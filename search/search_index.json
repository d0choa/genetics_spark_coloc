{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open Targets Genetics","text":"<p>Ingestion and analysis of genetic and functional genomic data for the identification and prioritisation of drug targets.</p> <p>This project is still in experimental phase. Please refer to the roadmap section for more information.</p> <p>For all development information, including running the code, troubleshooting, or contributing, see the development section.</p>"},{"location":"installation/","title":"Installation","text":"<p>TBC</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>The Open Targets core team is working on refactoring Open Targets Genetics, aiming to:</p> <ul> <li>Re-focus the product around Target ID</li> <li>Create a gold standard toolkit for post-GWAS analysis</li> <li>Faster/robust addition of new datasets and datatypes</li> <li>Reduce computational and financial cost</li> </ul> <p>See here for a list of open issues for this project.</p> <p>Schematic diagram representing the drafted process:</p> <p></p>"},{"location":"usage/","title":"How-to","text":"<p>TBC</p>"},{"location":"development/_development/","title":"Development","text":"<p>This section contains various technical information on how to develop and run the code.</p>"},{"location":"development/airflow/","title":"Airflow configuration","text":"<p>This section describes how to set up a local Airflow server which will orchestrate running workflows in Google Cloud Platform. This is useful for testing and debugging, but for production use, it is recommended to run Airflow on a dedicated server.</p>"},{"location":"development/airflow/#install-pre-requisites","title":"Install pre-requisites","text":"<ul> <li>Docker</li> <li>Google Cloud SDK</li> </ul> <p>Warning</p> <p>On macOS, the default amount of memory available for Docker might not be enough to get Airflow up and running. Allocate at least 4GB of memory for the Docker Engine (ideally 8GB). More info</p>"},{"location":"development/airflow/#configure-airflow-access-to-google-cloud-platform","title":"Configure Airflow access to Google Cloud Platform","text":"<p>Warning</p> <p>Run the next two command with the appropriate Google Cloud project ID and service account name to ensure the correct Google default application credentials are set up.</p> <p>Authenticate to Google Cloud:</p> <pre><code>gcloud auth application-default login --project=&lt;PROJECT&gt;\n</code></pre> <p>Create the service account key file that will be used by Airflow to access Google Cloud Platform resources:</p> <pre><code>gcloud iam service-accounts keys create ~/.config/gcloud/service_account_credentials.json --iam-account=&lt;PROJECT&gt;@appspot.gserviceaccount.com\n</code></pre>"},{"location":"development/airflow/#set-up-airflow","title":"Set up Airflow","text":"<p>Change the working directory so that all subsequent commands will work:</p> <pre><code>cd src/airflow\n</code></pre>"},{"location":"development/airflow/#build-docker-image","title":"Build Docker image","text":"<p>Note</p> <p>The custom Dockerfile built by the command below extends the official Airflow Docker Compose YAML. We add support for Google Cloud SDK, Google Dataproc operators, and access to GCP credentials.</p> <pre><code>docker build . --tag extending_airflow:latest\n</code></pre>"},{"location":"development/airflow/#set-airflow-user-id","title":"Set Airflow user ID","text":"<p>Note</p> <p>These commands allow Airflow running inside Docker to access the credentials file which was generated earlier.</p> <pre><code># If any user ID is already specified in .env, remove it.\ngrep -v \"AIRFLOW_UID\" .env &gt; .env.tmp\n# Add the correct user ID.\necho \"AIRFLOW_UID=$(id -u)\" &gt;&gt; .env.tmp\n# Move the file.\nmv .env.tmp .env\n</code></pre>"},{"location":"development/airflow/#initialise","title":"Initialise","text":"<p>Before starting Airflow, initialise the database:</p> <pre><code>docker compose up airflow-init\n</code></pre> <p>Now start all services:</p> <pre><code>docker compose up -d\n</code></pre> <p>Airflow UI will now be available at <code>http://localhost:8080/</code>. Default username and password are both <code>airflow</code>.</p> <p>For additional information on how to use Airflow visit the official documentation.</p>"},{"location":"development/airflow/#cleaning-up","title":"Cleaning up","text":"<p>At any time, you can check the status of your containers with:</p> <pre><code>docker ps\n</code></pre> <p>To stop Airflow, run:</p> <pre><code>docker compose down\n</code></pre> <p>To cleanup the Airflow database, run:</p> <pre><code>docker compose down --volumes --remove-orphans\n</code></pre>"},{"location":"development/airflow/#advanced-configuration","title":"Advanced configuration","text":"<p>More information on running Airflow with Docker Compose can be found in the official docs.</p> <ol> <li> <p>Increase Airflow concurrency. Modify the <code>docker-compose.yaml</code> and add the following to the x-airflow-common \u2192 environment section:</p> <pre><code>AIRFLOW__CORE__PARALLELISM: 32\nAIRFLOW__CORE__MAX_ACTIVE_TASKS_PER_DAG: 32\nAIRFLOW__SCHEDULER__MAX_TIS_PER_QUERY: 16\nAIRFLOW__CORE__MAX_ACTIVE_RUNS_PER_DAG: 1\n# Also add the following line if you are using CeleryExecutor (by default, LocalExecutor is used).\nAIRFLOW__CELERY__WORKER_CONCURRENCY: 32\n</code></pre> </li> <li> <p>Additional pip packages. They can be added to the <code>requirements.txt</code> file.</p> </li> </ol>"},{"location":"development/airflow/#troubleshooting","title":"Troubleshooting","text":"<p>Note that when you a a new workflow under <code>dags/</code>, Airflow will not pick that up immediately. By default the filesystem is only scanned for new DAGs every 300s. However, once the DAG is added, updates are applied nearly instantaneously.</p> <p>Also, if you edit the DAG while an instance of it is running, it might cause problems with the run, as Airflow will try to update the tasks and their properties in DAG according to the file changes.</p>"},{"location":"development/contributing/","title":"Contributing guidelines","text":""},{"location":"development/contributing/#one-time-configuration","title":"One-time configuration","text":"<p>The steps in this section only ever need to be done once on any particular system.</p> <p>Google Cloud configuration:</p> <ol> <li> <p>Install Google Cloud SDK: https://cloud.google.com/sdk/docs/install.</p> </li> <li> <p>Log in to your work Google Account: run <code>gcloud auth login</code> and follow instructions.</p> </li> <li> <p>Obtain Google application credentials: run <code>gcloud auth application-default login</code> and follow instructions.</p> </li> </ol> <p>Check that you have the <code>make</code> utility installed, and if not (which is unlikely), install it using your system package manager.</p> <p>Check that you have <code>java</code> installed.</p>"},{"location":"development/contributing/#environment-configuration","title":"Environment configuration","text":"<p>Run <code>make setup-dev</code> to install/update the necessary packages and activate the development environment. You need to do this every time you open a new shell.</p> <p>It is recommended to use VS Code as an IDE for development.</p>"},{"location":"development/contributing/#how-to-run-the-code","title":"How to run the code","text":"<p>All pipelines in this repository are intended to be run in Google Dataproc. Running them locally is not currently supported.</p> <p>In order to run the code:</p> <ol> <li> <p>Manually edit your local <code>src/airflow/dags/*</code> file and comment out the steps you do not want to run.</p> </li> <li> <p>Manually edit your local <code>pyproject.toml</code> file and modify the version of the code.</p> <ul> <li>This must be different from the version used by any other people working on the repository to avoid any deployment conflicts, so it's a good idea to use your name, for example: <code>1.2.3+jdoe</code>.</li> <li>You can also add a brief branch description, for example: <code>1.2.3+jdoe.myfeature</code>.</li> <li>Note that the version must comply with PEP440 conventions, otherwise Poetry will not allow it to be deployed.</li> <li>Do not use underscores or hyphens in your version name. When building the WHL file, they will be automatically converted to dots, which means the file name will no longer match the version and the build will fail. Use dots instead.</li> </ul> </li> <li> <p>Manually edit your local <code>src/airflow/dags/common_airflow.py</code> and set <code>OTG_VERSION</code> to the same version as you did in the previous step.</p> </li> <li> <p>Run <code>make build</code>.</p> <ul> <li>This will create a bundle containing the neccessary code, configuration and dependencies to run the ETL pipeline, and then upload this bundle to Google Cloud.</li> <li>A version specific subpath is used, so uploading the code will not affect any branches but your own.</li> <li>If there was already a code bundle uploaded with the same version number, it will be replaced.</li> </ul> </li> <li> <p>Open Airflow UI and run the DAG.</p> </li> </ol>"},{"location":"development/contributing/#contributing-checklist","title":"Contributing checklist","text":"<p>When making changes, and especially when implementing a new module or feature, it's essential to ensure that all relevant sections of the code base are modified. - [ ] Run <code>make check</code>. This will run the linter and formatter to ensure that the code is compliant with the project conventions. - [ ] Develop unit tests for your code and run <code>make test</code>. This will run all unit tests in the repository, including the examples appended in the docstrings of some methods. - [ ] Update the configuration if necessary. - [ ] Update the documentation and check it with <code>make build-documentation</code>. This will start a local server to browse it (URL will be printed, usually <code>http://127.0.0.1:8000/</code>)</p> <p>For more details on each of these steps, see the sections below.</p>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>If during development you had a question which wasn't covered in the documentation, and someone explained it to you, add it to the documentation. The same applies if you encountered any instructions in the documentation which were obsolete or incorrect.</li> <li>Documentation autogeneration expressions start with <code>:::</code>. They will automatically generate sections of the documentation based on class and method docstrings. Be sure to update them for:</li> <li>Dataset definitions in <code>docs/python_api/datasource/STEP</code> (example: <code>docs/python_api/datasource/finngen/study_index.md</code>)</li> <li>Step definition in <code>docs/python_api/step/STEP.md</code> (example: <code>docs/python_api/step/finngen.md</code>)</li> </ul>"},{"location":"development/contributing/#configuration","title":"Configuration","text":"<ul> <li>Input and output paths in <code>config/datasets/gcp.yaml</code></li> <li>Step configuration in <code>config/step/STEP.yaml</code> (example: <code>config/step/finngen.yaml</code>)</li> </ul>"},{"location":"development/contributing/#classes","title":"Classes","text":"<ul> <li>Dataset class in <code>src/otg/datasource/STEP</code> (example: <code>src/otg/datasource/finngen/study_index.py</code> \u2192 <code>FinnGenStudyIndex</code>)</li> <li>Step main running class in <code>src/otg/STEP.py</code> (example: <code>src/otg/finngen.py</code>)</li> </ul>"},{"location":"development/contributing/#tests","title":"Tests","text":"<ul> <li>Test study fixture in <code>tests/conftest.py</code> (example: <code>mock_study_index_finngen</code> in that module)</li> <li>Test sample data in <code>tests/data_samples</code> (example: <code>tests/data_samples/finngen_studies_sample.json</code>)</li> <li>Test definition in <code>tests/</code> (example: <code>tests/dataset/test_study_index.py</code> \u2192 <code>test_study_index_finngen_creation</code>)</li> </ul>"},{"location":"development/troubleshooting/","title":"Troubleshooting","text":""},{"location":"development/troubleshooting/#blaslapack","title":"BLAS/LAPACK","text":"<p>If you see errors related to BLAS/LAPACK libraries, see this StackOverflow post for guidance.</p>"},{"location":"development/troubleshooting/#pyenv-and-poetry","title":"Pyenv and Poetry","text":"<p>If you see various errors thrown by Pyenv or Poetry, they can be hard to specifically diagnose and resolve. In this case, it often helps to remove those tools from the system completely. Follow these steps:</p> <ol> <li>Close your currently activated environment, if any: <code>exit</code></li> <li>Uninstall Poetry: <code>curl -sSL https://install.python-poetry.org | python3 - --uninstall</code></li> <li>Clear Poetry cache: <code>rm -rf ~/.cache/pypoetry</code></li> <li>Clear pre-commit cache: <code>rm -rf ~/.cache/pre-commit</code></li> <li>Switch to system Python shell: <code>pyenv shell system</code></li> <li>Edit <code>~/.bashrc</code> to remove the lines related to Pyenv configuration</li> <li>Remove Pyenv configuration and cache: <code>rm -rf ~/.pyenv</code></li> </ol> <p>After that, open a fresh shell session and run <code>make setup-dev</code> again.</p>"},{"location":"development/troubleshooting/#java","title":"Java","text":"<p>Officially, PySpark requires Java version 8 (a.k.a. 1.8) or above to work. However, if you have a very recent version of Java, you may experience issues, as it may introduce breaking changes that PySpark hasn't had time to integrate. For example, as of May 2023, PySpark did not work with Java 20.</p> <p>If you are encountering problems with initialising a Spark session, try using Java 11.</p>"},{"location":"development/troubleshooting/#pre-commit","title":"Pre-commit","text":"<p>If you see an error message thrown by pre-commit, which looks like this (<code>SyntaxError: Unexpected token '?'</code>), followed by a JavaScript traceback, the issue is likely with your system NodeJS version.</p> <p>One solution which can help in this case is to upgrade your system NodeJS version. However, this may not always be possible. For example, Ubuntu repository is several major versions behind the latest version as of July 2023.</p> <p>Another solution which helps is to remove Node, NodeJS, and npm from your system entirely. In this case, pre-commit will not try to rely on a system version of NodeJS and will install its own, suitable one.</p> <p>On Ubuntu, this can be done using <code>sudo apt remove node nodejs npm</code>, followed by <code>sudo apt autoremove</code>. But in some cases, depending on your existing installation, you may need to also manually remove some files. See this StackOverflow answer for guidance.</p> <p>After running these commands, you are advised to open a fresh shell, and then also reinstall Pyenv and Poetry to make sure they pick up the changes (see relevant section above).</p>"},{"location":"development/workflows/","title":"Pipeline workflows","text":"<p>This page describes the high level components of the pipeline, which are organised as Airflow DAGs (directed acyclic graphs).</p>"},{"location":"development/workflows/#note-on-dags-and-dataproc-clusters","title":"Note on DAGs and Dataproc clusters","text":"<p>Each DAG consists of the following general stages:</p> <ol> <li> <p>Create cluster (if it already exists, this step is skipped)</p> </li> <li> <p>Install dependencies on the cluster</p> </li> <li> <p>Run data processing steps for this DAG</p> </li> <li> <p>Delete the cluster</p> </li> </ol> <p>Within a DAG, all data processing steps run on the same Dataproc cluster as separate jobs.</p> <p>There is no need to configure DAGs or steps depending on the size of the input data. Clusters have autoscaling enabled, which means they will increase or decrease the number of worker VMs to accommodate the load.</p>"},{"location":"development/workflows/#dag-1-preprocess","title":"DAG 1: Preprocess","text":"<p>This DAG contains steps which are only supposed to be run once, or very rarely. They ingest external data and apply bespoke transformations specific for each particular data source. The output is normalised according to the data schemas used by the pipeline.</p>"},{"location":"development/workflows/#dag-2-etl","title":"DAG 2: ETL","text":"<p>The ETL DAG takes the inputs of the previous step and performs the main algorithmic processing. This processing is supposed to be data source agnostic.</p>"},{"location":"python_api/dataset/_dataset/","title":"Dataset","text":""},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset","title":"<code>otg.dataset.dataset.Dataset</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Open Targets Genetics Dataset.</p> <p><code>Dataset</code> is a wrapper around a Spark DataFrame with a predefined schema. Schemas for each child dataset are described in the <code>schemas</code> module.</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>@dataclass\nclass Dataset(ABC):\n    \"\"\"Open Targets Genetics Dataset.\n\n    `Dataset` is a wrapper around a Spark DataFrame with a predefined schema. Schemas for each child dataset are described in the `schemas` module.\n    \"\"\"\n\n    _df: DataFrame\n    _schema: StructType\n\n    def __post_init__(self: Dataset) -&gt; None:\n        \"\"\"Post init.\"\"\"\n        self.validate_schema()\n\n    @property\n    def df(self: Dataset) -&gt; DataFrame:\n        \"\"\"Dataframe included in the Dataset.\n\n        Returns:\n            DataFrame: Dataframe included in the Dataset\n        \"\"\"\n        return self._df\n\n    @df.setter\n    def df(self: Dataset, new_df: DataFrame) -&gt; None:  # noqa: CCE001\n        \"\"\"Dataframe setter.\n\n        Args:\n            new_df (DataFrame): New dataframe to be included in the Dataset\n        \"\"\"\n        self._df: DataFrame = new_df\n        self.validate_schema()\n\n    @property\n    def schema(self: Dataset) -&gt; StructType:\n        \"\"\"Dataframe expected schema.\n\n        Returns:\n            StructType: Dataframe expected schema\n        \"\"\"\n        return self._schema\n\n    @classmethod\n    @abstractmethod\n    def get_schema(cls: type[Self]) -&gt; StructType:\n        \"\"\"Abstract method to get the schema. Must be implemented by child classes.\n\n        Returns:\n            StructType: Schema for the Dataset\n        \"\"\"\n        pass\n\n    @classmethod\n    def from_parquet(\n        cls: type[Self],\n        session: Session,\n        path: str,\n        **kwargs: bool | float | int | str | None,\n    ) -&gt; Self:\n        \"\"\"Reads a parquet file into a Dataset with a given schema.\n\n        Args:\n            session (Session): Spark session\n            path (str): Path to the parquet file\n            **kwargs (bool | float | int | str | None): Additional arguments to pass to spark.read.parquet\n\n        Returns:\n            Self: Dataset with the parquet file contents\n\n        Raises:\n            ValueError: Parquet file is empty\n        \"\"\"\n        schema = cls.get_schema()\n        df = session.read_parquet(path=path, schema=schema, **kwargs)\n        if df.isEmpty():\n            raise ValueError(f\"Parquet file is empty: {path}\")\n        return cls(_df=df, _schema=schema)\n\n    def validate_schema(self: Dataset) -&gt; None:\n        \"\"\"Validate DataFrame schema against expected class schema.\n\n        Raises:\n            ValueError: DataFrame schema is not valid\n        \"\"\"\n        expected_schema = self._schema\n        expected_fields = flatten_schema(expected_schema)\n        observed_schema = self._df.schema\n        observed_fields = flatten_schema(observed_schema)\n\n        # Unexpected fields in dataset\n        if unexpected_field_names := [\n            x.name\n            for x in observed_fields\n            if x.name not in [y.name for y in expected_fields]\n        ]:\n            raise ValueError(\n                f\"The {unexpected_field_names} fields are not included in DataFrame schema: {expected_fields}\"\n            )\n\n        # Required fields not in dataset\n        required_fields = [x.name for x in expected_schema if not x.nullable]\n        if missing_required_fields := [\n            req\n            for req in required_fields\n            if not any(field.name == req for field in observed_fields)\n        ]:\n            raise ValueError(\n                f\"The {missing_required_fields} fields are required but missing: {required_fields}\"\n            )\n\n        # Fields with duplicated names\n        if duplicated_fields := [\n            x for x in set(observed_fields) if observed_fields.count(x) &gt; 1\n        ]:\n            raise ValueError(\n                f\"The following fields are duplicated in DataFrame schema: {duplicated_fields}\"\n            )\n\n        # Fields with different datatype\n        observed_field_types = {\n            field.name: type(field.dataType) for field in observed_fields\n        }\n        expected_field_types = {\n            field.name: type(field.dataType) for field in expected_fields\n        }\n        if fields_with_different_observed_datatype := [\n            name\n            for name, observed_type in observed_field_types.items()\n            if name in expected_field_types\n            and observed_type != expected_field_types[name]\n        ]:\n            raise ValueError(\n                f\"The following fields present differences in their datatypes: {fields_with_different_observed_datatype}.\"\n            )\n\n    def persist(self: Self) -&gt; Self:\n        \"\"\"Persist in memory the DataFrame included in the Dataset.\n\n        Returns:\n            Self: Persisted Dataset\n        \"\"\"\n        self.df = self._df.persist()\n        return self\n\n    def unpersist(self: Self) -&gt; Self:\n        \"\"\"Remove the persisted DataFrame from memory.\n\n        Returns:\n            Self: Unpersisted Dataset\n        \"\"\"\n        self.df = self._df.unpersist()\n        return self\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.df","title":"<code>df: DataFrame</code>  <code>property</code> <code>writable</code>","text":"<p>Dataframe included in the Dataset.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Dataframe included in the Dataset</p>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.schema","title":"<code>schema: StructType</code>  <code>property</code>","text":"<p>Dataframe expected schema.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Dataframe expected schema</p>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.from_parquet","title":"<code>from_parquet(session: Session, path: str, **kwargs: bool | float | int | str | None) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Reads a parquet file into a Dataset with a given schema.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to the parquet file</p> required <code>**kwargs</code> <code>bool | float | int | str | None</code> <p>Additional arguments to pass to spark.read.parquet</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Dataset with the parquet file contents</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Parquet file is empty</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>@classmethod\ndef from_parquet(\n    cls: type[Self],\n    session: Session,\n    path: str,\n    **kwargs: bool | float | int | str | None,\n) -&gt; Self:\n    \"\"\"Reads a parquet file into a Dataset with a given schema.\n\n    Args:\n        session (Session): Spark session\n        path (str): Path to the parquet file\n        **kwargs (bool | float | int | str | None): Additional arguments to pass to spark.read.parquet\n\n    Returns:\n        Self: Dataset with the parquet file contents\n\n    Raises:\n        ValueError: Parquet file is empty\n    \"\"\"\n    schema = cls.get_schema()\n    df = session.read_parquet(path=path, schema=schema, **kwargs)\n    if df.isEmpty():\n        raise ValueError(f\"Parquet file is empty: {path}\")\n    return cls(_df=df, _schema=schema)\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Abstract method to get the schema. Must be implemented by child classes.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the Dataset</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_schema(cls: type[Self]) -&gt; StructType:\n    \"\"\"Abstract method to get the schema. Must be implemented by child classes.\n\n    Returns:\n        StructType: Schema for the Dataset\n    \"\"\"\n    pass\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.persist","title":"<code>persist() -&gt; Self</code>","text":"<p>Persist in memory the DataFrame included in the Dataset.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Persisted Dataset</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>def persist(self: Self) -&gt; Self:\n    \"\"\"Persist in memory the DataFrame included in the Dataset.\n\n    Returns:\n        Self: Persisted Dataset\n    \"\"\"\n    self.df = self._df.persist()\n    return self\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.unpersist","title":"<code>unpersist() -&gt; Self</code>","text":"<p>Remove the persisted DataFrame from memory.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Unpersisted Dataset</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>def unpersist(self: Self) -&gt; Self:\n    \"\"\"Remove the persisted DataFrame from memory.\n\n    Returns:\n        Self: Unpersisted Dataset\n    \"\"\"\n    self.df = self._df.unpersist()\n    return self\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.validate_schema","title":"<code>validate_schema() -&gt; None</code>","text":"<p>Validate DataFrame schema against expected class schema.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>DataFrame schema is not valid</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>def validate_schema(self: Dataset) -&gt; None:\n    \"\"\"Validate DataFrame schema against expected class schema.\n\n    Raises:\n        ValueError: DataFrame schema is not valid\n    \"\"\"\n    expected_schema = self._schema\n    expected_fields = flatten_schema(expected_schema)\n    observed_schema = self._df.schema\n    observed_fields = flatten_schema(observed_schema)\n\n    # Unexpected fields in dataset\n    if unexpected_field_names := [\n        x.name\n        for x in observed_fields\n        if x.name not in [y.name for y in expected_fields]\n    ]:\n        raise ValueError(\n            f\"The {unexpected_field_names} fields are not included in DataFrame schema: {expected_fields}\"\n        )\n\n    # Required fields not in dataset\n    required_fields = [x.name for x in expected_schema if not x.nullable]\n    if missing_required_fields := [\n        req\n        for req in required_fields\n        if not any(field.name == req for field in observed_fields)\n    ]:\n        raise ValueError(\n            f\"The {missing_required_fields} fields are required but missing: {required_fields}\"\n        )\n\n    # Fields with duplicated names\n    if duplicated_fields := [\n        x for x in set(observed_fields) if observed_fields.count(x) &gt; 1\n    ]:\n        raise ValueError(\n            f\"The following fields are duplicated in DataFrame schema: {duplicated_fields}\"\n        )\n\n    # Fields with different datatype\n    observed_field_types = {\n        field.name: type(field.dataType) for field in observed_fields\n    }\n    expected_field_types = {\n        field.name: type(field.dataType) for field in expected_fields\n    }\n    if fields_with_different_observed_datatype := [\n        name\n        for name, observed_type in observed_field_types.items()\n        if name in expected_field_types\n        and observed_type != expected_field_types[name]\n    ]:\n        raise ValueError(\n            f\"The following fields present differences in their datatypes: {fields_with_different_observed_datatype}.\"\n        )\n</code></pre>"},{"location":"python_api/dataset/colocalisation/","title":"Colocalisation","text":""},{"location":"python_api/dataset/colocalisation/#otg.dataset.colocalisation.Colocalisation","title":"<code>otg.dataset.colocalisation.Colocalisation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Colocalisation results for pairs of overlapping study-locus.</p> Source code in <code>src/otg/dataset/colocalisation.py</code> <pre><code>@dataclass\nclass Colocalisation(Dataset):\n    \"\"\"Colocalisation results for pairs of overlapping study-locus.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[Colocalisation]) -&gt; StructType:\n        \"\"\"Provides the schema for the Colocalisation dataset.\n\n        Returns:\n            StructType: Schema for the Colocalisation dataset\n        \"\"\"\n        return parse_spark_schema(\"colocalisation.json\")\n</code></pre>"},{"location":"python_api/dataset/colocalisation/#otg.dataset.colocalisation.Colocalisation.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the Colocalisation dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the Colocalisation dataset</p> Source code in <code>src/otg/dataset/colocalisation.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[Colocalisation]) -&gt; StructType:\n    \"\"\"Provides the schema for the Colocalisation dataset.\n\n    Returns:\n        StructType: Schema for the Colocalisation dataset\n    \"\"\"\n    return parse_spark_schema(\"colocalisation.json\")\n</code></pre>"},{"location":"python_api/dataset/colocalisation/#schema","title":"Schema","text":"<pre><code>root\n |-- leftStudyLocusId: long (nullable = false)\n |-- rightStudyLocusId: long (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- colocalisationMethod: string (nullable = false)\n |-- numberColocalisingVariants: long (nullable = false)\n |-- h0: double (nullable = true)\n |-- h1: double (nullable = true)\n |-- h2: double (nullable = true)\n |-- h3: double (nullable = true)\n |-- h4: double (nullable = true)\n |-- log2h4h3: double (nullable = true)\n |-- clpp: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/gene_index/","title":"Gene Index","text":""},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex","title":"<code>otg.dataset.gene_index.GeneIndex</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Gene index dataset.</p> <p>Gene-based annotation.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>@dataclass\nclass GeneIndex(Dataset):\n    \"\"\"Gene index dataset.\n\n    Gene-based annotation.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[GeneIndex]) -&gt; StructType:\n        \"\"\"Provides the schema for the GeneIndex dataset.\n\n        Returns:\n            StructType: Schema for the GeneIndex dataset\n        \"\"\"\n        return parse_spark_schema(\"gene_index.json\")\n\n    def filter_by_biotypes(self: GeneIndex, biotypes: list[str]) -&gt; GeneIndex:\n        \"\"\"Filter by approved biotypes.\n\n        Args:\n            biotypes (list[str]): List of Ensembl biotypes to keep.\n\n        Returns:\n            GeneIndex: Gene index dataset filtered by biotypes.\n        \"\"\"\n        self.df = self._df.filter(f.col(\"biotype\").isin(biotypes))\n        return self\n\n    def locations_lut(self: GeneIndex) -&gt; DataFrame:\n        \"\"\"Gene location information.\n\n        Returns:\n            DataFrame: Gene LUT including genomic location information.\n        \"\"\"\n        return self.df.select(\n            \"geneId\",\n            \"chromosome\",\n            \"start\",\n            \"end\",\n            \"strand\",\n            \"tss\",\n        )\n\n    def symbols_lut(self: GeneIndex) -&gt; DataFrame:\n        \"\"\"Gene symbol lookup table.\n\n        Pre-processess gene/target dataset to create lookup table of gene symbols, including\n        obsoleted gene symbols.\n\n        Returns:\n            DataFrame: Gene LUT for symbol mapping containing `geneId` and `geneSymbol` columns.\n        \"\"\"\n        return self.df.select(\n            f.explode(\n                f.array_union(f.array(\"approvedSymbol\"), f.col(\"obsoleteSymbols\"))\n            ).alias(\"geneSymbol\"),\n            \"*\",\n        )\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.filter_by_biotypes","title":"<code>filter_by_biotypes(biotypes: list[str]) -&gt; GeneIndex</code>","text":"<p>Filter by approved biotypes.</p> <p>Parameters:</p> Name Type Description Default <code>biotypes</code> <code>list[str]</code> <p>List of Ensembl biotypes to keep.</p> required <p>Returns:</p> Name Type Description <code>GeneIndex</code> <code>GeneIndex</code> <p>Gene index dataset filtered by biotypes.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>def filter_by_biotypes(self: GeneIndex, biotypes: list[str]) -&gt; GeneIndex:\n    \"\"\"Filter by approved biotypes.\n\n    Args:\n        biotypes (list[str]): List of Ensembl biotypes to keep.\n\n    Returns:\n        GeneIndex: Gene index dataset filtered by biotypes.\n    \"\"\"\n    self.df = self._df.filter(f.col(\"biotype\").isin(biotypes))\n    return self\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the GeneIndex dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the GeneIndex dataset</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[GeneIndex]) -&gt; StructType:\n    \"\"\"Provides the schema for the GeneIndex dataset.\n\n    Returns:\n        StructType: Schema for the GeneIndex dataset\n    \"\"\"\n    return parse_spark_schema(\"gene_index.json\")\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.locations_lut","title":"<code>locations_lut() -&gt; DataFrame</code>","text":"<p>Gene location information.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Gene LUT including genomic location information.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>def locations_lut(self: GeneIndex) -&gt; DataFrame:\n    \"\"\"Gene location information.\n\n    Returns:\n        DataFrame: Gene LUT including genomic location information.\n    \"\"\"\n    return self.df.select(\n        \"geneId\",\n        \"chromosome\",\n        \"start\",\n        \"end\",\n        \"strand\",\n        \"tss\",\n    )\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.symbols_lut","title":"<code>symbols_lut() -&gt; DataFrame</code>","text":"<p>Gene symbol lookup table.</p> <p>Pre-processess gene/target dataset to create lookup table of gene symbols, including obsoleted gene symbols.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Gene LUT for symbol mapping containing <code>geneId</code> and <code>geneSymbol</code> columns.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>def symbols_lut(self: GeneIndex) -&gt; DataFrame:\n    \"\"\"Gene symbol lookup table.\n\n    Pre-processess gene/target dataset to create lookup table of gene symbols, including\n    obsoleted gene symbols.\n\n    Returns:\n        DataFrame: Gene LUT for symbol mapping containing `geneId` and `geneSymbol` columns.\n    \"\"\"\n    return self.df.select(\n        f.explode(\n            f.array_union(f.array(\"approvedSymbol\"), f.col(\"obsoleteSymbols\"))\n        ).alias(\"geneSymbol\"),\n        \"*\",\n    )\n</code></pre>"},{"location":"python_api/dataset/gene_index/#schema","title":"Schema","text":"<pre><code>root\n |-- geneId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- approvedSymbol: string (nullable = true)\n |-- biotype: string (nullable = true)\n |-- approvedName: string (nullable = true)\n |-- obsoleteSymbols: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- tss: long (nullable = true)\n |-- start: long (nullable = true)\n |-- end: long (nullable = true)\n |-- strand: integer (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/intervals/","title":"Intervals","text":""},{"location":"python_api/dataset/intervals/#otg.dataset.intervals.Intervals","title":"<code>otg.dataset.intervals.Intervals</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Intervals dataset links genes to genomic regions based on genome interaction studies.</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>@dataclass\nclass Intervals(Dataset):\n    \"\"\"Intervals dataset links genes to genomic regions based on genome interaction studies.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[Intervals]) -&gt; StructType:\n        \"\"\"Provides the schema for the Intervals dataset.\n\n        Returns:\n            StructType: Schema for the Intervals dataset\n        \"\"\"\n        return parse_spark_schema(\"intervals.json\")\n\n    @classmethod\n    def from_source(\n        cls: type[Intervals],\n        spark: SparkSession,\n        source_name: str,\n        source_path: str,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; Intervals:\n        \"\"\"Collect interval data for a particular source.\n\n        Args:\n            spark (SparkSession): Spark session\n            source_name (str): Name of the interval source\n            source_path (str): Path to the interval source file\n            gene_index (GeneIndex): Gene index\n            lift (LiftOverSpark): LiftOverSpark instance to convert coordinats from hg37 to hg38\n\n        Returns:\n            Intervals: Intervals dataset\n\n        Raises:\n            ValueError: If the source name is not recognised\n        \"\"\"\n        from otg.datasource.intervals.andersson import IntervalsAndersson\n        from otg.datasource.intervals.javierre import IntervalsJavierre\n        from otg.datasource.intervals.jung import IntervalsJung\n        from otg.datasource.intervals.thurman import IntervalsThurman\n\n        source_to_class = {\n            \"andersson\": IntervalsAndersson,\n            \"javierre\": IntervalsJavierre,\n            \"jung\": IntervalsJung,\n            \"thurman\": IntervalsThurman,\n        }\n\n        if source_name not in source_to_class:\n            raise ValueError(f\"Unknown interval source: {source_name}\")\n\n        source_class = source_to_class[source_name]\n        data = source_class.read(spark, source_path)  # type: ignore\n        return source_class.parse(data, gene_index, lift)  # type: ignore\n\n    def v2g(self: Intervals, variant_index: VariantIndex) -&gt; V2G:\n        \"\"\"Convert intervals into V2G by intersecting with a variant index.\n\n        Args:\n            variant_index (VariantIndex): Variant index dataset\n\n        Returns:\n            V2G: Variant-to-gene evidence dataset\n        \"\"\"\n        return V2G(\n            _df=(\n                self.df.alias(\"interval\")\n                .join(\n                    variant_index.df.selectExpr(\n                        \"chromosome as vi_chromosome\", \"variantId\", \"position\"\n                    ).alias(\"vi\"),\n                    on=[\n                        f.col(\"vi.vi_chromosome\") == f.col(\"interval.chromosome\"),\n                        f.col(\"vi.position\").between(\n                            f.col(\"interval.start\"), f.col(\"interval.end\")\n                        ),\n                    ],\n                    how=\"inner\",\n                )\n                .drop(\"start\", \"end\", \"vi_chromosome\", \"position\")\n            ),\n            _schema=V2G.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/intervals/#otg.dataset.intervals.Intervals.from_source","title":"<code>from_source(spark: SparkSession, source_name: str, source_path: str, gene_index: GeneIndex, lift: LiftOverSpark) -&gt; Intervals</code>  <code>classmethod</code>","text":"<p>Collect interval data for a particular source.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>source_name</code> <code>str</code> <p>Name of the interval source</p> required <code>source_path</code> <code>str</code> <p>Path to the interval source file</p> required <code>gene_index</code> <code>GeneIndex</code> <p>Gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance to convert coordinats from hg37 to hg38</p> required <p>Returns:</p> Name Type Description <code>Intervals</code> <code>Intervals</code> <p>Intervals dataset</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the source name is not recognised</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[Intervals],\n    spark: SparkSession,\n    source_name: str,\n    source_path: str,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; Intervals:\n    \"\"\"Collect interval data for a particular source.\n\n    Args:\n        spark (SparkSession): Spark session\n        source_name (str): Name of the interval source\n        source_path (str): Path to the interval source file\n        gene_index (GeneIndex): Gene index\n        lift (LiftOverSpark): LiftOverSpark instance to convert coordinats from hg37 to hg38\n\n    Returns:\n        Intervals: Intervals dataset\n\n    Raises:\n        ValueError: If the source name is not recognised\n    \"\"\"\n    from otg.datasource.intervals.andersson import IntervalsAndersson\n    from otg.datasource.intervals.javierre import IntervalsJavierre\n    from otg.datasource.intervals.jung import IntervalsJung\n    from otg.datasource.intervals.thurman import IntervalsThurman\n\n    source_to_class = {\n        \"andersson\": IntervalsAndersson,\n        \"javierre\": IntervalsJavierre,\n        \"jung\": IntervalsJung,\n        \"thurman\": IntervalsThurman,\n    }\n\n    if source_name not in source_to_class:\n        raise ValueError(f\"Unknown interval source: {source_name}\")\n\n    source_class = source_to_class[source_name]\n    data = source_class.read(spark, source_path)  # type: ignore\n    return source_class.parse(data, gene_index, lift)  # type: ignore\n</code></pre>"},{"location":"python_api/dataset/intervals/#otg.dataset.intervals.Intervals.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the Intervals dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the Intervals dataset</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[Intervals]) -&gt; StructType:\n    \"\"\"Provides the schema for the Intervals dataset.\n\n    Returns:\n        StructType: Schema for the Intervals dataset\n    \"\"\"\n    return parse_spark_schema(\"intervals.json\")\n</code></pre>"},{"location":"python_api/dataset/intervals/#otg.dataset.intervals.Intervals.v2g","title":"<code>v2g(variant_index: VariantIndex) -&gt; V2G</code>","text":"<p>Convert intervals into V2G by intersecting with a variant index.</p> <p>Parameters:</p> Name Type Description Default <code>variant_index</code> <code>VariantIndex</code> <p>Variant index dataset</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>Variant-to-gene evidence dataset</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>def v2g(self: Intervals, variant_index: VariantIndex) -&gt; V2G:\n    \"\"\"Convert intervals into V2G by intersecting with a variant index.\n\n    Args:\n        variant_index (VariantIndex): Variant index dataset\n\n    Returns:\n        V2G: Variant-to-gene evidence dataset\n    \"\"\"\n    return V2G(\n        _df=(\n            self.df.alias(\"interval\")\n            .join(\n                variant_index.df.selectExpr(\n                    \"chromosome as vi_chromosome\", \"variantId\", \"position\"\n                ).alias(\"vi\"),\n                on=[\n                    f.col(\"vi.vi_chromosome\") == f.col(\"interval.chromosome\"),\n                    f.col(\"vi.position\").between(\n                        f.col(\"interval.start\"), f.col(\"interval.end\")\n                    ),\n                ],\n                how=\"inner\",\n            )\n            .drop(\"start\", \"end\", \"vi_chromosome\", \"position\")\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/intervals/#schema","title":"Schema","text":"<pre><code>root\n |-- chromosome: string (nullable = false)\n |-- start: string (nullable = false)\n |-- end: string (nullable = false)\n |-- geneId: string (nullable = false)\n |-- resourceScore: double (nullable = true)\n |-- score: double (nullable = true)\n |-- datasourceId: string (nullable = false)\n |-- datatypeId: string (nullable = false)\n |-- pmid: string (nullable = true)\n |-- biofeature: string (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/l2g_feature/","title":"L2G Feature","text":""},{"location":"python_api/dataset/l2g_feature/#otg.method.l2g.feature_factory.L2GFeature","title":"<code>otg.method.l2g.feature_factory.L2GFeature</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Locus-to-gene feature dataset.</p> Source code in <code>src/otg/dataset/l2g_feature.py</code> <pre><code>@dataclass\nclass L2GFeature(Dataset):\n    \"\"\"Locus-to-gene feature dataset.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[L2GFeature]) -&gt; StructType:\n        \"\"\"Provides the schema for the L2GFeature dataset.\n\n        Returns:\n            StructType: Schema for the L2GFeature dataset\n        \"\"\"\n        return parse_spark_schema(\"l2g_feature.json\")\n</code></pre>"},{"location":"python_api/dataset/l2g_feature/#otg.method.l2g.feature_factory.L2GFeature.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the L2GFeature dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the L2GFeature dataset</p> Source code in <code>src/otg/dataset/l2g_feature.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[L2GFeature]) -&gt; StructType:\n    \"\"\"Provides the schema for the L2GFeature dataset.\n\n    Returns:\n        StructType: Schema for the L2GFeature dataset\n    \"\"\"\n    return parse_spark_schema(\"l2g_feature.json\")\n</code></pre>"},{"location":"python_api/dataset/l2g_feature/#schema","title":"Schema","text":"<pre><code>root\n |-- studyLocusId: long (nullable = false)\n |-- geneId: string (nullable = false)\n |-- featureName: string (nullable = false)\n |-- featureValue: float (nullable = false)\n</code></pre>"},{"location":"python_api/dataset/l2g_feature_matrix/","title":"L2G Feature Matrix","text":""},{"location":"python_api/dataset/l2g_feature_matrix/#otg.dataset.l2g_feature_matrix.L2GFeatureMatrix","title":"<code>otg.dataset.l2g_feature_matrix.L2GFeatureMatrix</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Dataset with features for Locus to Gene prediction.</p> Source code in <code>src/otg/dataset/l2g_feature_matrix.py</code> <pre><code>@dataclass\nclass L2GFeatureMatrix(Dataset):\n    \"\"\"Dataset with features for Locus to Gene prediction.\"\"\"\n\n    @classmethod\n    def generate_features(\n        cls: Type[L2GFeatureMatrix],\n        study_locus: StudyLocus,\n        study_index: StudyIndex,\n        variant_gene: V2G,\n        # colocalisation: Colocalisation,\n    ) -&gt; L2GFeatureMatrix:\n        \"\"\"Generate features from the OTG datasets.\n\n        Args:\n            study_locus (StudyLocus): Study locus dataset\n            study_index (StudyIndex): Study index dataset\n            variant_gene (V2G): Variant to gene dataset\n\n        Returns:\n            L2GFeatureMatrix: L2G feature matrix dataset\n\n        Raises:\n            ValueError: If the feature matrix is empty\n        \"\"\"\n        if features_dfs := [\n            # Extract features\n            # ColocalisationFactory._get_coloc_features(\n            #     study_locus, study_index, colocalisation\n            # ).df,\n            StudyLocusFactory._get_tss_distance_features(study_locus, variant_gene).df,\n        ]:\n            fm = reduce(\n                lambda x, y: x.unionByName(y),\n                features_dfs,\n            )\n        else:\n            raise ValueError(\"No features found\")\n\n        # raise error if the feature matrix is empty\n        if fm.limit(1).count() != 0:\n            return cls(\n                _df=convert_from_long_to_wide(\n                    fm, [\"studyLocusId\", \"geneId\"], \"featureName\", \"featureValue\"\n                ),\n                _schema=cls.get_schema(),\n            )\n        raise ValueError(\"L2G Feature matrix is empty\")\n\n    @classmethod\n    def get_schema(cls: type[L2GFeatureMatrix]) -&gt; StructType:\n        \"\"\"Provides the schema for the L2gFeatureMatrix dataset.\n\n        Returns:\n            StructType: Schema for the L2gFeatureMatrix dataset\n        \"\"\"\n        return parse_spark_schema(\"l2g_feature_matrix.json\")\n\n    def fill_na(\n        self: L2GFeatureMatrix, value: float = 0.0, subset: list[str] | None = None\n    ) -&gt; L2GFeatureMatrix:\n        \"\"\"Fill missing values in a column with a given value.\n\n        Args:\n            value (float): Value to replace missing values with. Defaults to 0.0.\n            subset (list[str] | None): Subset of columns to consider. Defaults to None.\n\n        Returns:\n            L2GFeatureMatrix: L2G feature matrix dataset\n        \"\"\"\n        self.df = self._df.fillna(value, subset=subset)\n        return self\n\n    def select_features(\n        self: L2GFeatureMatrix, features_list: list[str]\n    ) -&gt; L2GFeatureMatrix:\n        \"\"\"Select a subset of features from the feature matrix.\n\n        Args:\n            features_list (list[str]): List of features to select\n\n        Returns:\n            L2GFeatureMatrix: L2G feature matrix dataset\n        \"\"\"\n        fixed_rows = [\"studyLocusId\", \"geneId\", \"goldStandardSet\"]\n        self.df = self._df.select(fixed_rows + features_list)\n        return self\n\n    def train_test_split(\n        self: L2GFeatureMatrix, fraction: float\n    ) -&gt; tuple[L2GFeatureMatrix, L2GFeatureMatrix]:\n        \"\"\"Split the dataset into training and test sets.\n\n        Args:\n            fraction (float): Fraction of the dataset to use for training\n\n        Returns:\n            tuple[L2GFeatureMatrix, L2GFeatureMatrix]: Training and test datasets\n        \"\"\"\n        train, test = self._df.randomSplit([fraction, 1 - fraction], seed=42)\n        return (\n            L2GFeatureMatrix(\n                _df=train, _schema=L2GFeatureMatrix.get_schema()\n            ).persist(),\n            L2GFeatureMatrix(_df=test, _schema=L2GFeatureMatrix.get_schema()).persist(),\n        )\n</code></pre>"},{"location":"python_api/dataset/l2g_feature_matrix/#otg.dataset.l2g_feature_matrix.L2GFeatureMatrix.fill_na","title":"<code>fill_na(value: float = 0.0, subset: list[str] | None = None) -&gt; L2GFeatureMatrix</code>","text":"<p>Fill missing values in a column with a given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Value to replace missing values with. Defaults to 0.0.</p> <code>0.0</code> <code>subset</code> <code>list[str] | None</code> <p>Subset of columns to consider. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>L2GFeatureMatrix</code> <code>L2GFeatureMatrix</code> <p>L2G feature matrix dataset</p> Source code in <code>src/otg/dataset/l2g_feature_matrix.py</code> <pre><code>def fill_na(\n    self: L2GFeatureMatrix, value: float = 0.0, subset: list[str] | None = None\n) -&gt; L2GFeatureMatrix:\n    \"\"\"Fill missing values in a column with a given value.\n\n    Args:\n        value (float): Value to replace missing values with. Defaults to 0.0.\n        subset (list[str] | None): Subset of columns to consider. Defaults to None.\n\n    Returns:\n        L2GFeatureMatrix: L2G feature matrix dataset\n    \"\"\"\n    self.df = self._df.fillna(value, subset=subset)\n    return self\n</code></pre>"},{"location":"python_api/dataset/l2g_feature_matrix/#otg.dataset.l2g_feature_matrix.L2GFeatureMatrix.generate_features","title":"<code>generate_features(study_locus: StudyLocus, study_index: StudyIndex, variant_gene: V2G) -&gt; L2GFeatureMatrix</code>  <code>classmethod</code>","text":"<p>Generate features from the OTG datasets.</p> <p>Parameters:</p> Name Type Description Default <code>study_locus</code> <code>StudyLocus</code> <p>Study locus dataset</p> required <code>study_index</code> <code>StudyIndex</code> <p>Study index dataset</p> required <code>variant_gene</code> <code>V2G</code> <p>Variant to gene dataset</p> required <p>Returns:</p> Name Type Description <code>L2GFeatureMatrix</code> <code>L2GFeatureMatrix</code> <p>L2G feature matrix dataset</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the feature matrix is empty</p> Source code in <code>src/otg/dataset/l2g_feature_matrix.py</code> <pre><code>@classmethod\ndef generate_features(\n    cls: Type[L2GFeatureMatrix],\n    study_locus: StudyLocus,\n    study_index: StudyIndex,\n    variant_gene: V2G,\n    # colocalisation: Colocalisation,\n) -&gt; L2GFeatureMatrix:\n    \"\"\"Generate features from the OTG datasets.\n\n    Args:\n        study_locus (StudyLocus): Study locus dataset\n        study_index (StudyIndex): Study index dataset\n        variant_gene (V2G): Variant to gene dataset\n\n    Returns:\n        L2GFeatureMatrix: L2G feature matrix dataset\n\n    Raises:\n        ValueError: If the feature matrix is empty\n    \"\"\"\n    if features_dfs := [\n        # Extract features\n        # ColocalisationFactory._get_coloc_features(\n        #     study_locus, study_index, colocalisation\n        # ).df,\n        StudyLocusFactory._get_tss_distance_features(study_locus, variant_gene).df,\n    ]:\n        fm = reduce(\n            lambda x, y: x.unionByName(y),\n            features_dfs,\n        )\n    else:\n        raise ValueError(\"No features found\")\n\n    # raise error if the feature matrix is empty\n    if fm.limit(1).count() != 0:\n        return cls(\n            _df=convert_from_long_to_wide(\n                fm, [\"studyLocusId\", \"geneId\"], \"featureName\", \"featureValue\"\n            ),\n            _schema=cls.get_schema(),\n        )\n    raise ValueError(\"L2G Feature matrix is empty\")\n</code></pre>"},{"location":"python_api/dataset/l2g_feature_matrix/#otg.dataset.l2g_feature_matrix.L2GFeatureMatrix.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the L2gFeatureMatrix dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the L2gFeatureMatrix dataset</p> Source code in <code>src/otg/dataset/l2g_feature_matrix.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[L2GFeatureMatrix]) -&gt; StructType:\n    \"\"\"Provides the schema for the L2gFeatureMatrix dataset.\n\n    Returns:\n        StructType: Schema for the L2gFeatureMatrix dataset\n    \"\"\"\n    return parse_spark_schema(\"l2g_feature_matrix.json\")\n</code></pre>"},{"location":"python_api/dataset/l2g_feature_matrix/#otg.dataset.l2g_feature_matrix.L2GFeatureMatrix.select_features","title":"<code>select_features(features_list: list[str]) -&gt; L2GFeatureMatrix</code>","text":"<p>Select a subset of features from the feature matrix.</p> <p>Parameters:</p> Name Type Description Default <code>features_list</code> <code>list[str]</code> <p>List of features to select</p> required <p>Returns:</p> Name Type Description <code>L2GFeatureMatrix</code> <code>L2GFeatureMatrix</code> <p>L2G feature matrix dataset</p> Source code in <code>src/otg/dataset/l2g_feature_matrix.py</code> <pre><code>def select_features(\n    self: L2GFeatureMatrix, features_list: list[str]\n) -&gt; L2GFeatureMatrix:\n    \"\"\"Select a subset of features from the feature matrix.\n\n    Args:\n        features_list (list[str]): List of features to select\n\n    Returns:\n        L2GFeatureMatrix: L2G feature matrix dataset\n    \"\"\"\n    fixed_rows = [\"studyLocusId\", \"geneId\", \"goldStandardSet\"]\n    self.df = self._df.select(fixed_rows + features_list)\n    return self\n</code></pre>"},{"location":"python_api/dataset/l2g_feature_matrix/#otg.dataset.l2g_feature_matrix.L2GFeatureMatrix.train_test_split","title":"<code>train_test_split(fraction: float) -&gt; tuple[L2GFeatureMatrix, L2GFeatureMatrix]</code>","text":"<p>Split the dataset into training and test sets.</p> <p>Parameters:</p> Name Type Description Default <code>fraction</code> <code>float</code> <p>Fraction of the dataset to use for training</p> required <p>Returns:</p> Type Description <code>tuple[L2GFeatureMatrix, L2GFeatureMatrix]</code> <p>tuple[L2GFeatureMatrix, L2GFeatureMatrix]: Training and test datasets</p> Source code in <code>src/otg/dataset/l2g_feature_matrix.py</code> <pre><code>def train_test_split(\n    self: L2GFeatureMatrix, fraction: float\n) -&gt; tuple[L2GFeatureMatrix, L2GFeatureMatrix]:\n    \"\"\"Split the dataset into training and test sets.\n\n    Args:\n        fraction (float): Fraction of the dataset to use for training\n\n    Returns:\n        tuple[L2GFeatureMatrix, L2GFeatureMatrix]: Training and test datasets\n    \"\"\"\n    train, test = self._df.randomSplit([fraction, 1 - fraction], seed=42)\n    return (\n        L2GFeatureMatrix(\n            _df=train, _schema=L2GFeatureMatrix.get_schema()\n        ).persist(),\n        L2GFeatureMatrix(_df=test, _schema=L2GFeatureMatrix.get_schema()).persist(),\n    )\n</code></pre>"},{"location":"python_api/dataset/l2g_feature_matrix/#schema","title":"Schema","text":"<pre><code>root\n |-- studyLocusId: long (nullable = false)\n |-- geneId: string (nullable = false)\n |-- goldStandardSet: string (nullable = true)\n |-- distanceTssMean: float (nullable = true)\n |-- distanceTssMinimum: float (nullable = true)\n |-- eqtlColocClppLocalMaximum: double (nullable = true)\n |-- eqtlColocClppNeighborhoodMaximum: double (nullable = true)\n |-- eqtlColocLlrLocalMaximum: double (nullable = true)\n |-- eqtlColocLlrNeighborhoodMaximum: double (nullable = true)\n |-- pqtlColocClppLocalMaximum: double (nullable = true)\n |-- pqtlColocClppNeighborhoodMaximum: double (nullable = true)\n |-- pqtlColocLlrLocalMaximum: double (nullable = true)\n |-- pqtlColocLlrNeighborhoodMaximum: double (nullable = true)\n |-- sqtlColocClppLocalMaximum: double (nullable = true)\n |-- sqtlColocClppNeighborhoodMaximum: double (nullable = true)\n |-- sqtlColocLlrLocalMaximum: double (nullable = true)\n |-- sqtlColocLlrNeighborhoodMaximum: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/l2g_gold_standard/","title":"L2G Gold Standard","text":""},{"location":"python_api/dataset/l2g_gold_standard/#otg.dataset.l2g_gold_standard.L2GGoldStandard","title":"<code>otg.dataset.l2g_gold_standard.L2GGoldStandard</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>L2G gold standard dataset.</p> Source code in <code>src/otg/dataset/l2g_gold_standard.py</code> <pre><code>@dataclass\nclass L2GGoldStandard(Dataset):\n    \"\"\"L2G gold standard dataset.\"\"\"\n\n    INTERACTION_THRESHOLD = 0.7\n    GS_POSITIVE_LABEL = \"positive\"\n    GS_NEGATIVE_LABEL = \"negative\"\n\n    @classmethod\n    def from_otg_curation(\n        cls: type[L2GGoldStandard],\n        gold_standard_curation: DataFrame,\n        v2g: V2G,\n        study_locus_overlap: StudyLocusOverlap,\n        interactions: DataFrame,\n    ) -&gt; L2GGoldStandard:\n        \"\"\"Initialise L2GGoldStandard from source dataset.\n\n        Args:\n            gold_standard_curation (DataFrame): Gold standard curation dataframe, extracted from\n            v2g (V2G): Variant to gene dataset to bring distance between a variant and a gene's TSS\n            study_locus_overlap (StudyLocusOverlap): Study locus overlap dataset to remove duplicated loci\n            interactions (DataFrame): Gene-gene interactions dataset to remove negative cases where the gene interacts with a positive gene\n\n        Returns:\n            L2GGoldStandard: L2G Gold Standard dataset\n        \"\"\"\n        from otg.datasource.open_targets.l2g_gold_standard import (\n            OpenTargetsL2GGoldStandard,\n        )\n\n        interactions_df = cls.process_gene_interactions(interactions)\n\n        return (\n            OpenTargetsL2GGoldStandard.as_l2g_gold_standard(gold_standard_curation, v2g)\n            .filter_unique_associations(study_locus_overlap)\n            .remove_false_negatives(interactions_df)\n        )\n\n    @classmethod\n    def get_schema(cls: type[L2GGoldStandard]) -&gt; StructType:\n        \"\"\"Provides the schema for the L2GGoldStandard dataset.\n\n        Returns:\n            StructType: Spark schema for the L2GGoldStandard dataset\n        \"\"\"\n        return parse_spark_schema(\"l2g_gold_standard.json\")\n\n    @classmethod\n    def process_gene_interactions(\n        cls: Type[L2GGoldStandard], interactions: DataFrame\n    ) -&gt; DataFrame:\n        \"\"\"Extract top scoring gene-gene interaction from the interactions dataset of the Platform.\n\n        Args:\n            interactions (DataFrame): Gene-gene interactions dataset from the Open Targets Platform\n\n        Returns:\n            DataFrame: Top scoring gene-gene interaction per pair of genes\n\n        Examples:\n            &gt;&gt;&gt; interactions = spark.createDataFrame([(\"gene1\", \"gene2\", 0.8), (\"gene1\", \"gene2\", 0.5), (\"gene2\", \"gene3\", 0.7)], [\"targetA\", \"targetB\", \"scoring\"])\n            &gt;&gt;&gt; L2GGoldStandard.process_gene_interactions(interactions).show()\n            +-------+-------+-----+\n            |geneIdA|geneIdB|score|\n            +-------+-------+-----+\n            |  gene1|  gene2|  0.8|\n            |  gene2|  gene3|  0.7|\n            +-------+-------+-----+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        return get_record_with_maximum_value(\n            interactions,\n            [\"targetA\", \"targetB\"],\n            \"scoring\",\n        ).selectExpr(\n            \"targetA as geneIdA\",\n            \"targetB as geneIdB\",\n            \"scoring as score\",\n        )\n\n    def filter_unique_associations(\n        self: L2GGoldStandard,\n        study_locus_overlap: StudyLocusOverlap,\n    ) -&gt; L2GGoldStandard:\n        \"\"\"Refines the gold standard to filter out loci that are not independent.\n\n        Rules:\n        - If two loci point to the same gene, one positive and one negative, and have overlapping variants, we keep the positive one.\n        - If two loci point to the same gene, both positive or negative, and have overlapping variants, we drop one.\n        - If two loci point to different genes, and have overlapping variants, we keep both.\n\n        Args:\n            study_locus_overlap (StudyLocusOverlap): A dataset detailing variants that overlap between StudyLocus.\n\n        Returns:\n            L2GGoldStandard: L2GGoldStandard updated to exclude false negatives and redundant positives.\n        \"\"\"\n        squared_overlaps = study_locus_overlap._convert_to_square_matrix()\n        unique_associations = (\n            self.df.alias(\"left\")\n            # identify all the study loci that point to the same gene\n            .withColumn(\n                \"sl_same_gene\",\n                f.collect_set(\"studyLocusId\").over(Window.partitionBy(\"geneId\")),\n            )\n            # identify all the study loci that have an overlapping variant\n            .join(\n                squared_overlaps.df.alias(\"right\"),\n                (f.col(\"left.studyLocusId\") == f.col(\"right.leftStudyLocusId\"))\n                &amp; (f.col(\"left.variantId\") == f.col(\"right.tagVariantId\")),\n                \"left\",\n            )\n            .withColumn(\n                \"overlaps\",\n                f.when(f.col(\"right.tagVariantId\").isNotNull(), f.lit(True)).otherwise(\n                    f.lit(False)\n                ),\n            )\n            # drop redundant rows: where the variantid overlaps and the gene is \"explained\" by more than one study locus\n            .filter(~((f.size(\"sl_same_gene\") &gt; 1) &amp; (f.col(\"overlaps\") == 1)))\n            .select(*self.df.columns)\n        )\n        return L2GGoldStandard(_df=unique_associations, _schema=self.get_schema())\n\n    def remove_false_negatives(\n        self: L2GGoldStandard,\n        interactions_df: DataFrame,\n    ) -&gt; L2GGoldStandard:\n        \"\"\"Refines the gold standard to remove negative gold standard instances where the gene interacts with a positive gene.\n\n        Args:\n            interactions_df (DataFrame): Top scoring gene-gene interaction per pair of genes\n\n        Returns:\n            L2GGoldStandard: A refined set of locus-to-gene associations with increased reliability, having excluded loci that were likely false negatives due to gene-gene interaction confounding.\n        \"\"\"\n        squared_interactions = interactions_df.unionByName(\n            interactions_df.selectExpr(\n                \"geneIdB as geneIdA\", \"geneIdA as geneIdB\", \"score\"\n            )\n        ).filter(f.col(\"score\") &gt; self.INTERACTION_THRESHOLD)\n        df = (\n            self.df.alias(\"left\")\n            .join(\n                # bring gene partners\n                squared_interactions.alias(\"right\"),\n                f.col(\"left.geneId\") == f.col(\"right.geneIdA\"),\n                \"left\",\n            )\n            .withColumnRenamed(\"geneIdB\", \"interactorGeneId\")\n            .join(\n                # bring gold standard status for gene partners\n                self.df.selectExpr(\n                    \"geneId as interactorGeneId\",\n                    \"goldStandardSet as interactorGeneIdGoldStandardSet\",\n                ),\n                \"interactorGeneId\",\n                \"left\",\n            )\n            # remove self-interactions\n            .filter(\n                (f.col(\"geneId\") != f.col(\"interactorGeneId\"))\n                | (f.col(\"interactorGeneId\").isNull())\n            )\n            # remove false negatives\n            .filter(\n                # drop rows where the GS gene is negative but the interactor is a GS positive\n                ~(f.col(\"goldStandardSet\") == \"negative\")\n                &amp; (f.col(\"interactorGeneIdGoldStandardSet\") == \"positive\")\n                |\n                # keep rows where the gene does not interact\n                (f.col(\"interactorGeneId\").isNull())\n            )\n            .select(*self.df.columns)\n            .distinct()\n        )\n        return L2GGoldStandard(_df=df, _schema=self.get_schema())\n</code></pre>"},{"location":"python_api/dataset/l2g_gold_standard/#otg.dataset.l2g_gold_standard.L2GGoldStandard.filter_unique_associations","title":"<code>filter_unique_associations(study_locus_overlap: StudyLocusOverlap) -&gt; L2GGoldStandard</code>","text":"<p>Refines the gold standard to filter out loci that are not independent.</p> <p>Rules: - If two loci point to the same gene, one positive and one negative, and have overlapping variants, we keep the positive one. - If two loci point to the same gene, both positive or negative, and have overlapping variants, we drop one. - If two loci point to different genes, and have overlapping variants, we keep both.</p> <p>Parameters:</p> Name Type Description Default <code>study_locus_overlap</code> <code>StudyLocusOverlap</code> <p>A dataset detailing variants that overlap between StudyLocus.</p> required <p>Returns:</p> Name Type Description <code>L2GGoldStandard</code> <code>L2GGoldStandard</code> <p>L2GGoldStandard updated to exclude false negatives and redundant positives.</p> Source code in <code>src/otg/dataset/l2g_gold_standard.py</code> <pre><code>def filter_unique_associations(\n    self: L2GGoldStandard,\n    study_locus_overlap: StudyLocusOverlap,\n) -&gt; L2GGoldStandard:\n    \"\"\"Refines the gold standard to filter out loci that are not independent.\n\n    Rules:\n    - If two loci point to the same gene, one positive and one negative, and have overlapping variants, we keep the positive one.\n    - If two loci point to the same gene, both positive or negative, and have overlapping variants, we drop one.\n    - If two loci point to different genes, and have overlapping variants, we keep both.\n\n    Args:\n        study_locus_overlap (StudyLocusOverlap): A dataset detailing variants that overlap between StudyLocus.\n\n    Returns:\n        L2GGoldStandard: L2GGoldStandard updated to exclude false negatives and redundant positives.\n    \"\"\"\n    squared_overlaps = study_locus_overlap._convert_to_square_matrix()\n    unique_associations = (\n        self.df.alias(\"left\")\n        # identify all the study loci that point to the same gene\n        .withColumn(\n            \"sl_same_gene\",\n            f.collect_set(\"studyLocusId\").over(Window.partitionBy(\"geneId\")),\n        )\n        # identify all the study loci that have an overlapping variant\n        .join(\n            squared_overlaps.df.alias(\"right\"),\n            (f.col(\"left.studyLocusId\") == f.col(\"right.leftStudyLocusId\"))\n            &amp; (f.col(\"left.variantId\") == f.col(\"right.tagVariantId\")),\n            \"left\",\n        )\n        .withColumn(\n            \"overlaps\",\n            f.when(f.col(\"right.tagVariantId\").isNotNull(), f.lit(True)).otherwise(\n                f.lit(False)\n            ),\n        )\n        # drop redundant rows: where the variantid overlaps and the gene is \"explained\" by more than one study locus\n        .filter(~((f.size(\"sl_same_gene\") &gt; 1) &amp; (f.col(\"overlaps\") == 1)))\n        .select(*self.df.columns)\n    )\n    return L2GGoldStandard(_df=unique_associations, _schema=self.get_schema())\n</code></pre>"},{"location":"python_api/dataset/l2g_gold_standard/#otg.dataset.l2g_gold_standard.L2GGoldStandard.from_otg_curation","title":"<code>from_otg_curation(gold_standard_curation: DataFrame, v2g: V2G, study_locus_overlap: StudyLocusOverlap, interactions: DataFrame) -&gt; L2GGoldStandard</code>  <code>classmethod</code>","text":"<p>Initialise L2GGoldStandard from source dataset.</p> <p>Parameters:</p> Name Type Description Default <code>gold_standard_curation</code> <code>DataFrame</code> <p>Gold standard curation dataframe, extracted from</p> required <code>v2g</code> <code>V2G</code> <p>Variant to gene dataset to bring distance between a variant and a gene's TSS</p> required <code>study_locus_overlap</code> <code>StudyLocusOverlap</code> <p>Study locus overlap dataset to remove duplicated loci</p> required <code>interactions</code> <code>DataFrame</code> <p>Gene-gene interactions dataset to remove negative cases where the gene interacts with a positive gene</p> required <p>Returns:</p> Name Type Description <code>L2GGoldStandard</code> <code>L2GGoldStandard</code> <p>L2G Gold Standard dataset</p> Source code in <code>src/otg/dataset/l2g_gold_standard.py</code> <pre><code>@classmethod\ndef from_otg_curation(\n    cls: type[L2GGoldStandard],\n    gold_standard_curation: DataFrame,\n    v2g: V2G,\n    study_locus_overlap: StudyLocusOverlap,\n    interactions: DataFrame,\n) -&gt; L2GGoldStandard:\n    \"\"\"Initialise L2GGoldStandard from source dataset.\n\n    Args:\n        gold_standard_curation (DataFrame): Gold standard curation dataframe, extracted from\n        v2g (V2G): Variant to gene dataset to bring distance between a variant and a gene's TSS\n        study_locus_overlap (StudyLocusOverlap): Study locus overlap dataset to remove duplicated loci\n        interactions (DataFrame): Gene-gene interactions dataset to remove negative cases where the gene interacts with a positive gene\n\n    Returns:\n        L2GGoldStandard: L2G Gold Standard dataset\n    \"\"\"\n    from otg.datasource.open_targets.l2g_gold_standard import (\n        OpenTargetsL2GGoldStandard,\n    )\n\n    interactions_df = cls.process_gene_interactions(interactions)\n\n    return (\n        OpenTargetsL2GGoldStandard.as_l2g_gold_standard(gold_standard_curation, v2g)\n        .filter_unique_associations(study_locus_overlap)\n        .remove_false_negatives(interactions_df)\n    )\n</code></pre>"},{"location":"python_api/dataset/l2g_gold_standard/#otg.dataset.l2g_gold_standard.L2GGoldStandard.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the L2GGoldStandard dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Spark schema for the L2GGoldStandard dataset</p> Source code in <code>src/otg/dataset/l2g_gold_standard.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[L2GGoldStandard]) -&gt; StructType:\n    \"\"\"Provides the schema for the L2GGoldStandard dataset.\n\n    Returns:\n        StructType: Spark schema for the L2GGoldStandard dataset\n    \"\"\"\n    return parse_spark_schema(\"l2g_gold_standard.json\")\n</code></pre>"},{"location":"python_api/dataset/l2g_gold_standard/#otg.dataset.l2g_gold_standard.L2GGoldStandard.process_gene_interactions","title":"<code>process_gene_interactions(interactions: DataFrame) -&gt; DataFrame</code>  <code>classmethod</code>","text":"<p>Extract top scoring gene-gene interaction from the interactions dataset of the Platform.</p> <p>Parameters:</p> Name Type Description Default <code>interactions</code> <code>DataFrame</code> <p>Gene-gene interactions dataset from the Open Targets Platform</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Top scoring gene-gene interaction per pair of genes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; interactions = spark.createDataFrame([(\"gene1\", \"gene2\", 0.8), (\"gene1\", \"gene2\", 0.5), (\"gene2\", \"gene3\", 0.7)], [\"targetA\", \"targetB\", \"scoring\"])\n&gt;&gt;&gt; L2GGoldStandard.process_gene_interactions(interactions).show()\n+-------+-------+-----+\n|geneIdA|geneIdB|score|\n+-------+-------+-----+\n|  gene1|  gene2|  0.8|\n|  gene2|  gene3|  0.7|\n+-------+-------+-----+\n</code></pre> Source code in <code>src/otg/dataset/l2g_gold_standard.py</code> <pre><code>@classmethod\ndef process_gene_interactions(\n    cls: Type[L2GGoldStandard], interactions: DataFrame\n) -&gt; DataFrame:\n    \"\"\"Extract top scoring gene-gene interaction from the interactions dataset of the Platform.\n\n    Args:\n        interactions (DataFrame): Gene-gene interactions dataset from the Open Targets Platform\n\n    Returns:\n        DataFrame: Top scoring gene-gene interaction per pair of genes\n\n    Examples:\n        &gt;&gt;&gt; interactions = spark.createDataFrame([(\"gene1\", \"gene2\", 0.8), (\"gene1\", \"gene2\", 0.5), (\"gene2\", \"gene3\", 0.7)], [\"targetA\", \"targetB\", \"scoring\"])\n        &gt;&gt;&gt; L2GGoldStandard.process_gene_interactions(interactions).show()\n        +-------+-------+-----+\n        |geneIdA|geneIdB|score|\n        +-------+-------+-----+\n        |  gene1|  gene2|  0.8|\n        |  gene2|  gene3|  0.7|\n        +-------+-------+-----+\n        &lt;BLANKLINE&gt;\n    \"\"\"\n    return get_record_with_maximum_value(\n        interactions,\n        [\"targetA\", \"targetB\"],\n        \"scoring\",\n    ).selectExpr(\n        \"targetA as geneIdA\",\n        \"targetB as geneIdB\",\n        \"scoring as score\",\n    )\n</code></pre>"},{"location":"python_api/dataset/l2g_gold_standard/#otg.dataset.l2g_gold_standard.L2GGoldStandard.remove_false_negatives","title":"<code>remove_false_negatives(interactions_df: DataFrame) -&gt; L2GGoldStandard</code>","text":"<p>Refines the gold standard to remove negative gold standard instances where the gene interacts with a positive gene.</p> <p>Parameters:</p> Name Type Description Default <code>interactions_df</code> <code>DataFrame</code> <p>Top scoring gene-gene interaction per pair of genes</p> required <p>Returns:</p> Name Type Description <code>L2GGoldStandard</code> <code>L2GGoldStandard</code> <p>A refined set of locus-to-gene associations with increased reliability, having excluded loci that were likely false negatives due to gene-gene interaction confounding.</p> Source code in <code>src/otg/dataset/l2g_gold_standard.py</code> <pre><code>def remove_false_negatives(\n    self: L2GGoldStandard,\n    interactions_df: DataFrame,\n) -&gt; L2GGoldStandard:\n    \"\"\"Refines the gold standard to remove negative gold standard instances where the gene interacts with a positive gene.\n\n    Args:\n        interactions_df (DataFrame): Top scoring gene-gene interaction per pair of genes\n\n    Returns:\n        L2GGoldStandard: A refined set of locus-to-gene associations with increased reliability, having excluded loci that were likely false negatives due to gene-gene interaction confounding.\n    \"\"\"\n    squared_interactions = interactions_df.unionByName(\n        interactions_df.selectExpr(\n            \"geneIdB as geneIdA\", \"geneIdA as geneIdB\", \"score\"\n        )\n    ).filter(f.col(\"score\") &gt; self.INTERACTION_THRESHOLD)\n    df = (\n        self.df.alias(\"left\")\n        .join(\n            # bring gene partners\n            squared_interactions.alias(\"right\"),\n            f.col(\"left.geneId\") == f.col(\"right.geneIdA\"),\n            \"left\",\n        )\n        .withColumnRenamed(\"geneIdB\", \"interactorGeneId\")\n        .join(\n            # bring gold standard status for gene partners\n            self.df.selectExpr(\n                \"geneId as interactorGeneId\",\n                \"goldStandardSet as interactorGeneIdGoldStandardSet\",\n            ),\n            \"interactorGeneId\",\n            \"left\",\n        )\n        # remove self-interactions\n        .filter(\n            (f.col(\"geneId\") != f.col(\"interactorGeneId\"))\n            | (f.col(\"interactorGeneId\").isNull())\n        )\n        # remove false negatives\n        .filter(\n            # drop rows where the GS gene is negative but the interactor is a GS positive\n            ~(f.col(\"goldStandardSet\") == \"negative\")\n            &amp; (f.col(\"interactorGeneIdGoldStandardSet\") == \"positive\")\n            |\n            # keep rows where the gene does not interact\n            (f.col(\"interactorGeneId\").isNull())\n        )\n        .select(*self.df.columns)\n        .distinct()\n    )\n    return L2GGoldStandard(_df=df, _schema=self.get_schema())\n</code></pre>"},{"location":"python_api/dataset/l2g_gold_standard/#schema","title":"Schema","text":"<pre><code>root\n |-- studyLocusId: long (nullable = false)\n |-- variantId: string (nullable = false)\n |-- geneId: string (nullable = false)\n |-- goldStandardSet: string (nullable = false)\n |-- sources: array (nullable = true)\n |    |-- element: string (containsNull = true)\n</code></pre>"},{"location":"python_api/dataset/l2g_prediction/","title":"L2G Prediction","text":""},{"location":"python_api/dataset/l2g_prediction/#otg.dataset.l2g_prediction.L2GPrediction","title":"<code>otg.dataset.l2g_prediction.L2GPrediction</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Dataset that contains the Locus to Gene predictions.</p> <p>It is the result of applying the L2G model on a feature matrix, which contains all the study/locus pairs and their functional annotations. The score column informs the confidence of the prediction that a gene is causal to an association.</p> Source code in <code>src/otg/dataset/l2g_prediction.py</code> <pre><code>@dataclass\nclass L2GPrediction(Dataset):\n    \"\"\"Dataset that contains the Locus to Gene predictions.\n\n    It is the result of applying the L2G model on a feature matrix, which contains all\n    the study/locus pairs and their functional annotations. The score column informs the\n    confidence of the prediction that a gene is causal to an association.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[L2GPrediction]) -&gt; StructType:\n        \"\"\"Provides the schema for the L2GPrediction dataset.\n\n        Returns:\n            StructType: Schema for the L2GPrediction dataset\n        \"\"\"\n        return parse_spark_schema(\"l2g_predictions.json\")\n\n    @classmethod\n    def from_credible_set(\n        cls: Type[L2GPrediction],\n        model_path: str,\n        study_locus: StudyLocus,\n        study_index: StudyIndex,\n        v2g: V2G,\n        # coloc: Colocalisation,\n    ) -&gt; L2GPrediction:\n        \"\"\"Initialise L2G from feature matrix.\n\n        Args:\n            model_path (str): Path to the fitted model\n            study_locus (StudyLocus): Study locus dataset\n            study_index (StudyIndex): Study index dataset\n            v2g (V2G): Variant to gene dataset\n\n        Returns:\n            L2GPrediction: L2G dataset\n        \"\"\"\n        fm = L2GFeatureMatrix.generate_features(\n            study_locus=study_locus,\n            study_index=study_index,\n            variant_gene=v2g,\n            # colocalisation=coloc,\n        ).fill_na()\n        return L2GPrediction(\n            # Load and apply fitted model\n            _df=(\n                LocusToGeneModel.load_from_disk(\n                    model_path,\n                    features_list=fm.df.drop(\"studyLocusId\", \"geneId\").columns,\n                ).predict(fm)\n                # the probability of the positive class is the second element inside the probability array\n                # - this is selected as the L2G probability\n                .select(\n                    \"studyLocusId\",\n                    \"geneId\",\n                    vector_to_array(f.col(\"probability\"))[1].alias(\"score\"),\n                )\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/l2g_prediction/#otg.dataset.l2g_prediction.L2GPrediction.from_credible_set","title":"<code>from_credible_set(model_path: str, study_locus: StudyLocus, study_index: StudyIndex, v2g: V2G) -&gt; L2GPrediction</code>  <code>classmethod</code>","text":"<p>Initialise L2G from feature matrix.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to the fitted model</p> required <code>study_locus</code> <code>StudyLocus</code> <p>Study locus dataset</p> required <code>study_index</code> <code>StudyIndex</code> <p>Study index dataset</p> required <code>v2g</code> <code>V2G</code> <p>Variant to gene dataset</p> required <p>Returns:</p> Name Type Description <code>L2GPrediction</code> <code>L2GPrediction</code> <p>L2G dataset</p> Source code in <code>src/otg/dataset/l2g_prediction.py</code> <pre><code>@classmethod\ndef from_credible_set(\n    cls: Type[L2GPrediction],\n    model_path: str,\n    study_locus: StudyLocus,\n    study_index: StudyIndex,\n    v2g: V2G,\n    # coloc: Colocalisation,\n) -&gt; L2GPrediction:\n    \"\"\"Initialise L2G from feature matrix.\n\n    Args:\n        model_path (str): Path to the fitted model\n        study_locus (StudyLocus): Study locus dataset\n        study_index (StudyIndex): Study index dataset\n        v2g (V2G): Variant to gene dataset\n\n    Returns:\n        L2GPrediction: L2G dataset\n    \"\"\"\n    fm = L2GFeatureMatrix.generate_features(\n        study_locus=study_locus,\n        study_index=study_index,\n        variant_gene=v2g,\n        # colocalisation=coloc,\n    ).fill_na()\n    return L2GPrediction(\n        # Load and apply fitted model\n        _df=(\n            LocusToGeneModel.load_from_disk(\n                model_path,\n                features_list=fm.df.drop(\"studyLocusId\", \"geneId\").columns,\n            ).predict(fm)\n            # the probability of the positive class is the second element inside the probability array\n            # - this is selected as the L2G probability\n            .select(\n                \"studyLocusId\",\n                \"geneId\",\n                vector_to_array(f.col(\"probability\"))[1].alias(\"score\"),\n            )\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/l2g_prediction/#otg.dataset.l2g_prediction.L2GPrediction.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the L2GPrediction dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the L2GPrediction dataset</p> Source code in <code>src/otg/dataset/l2g_prediction.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[L2GPrediction]) -&gt; StructType:\n    \"\"\"Provides the schema for the L2GPrediction dataset.\n\n    Returns:\n        StructType: Schema for the L2GPrediction dataset\n    \"\"\"\n    return parse_spark_schema(\"l2g_predictions.json\")\n</code></pre>"},{"location":"python_api/dataset/l2g_prediction/#schema","title":"Schema","text":""},{"location":"python_api/dataset/ld_index/","title":"LD Index","text":""},{"location":"python_api/dataset/ld_index/#otg.dataset.ld_index.LDIndex","title":"<code>otg.dataset.ld_index.LDIndex</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Dataset containing linkage desequilibrium information between variants.</p> Source code in <code>src/otg/dataset/ld_index.py</code> <pre><code>@dataclass\nclass LDIndex(Dataset):\n    \"\"\"Dataset containing linkage desequilibrium information between variants.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[LDIndex]) -&gt; StructType:\n        \"\"\"Provides the schema for the LDIndex dataset.\n\n        Returns:\n            StructType: Schema for the LDIndex dataset\n        \"\"\"\n        return parse_spark_schema(\"ld_index.json\")\n</code></pre>"},{"location":"python_api/dataset/ld_index/#otg.dataset.ld_index.LDIndex.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the LDIndex dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the LDIndex dataset</p> Source code in <code>src/otg/dataset/ld_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[LDIndex]) -&gt; StructType:\n    \"\"\"Provides the schema for the LDIndex dataset.\n\n    Returns:\n        StructType: Schema for the LDIndex dataset\n    \"\"\"\n    return parse_spark_schema(\"ld_index.json\")\n</code></pre>"},{"location":"python_api/dataset/ld_index/#schema","title":"Schema","text":"<pre><code>root\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- ldSet: array (nullable = false)\n |    |-- element: struct (containsNull = false)\n |    |    |-- tagVariantId: string (nullable = false)\n |    |    |-- rValues: array (nullable = false)\n |    |    |    |-- element: struct (containsNull = false)\n |    |    |    |    |-- population: string (nullable = false)\n |    |    |    |    |-- r: double (nullable = false)\n</code></pre>"},{"location":"python_api/dataset/study_index/","title":"Study Index","text":""},{"location":"python_api/dataset/study_index/#otg.dataset.study_index.StudyIndex","title":"<code>otg.dataset.study_index.StudyIndex</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Study index dataset.</p> <p>A study index dataset captures all the metadata for all studies including GWAS and Molecular QTL.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>@dataclass\nclass StudyIndex(Dataset):\n    \"\"\"Study index dataset.\n\n    A study index dataset captures all the metadata for all studies including GWAS and Molecular QTL.\n    \"\"\"\n\n    @staticmethod\n    def _aggregate_samples_by_ancestry(merged: Column, ancestry: Column) -&gt; Column:\n        \"\"\"Aggregate sample counts by ancestry in a list of struct colmns.\n\n        Args:\n            merged (Column): A column representing merged data (list of structs).\n            ancestry (Column): The `ancestry` parameter is a column that represents the ancestry of each\n                sample. (a struct)\n\n        Returns:\n            Column: the modified \"merged\" column after aggregating the samples by ancestry.\n        \"\"\"\n        # Iterating over the list of ancestries and adding the sample size if label matches:\n        return f.transform(\n            merged,\n            lambda a: f.when(\n                a.ancestry == ancestry.ancestry,\n                f.struct(\n                    a.ancestry.alias(\"ancestry\"),\n                    (a.sampleSize + ancestry.sampleSize).alias(\"sampleSize\"),\n                ),\n            ).otherwise(a),\n        )\n\n    @staticmethod\n    def _map_ancestries_to_ld_population(gwas_ancestry_label: Column) -&gt; Column:\n        \"\"\"Normalise ancestry column from GWAS studies into reference LD panel based on a pre-defined map.\n\n        This function assumes all possible ancestry categories have a corresponding\n        LD panel in the LD index. It is very important to have the ancestry labels\n        moved to the LD panel map.\n\n        Args:\n            gwas_ancestry_label (Column): A struct column with ancestry label like Finnish,\n                European, African etc. and the corresponding sample size.\n\n        Returns:\n            Column: Struct column with the mapped LD population label and the sample size.\n        \"\"\"\n        # Loading ancestry label to LD population label:\n        json_dict = json.loads(\n            pkg_resources.read_text(\n                data, \"gwas_population_2_LD_panel_map.json\", encoding=\"utf-8\"\n            )\n        )\n        map_expr = f.create_map(*[f.lit(x) for x in chain(*json_dict.items())])\n\n        return f.struct(\n            map_expr[gwas_ancestry_label.ancestry].alias(\"ancestry\"),\n            gwas_ancestry_label.sampleSize.alias(\"sampleSize\"),\n        )\n\n    @classmethod\n    def get_schema(cls: type[StudyIndex]) -&gt; StructType:\n        \"\"\"Provide the schema for the StudyIndex dataset.\n\n        Returns:\n            StructType: The schema of the StudyIndex dataset.\n        \"\"\"\n        return parse_spark_schema(\"study_index.json\")\n\n    @classmethod\n    def aggregate_and_map_ancestries(\n        cls: type[StudyIndex], discovery_samples: Column\n    ) -&gt; Column:\n        \"\"\"Map ancestries to populations in the LD reference and calculate relative sample size.\n\n        Args:\n            discovery_samples (Column): A list of struct column. Has an `ancestry` column and a `sampleSize` columns\n\n        Returns:\n            Column: A list of struct with mapped LD population and their relative sample size.\n        \"\"\"\n        # Map ancestry categories to population labels of the LD index:\n        mapped_ancestries = f.transform(\n            discovery_samples, cls._map_ancestries_to_ld_population\n        )\n\n        # Aggregate sample sizes belonging to the same LD population:\n        aggregated_counts = f.aggregate(\n            mapped_ancestries,\n            f.array_distinct(\n                f.transform(\n                    mapped_ancestries,\n                    lambda x: f.struct(\n                        x.ancestry.alias(\"ancestry\"), f.lit(0.0).alias(\"sampleSize\")\n                    ),\n                )\n            ),\n            cls._aggregate_samples_by_ancestry,\n        )\n        # Getting total sample count:\n        total_sample_count = f.aggregate(\n            aggregated_counts, f.lit(0.0), lambda total, pop: total + pop.sampleSize\n        ).alias(\"sampleSize\")\n\n        # Calculating relative sample size for each LD population:\n        return f.transform(\n            aggregated_counts,\n            lambda ld_population: f.struct(\n                ld_population.ancestry.alias(\"ldPopulation\"),\n                (ld_population.sampleSize / total_sample_count).alias(\n                    \"relativeSampleSize\"\n                ),\n            ),\n        )\n\n    def study_type_lut(self: StudyIndex) -&gt; DataFrame:\n        \"\"\"Return a lookup table of study type.\n\n        Returns:\n            DataFrame: A dataframe containing `studyId` and `studyType` columns.\n        \"\"\"\n        return self.df.select(\"studyId\", \"studyType\")\n</code></pre>"},{"location":"python_api/dataset/study_index/#otg.dataset.study_index.StudyIndex.aggregate_and_map_ancestries","title":"<code>aggregate_and_map_ancestries(discovery_samples: Column) -&gt; Column</code>  <code>classmethod</code>","text":"<p>Map ancestries to populations in the LD reference and calculate relative sample size.</p> <p>Parameters:</p> Name Type Description Default <code>discovery_samples</code> <code>Column</code> <p>A list of struct column. Has an <code>ancestry</code> column and a <code>sampleSize</code> columns</p> required <p>Returns:</p> Name Type Description <code>Column</code> <code>Column</code> <p>A list of struct with mapped LD population and their relative sample size.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>@classmethod\ndef aggregate_and_map_ancestries(\n    cls: type[StudyIndex], discovery_samples: Column\n) -&gt; Column:\n    \"\"\"Map ancestries to populations in the LD reference and calculate relative sample size.\n\n    Args:\n        discovery_samples (Column): A list of struct column. Has an `ancestry` column and a `sampleSize` columns\n\n    Returns:\n        Column: A list of struct with mapped LD population and their relative sample size.\n    \"\"\"\n    # Map ancestry categories to population labels of the LD index:\n    mapped_ancestries = f.transform(\n        discovery_samples, cls._map_ancestries_to_ld_population\n    )\n\n    # Aggregate sample sizes belonging to the same LD population:\n    aggregated_counts = f.aggregate(\n        mapped_ancestries,\n        f.array_distinct(\n            f.transform(\n                mapped_ancestries,\n                lambda x: f.struct(\n                    x.ancestry.alias(\"ancestry\"), f.lit(0.0).alias(\"sampleSize\")\n                ),\n            )\n        ),\n        cls._aggregate_samples_by_ancestry,\n    )\n    # Getting total sample count:\n    total_sample_count = f.aggregate(\n        aggregated_counts, f.lit(0.0), lambda total, pop: total + pop.sampleSize\n    ).alias(\"sampleSize\")\n\n    # Calculating relative sample size for each LD population:\n    return f.transform(\n        aggregated_counts,\n        lambda ld_population: f.struct(\n            ld_population.ancestry.alias(\"ldPopulation\"),\n            (ld_population.sampleSize / total_sample_count).alias(\n                \"relativeSampleSize\"\n            ),\n        ),\n    )\n</code></pre>"},{"location":"python_api/dataset/study_index/#otg.dataset.study_index.StudyIndex.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provide the schema for the StudyIndex dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>The schema of the StudyIndex dataset.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[StudyIndex]) -&gt; StructType:\n    \"\"\"Provide the schema for the StudyIndex dataset.\n\n    Returns:\n        StructType: The schema of the StudyIndex dataset.\n    \"\"\"\n    return parse_spark_schema(\"study_index.json\")\n</code></pre>"},{"location":"python_api/dataset/study_index/#otg.dataset.study_index.StudyIndex.study_type_lut","title":"<code>study_type_lut() -&gt; DataFrame</code>","text":"<p>Return a lookup table of study type.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A dataframe containing <code>studyId</code> and <code>studyType</code> columns.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>def study_type_lut(self: StudyIndex) -&gt; DataFrame:\n    \"\"\"Return a lookup table of study type.\n\n    Returns:\n        DataFrame: A dataframe containing `studyId` and `studyType` columns.\n    \"\"\"\n    return self.df.select(\"studyId\", \"studyType\")\n</code></pre>"},{"location":"python_api/dataset/study_index/#schema","title":"Schema","text":"<pre><code>root\n |-- studyId: string (nullable = false)\n |-- projectId: string (nullable = false)\n |-- studyType: string (nullable = false)\n |-- traitFromSource: string (nullable = false)\n |-- traitFromSourceMappedIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- geneId: string (nullable = true)\n |-- pubmedId: string (nullable = true)\n |-- publicationTitle: string (nullable = true)\n |-- publicationFirstAuthor: string (nullable = true)\n |-- publicationDate: string (nullable = true)\n |-- publicationJournal: string (nullable = true)\n |-- backgroundTraitFromSourceMappedIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- initialSampleSize: string (nullable = true)\n |-- nCases: long (nullable = true)\n |-- nControls: long (nullable = true)\n |-- nSamples: long (nullable = true)\n |-- ldPopulationStructure: array (nullable = true)\n |    |-- element: struct (containsNull = false)\n |    |    |-- ldPopulation: string (nullable = true)\n |    |    |-- relativeSampleSize: double (nullable = true)\n |-- discoverySamples: array (nullable = true)\n |    |-- element: struct (containsNull = false)\n |    |    |-- sampleSize: long (nullable = true)\n |    |    |-- ancestry: string (nullable = true)\n |-- replicationSamples: array (nullable = true)\n |    |-- element: struct (containsNull = false)\n |    |    |-- sampleSize: long (nullable = true)\n |    |    |-- ancestry: string (nullable = true)\n |-- summarystatsLocation: string (nullable = true)\n |-- hasSumstats: boolean (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/study_locus/","title":"Study Locus","text":""},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus","title":"<code>otg.dataset.study_locus.StudyLocus</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Study-Locus dataset.</p> <p>This dataset captures associations between study/traits and a genetic loci as provided by finemapping methods.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>@dataclass\nclass StudyLocus(Dataset):\n    \"\"\"Study-Locus dataset.\n\n    This dataset captures associations between study/traits and a genetic loci as provided by finemapping methods.\n    \"\"\"\n\n    @staticmethod\n    def _overlapping_peaks(credset_to_overlap: DataFrame) -&gt; DataFrame:\n        \"\"\"Calculate overlapping signals (study-locus) between GWAS-GWAS and GWAS-Molecular trait.\n\n        Args:\n            credset_to_overlap (DataFrame): DataFrame containing at least `studyLocusId`, `studyType`, `chromosome` and `tagVariantId` columns.\n\n        Returns:\n            DataFrame: containing `leftStudyLocusId`, `rightStudyLocusId` and `chromosome` columns.\n        \"\"\"\n        # Reduce columns to the minimum to reduce the size of the dataframe\n        credset_to_overlap = credset_to_overlap.select(\n            \"studyLocusId\", \"studyType\", \"chromosome\", \"tagVariantId\"\n        )\n        return (\n            credset_to_overlap.alias(\"left\")\n            .filter(f.col(\"studyType\") == \"gwas\")\n            # Self join with complex condition. Left it's all gwas and right can be gwas or molecular trait\n            .join(\n                credset_to_overlap.alias(\"right\"),\n                on=[\n                    f.col(\"left.chromosome\") == f.col(\"right.chromosome\"),\n                    f.col(\"left.tagVariantId\") == f.col(\"right.tagVariantId\"),\n                    (f.col(\"right.studyType\") != \"gwas\")\n                    | (f.col(\"left.studyLocusId\") &gt; f.col(\"right.studyLocusId\")),\n                ],\n                how=\"inner\",\n            )\n            .select(\n                f.col(\"left.studyLocusId\").alias(\"leftStudyLocusId\"),\n                f.col(\"right.studyLocusId\").alias(\"rightStudyLocusId\"),\n                f.col(\"left.chromosome\").alias(\"chromosome\"),\n            )\n            .distinct()\n            .repartition(\"chromosome\")\n            .persist()\n        )\n\n    @staticmethod\n    def _align_overlapping_tags(\n        loci_to_overlap: DataFrame, peak_overlaps: DataFrame\n    ) -&gt; StudyLocusOverlap:\n        \"\"\"Align overlapping tags in pairs of overlapping study-locus, keeping all tags in both loci.\n\n        Args:\n            loci_to_overlap (DataFrame): containing `studyLocusId`, `studyType`, `chromosome`, `tagVariantId`, `logABF` and `posteriorProbability` columns.\n            peak_overlaps (DataFrame): containing `leftStudyLocusId`, `rightStudyLocusId` and `chromosome` columns.\n\n        Returns:\n            StudyLocusOverlap: Pairs of overlapping study-locus with aligned tags.\n        \"\"\"\n        # Complete information about all tags in the left study-locus of the overlap\n        stats_cols = [\n            \"logABF\",\n            \"posteriorProbability\",\n            \"beta\",\n            \"pValueMantissa\",\n            \"pValueExponent\",\n        ]\n        overlapping_left = loci_to_overlap.select(\n            f.col(\"chromosome\"),\n            f.col(\"tagVariantId\"),\n            f.col(\"studyLocusId\").alias(\"leftStudyLocusId\"),\n            *[f.col(col).alias(f\"left_{col}\") for col in stats_cols],\n        ).join(peak_overlaps, on=[\"chromosome\", \"leftStudyLocusId\"], how=\"inner\")\n\n        # Complete information about all tags in the right study-locus of the overlap\n        overlapping_right = loci_to_overlap.select(\n            f.col(\"chromosome\"),\n            f.col(\"tagVariantId\"),\n            f.col(\"studyLocusId\").alias(\"rightStudyLocusId\"),\n            *[f.col(col).alias(f\"right_{col}\") for col in stats_cols],\n        ).join(peak_overlaps, on=[\"chromosome\", \"rightStudyLocusId\"], how=\"inner\")\n\n        # Include information about all tag variants in both study-locus aligned by tag variant id\n        overlaps = overlapping_left.join(\n            overlapping_right,\n            on=[\n                \"chromosome\",\n                \"rightStudyLocusId\",\n                \"leftStudyLocusId\",\n                \"tagVariantId\",\n            ],\n            how=\"outer\",\n        ).select(\n            \"leftStudyLocusId\",\n            \"rightStudyLocusId\",\n            \"chromosome\",\n            \"tagVariantId\",\n            f.struct(\n                *[f\"left_{e}\" for e in stats_cols] + [f\"right_{e}\" for e in stats_cols]\n            ).alias(\"statistics\"),\n        )\n        return StudyLocusOverlap(\n            _df=overlaps,\n            _schema=StudyLocusOverlap.get_schema(),\n        )\n\n    @staticmethod\n    def _update_quality_flag(\n        qc: Column, flag_condition: Column, flag_text: StudyLocusQualityCheck\n    ) -&gt; Column:\n        \"\"\"Update the provided quality control list with a new flag if condition is met.\n\n        Args:\n            qc (Column): Array column with the current list of qc flags.\n            flag_condition (Column): This is a column of booleans, signing which row should be flagged\n            flag_text (StudyLocusQualityCheck): Text for the new quality control flag\n\n        Returns:\n            Column: Array column with the updated list of qc flags.\n        \"\"\"\n        qc = f.when(qc.isNull(), f.array()).otherwise(qc)\n        return f.when(\n            flag_condition,\n            f.array_union(qc, f.array(f.lit(flag_text.value))),\n        ).otherwise(qc)\n\n    @staticmethod\n    def assign_study_locus_id(study_id_col: Column, variant_id_col: Column) -&gt; Column:\n        \"\"\"Hashes a column with a variant ID and a study ID to extract a consistent studyLocusId.\n\n        Args:\n            study_id_col (Column): column name with a study ID\n            variant_id_col (Column): column name with a variant ID\n\n        Returns:\n            Column: column with a study locus ID\n\n        Examples:\n            &gt;&gt;&gt; df = spark.createDataFrame([(\"GCST000001\", \"1_1000_A_C\"), (\"GCST000002\", \"1_1000_A_C\")]).toDF(\"studyId\", \"variantId\")\n            &gt;&gt;&gt; df.withColumn(\"study_locus_id\", StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\"))).show()\n            +----------+----------+-------------------+\n            |   studyId| variantId|     study_locus_id|\n            +----------+----------+-------------------+\n            |GCST000001|1_1000_A_C|1553357789130151995|\n            |GCST000002|1_1000_A_C|-415050894682709184|\n            +----------+----------+-------------------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        variant_id_col = f.coalesce(variant_id_col, f.rand().cast(\"string\"))\n        return f.xxhash64(study_id_col, variant_id_col).alias(\"studyLocusId\")\n\n    @classmethod\n    def get_schema(cls: type[StudyLocus]) -&gt; StructType:\n        \"\"\"Provides the schema for the StudyLocus dataset.\n\n        Returns:\n            StructType: schema for the StudyLocus dataset.\n        \"\"\"\n        return parse_spark_schema(\"study_locus.json\")\n\n    def filter_credible_set(\n        self: StudyLocus,\n        credible_interval: CredibleInterval,\n    ) -&gt; StudyLocus:\n        \"\"\"Filter study-locus tag variants based on given credible interval.\n\n        Args:\n            credible_interval (CredibleInterval): Credible interval to filter for.\n\n        Returns:\n            StudyLocus: Filtered study-locus dataset.\n        \"\"\"\n        self.df = self._df.withColumn(\n            \"locus\",\n            f.filter(\n                f.col(\"locus\"),\n                lambda tag: (tag[credible_interval.value]),\n            ),\n        )\n        return self\n\n    def find_overlaps(self: StudyLocus, study_index: StudyIndex) -&gt; StudyLocusOverlap:\n        \"\"\"Calculate overlapping study-locus.\n\n        Find overlapping study-locus that share at least one tagging variant. All GWAS-GWAS and all GWAS-Molecular traits are computed with the Molecular traits always\n        appearing on the right side.\n\n        Args:\n            study_index (StudyIndex): Study index to resolve study types.\n\n        Returns:\n            StudyLocusOverlap: Pairs of overlapping study-locus with aligned tags.\n        \"\"\"\n        loci_to_overlap = (\n            self.df.join(study_index.study_type_lut(), on=\"studyId\", how=\"inner\")\n            .withColumn(\"locus\", f.explode(\"locus\"))\n            .select(\n                \"studyLocusId\",\n                \"studyType\",\n                \"chromosome\",\n                f.col(\"locus.variantId\").alias(\"tagVariantId\"),\n                f.col(\"locus.logABF\").alias(\"logABF\"),\n                f.col(\"locus.posteriorProbability\").alias(\"posteriorProbability\"),\n                f.col(\"locus.pValueMantissa\").alias(\"pValueMantissa\"),\n                f.col(\"locus.pValueExponent\").alias(\"pValueExponent\"),\n                f.col(\"locus.beta\").alias(\"beta\"),\n            )\n            .persist()\n        )\n\n        # overlapping study-locus\n        peak_overlaps = self._overlapping_peaks(loci_to_overlap)\n\n        # study-locus overlap by aligning overlapping variants\n        return self._align_overlapping_tags(loci_to_overlap, peak_overlaps)\n\n    def unique_variants_in_locus(self: StudyLocus) -&gt; DataFrame:\n        \"\"\"All unique variants collected in a `StudyLocus` dataframe.\n\n        Returns:\n            DataFrame: A dataframe containing `variantId` and `chromosome` columns.\n        \"\"\"\n        return (\n            self.df.withColumn(\n                \"variantId\",\n                # Joint array of variants in that studylocus. Locus can be null\n                f.explode(\n                    f.array_union(\n                        f.array(f.col(\"variantId\")),\n                        f.coalesce(f.col(\"locus.variantId\"), f.array()),\n                    )\n                ),\n            )\n            .select(\n                \"variantId\", f.split(f.col(\"variantId\"), \"_\")[0].alias(\"chromosome\")\n            )\n            .distinct()\n        )\n\n    def neglog_pvalue(self: StudyLocus) -&gt; Column:\n        \"\"\"Returns the negative log p-value.\n\n        Returns:\n            Column: Negative log p-value\n        \"\"\"\n        return calculate_neglog_pvalue(\n            self.df.pValueMantissa,\n            self.df.pValueExponent,\n        )\n\n    def annotate_credible_sets(self: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Annotate study-locus dataset with credible set flags.\n\n        Sorts the array in the `locus` column elements by their `posteriorProbability` values in descending order and adds\n        `is95CredibleSet` and `is99CredibleSet` fields to the elements, indicating which are the tagging variants whose cumulative sum\n        of their `posteriorProbability` values is below 0.95 and 0.99, respectively.\n\n        Returns:\n            StudyLocus: including annotation on `is95CredibleSet` and `is99CredibleSet`.\n\n        Raises:\n            ValueError: If `locus` column is not available.\n        \"\"\"\n        if \"locus\" not in self.df.columns:\n            raise ValueError(\"Locus column not available.\")\n\n        self.df = self.df.withColumn(\n            # Sort credible set by posterior probability in descending order\n            \"locus\",\n            f.when(\n                f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n                order_array_of_structs_by_field(\"locus\", \"posteriorProbability\"),\n            ),\n        ).withColumn(\n            # Calculate array of cumulative sums of posterior probabilities to determine which variants are in the 95% and 99% credible sets\n            # and zip the cumulative sums array with the credible set array to add the flags\n            \"locus\",\n            f.when(\n                f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n                f.zip_with(\n                    f.col(\"locus\"),\n                    f.transform(\n                        f.sequence(f.lit(1), f.size(f.col(\"locus\"))),\n                        lambda index: f.aggregate(\n                            f.slice(\n                                # By using `index - 1` we introduce a value of `0.0` in the cumulative sums array. to ensure that the last variant\n                                # that exceeds the 0.95 threshold is included in the cumulative sum, as its probability is necessary to satisfy the threshold.\n                                f.col(\"locus.posteriorProbability\"),\n                                1,\n                                index - 1,\n                            ),\n                            f.lit(0.0),\n                            lambda acc, el: acc + el,\n                        ),\n                    ),\n                    lambda struct_e, acc: struct_e.withField(\n                        CredibleInterval.IS95.value, (acc &lt; 0.95) &amp; acc.isNotNull()\n                    ).withField(\n                        CredibleInterval.IS99.value, (acc &lt; 0.99) &amp; acc.isNotNull()\n                    ),\n                ),\n            ),\n        )\n        return self\n\n    def clump(self: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Perform LD clumping of the studyLocus.\n\n        Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.\n\n        Returns:\n            StudyLocus: with empty credible sets for linked variants and QC flag.\n        \"\"\"\n        self.df = (\n            self.df.withColumn(\n                \"is_lead_linked\",\n                LDclumping._is_lead_linked(\n                    self.df.studyId,\n                    self.df.variantId,\n                    self.df.pValueExponent,\n                    self.df.pValueMantissa,\n                    self.df.ldSet,\n                ),\n            )\n            .withColumn(\n                \"ldSet\",\n                f.when(f.col(\"is_lead_linked\"), f.array()).otherwise(f.col(\"ldSet\")),\n            )\n            .withColumn(\n                \"qualityControls\",\n                StudyLocus._update_quality_flag(\n                    f.col(\"qualityControls\"),\n                    f.col(\"is_lead_linked\"),\n                    StudyLocusQualityCheck.LD_CLUMPED,\n                ),\n            )\n            .drop(\"is_lead_linked\")\n        )\n        return self\n\n    def _qc_unresolved_ld(\n        self: StudyLocus,\n    ) -&gt; StudyLocus:\n        \"\"\"Flag associations with variants that are not found in the LD reference.\n\n        Returns:\n            StudyLocus: Updated study locus.\n        \"\"\"\n        self.df = self.df.withColumn(\n            \"qualityControls\",\n            self._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.col(\"ldSet\").isNull(),\n                StudyLocusQualityCheck.UNRESOLVED_LD,\n            ),\n        )\n        return self\n\n    def _qc_no_population(self: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Flag associations where the study doesn't have population information to resolve LD.\n\n        Returns:\n            StudyLocus: Updated study locus.\n        \"\"\"\n        # If the tested column is not present, return self unchanged:\n        if \"ldPopulationStructure\" not in self.df.columns:\n            return self\n\n        self.df = self.df.withColumn(\n            \"qualityControls\",\n            self._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.col(\"ldPopulationStructure\").isNull(),\n                StudyLocusQualityCheck.NO_POPULATION,\n            ),\n        )\n        return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.annotate_credible_sets","title":"<code>annotate_credible_sets() -&gt; StudyLocus</code>","text":"<p>Annotate study-locus dataset with credible set flags.</p> <p>Sorts the array in the <code>locus</code> column elements by their <code>posteriorProbability</code> values in descending order and adds <code>is95CredibleSet</code> and <code>is99CredibleSet</code> fields to the elements, indicating which are the tagging variants whose cumulative sum of their <code>posteriorProbability</code> values is below 0.95 and 0.99, respectively.</p> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>including annotation on <code>is95CredibleSet</code> and <code>is99CredibleSet</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>locus</code> column is not available.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def annotate_credible_sets(self: StudyLocus) -&gt; StudyLocus:\n    \"\"\"Annotate study-locus dataset with credible set flags.\n\n    Sorts the array in the `locus` column elements by their `posteriorProbability` values in descending order and adds\n    `is95CredibleSet` and `is99CredibleSet` fields to the elements, indicating which are the tagging variants whose cumulative sum\n    of their `posteriorProbability` values is below 0.95 and 0.99, respectively.\n\n    Returns:\n        StudyLocus: including annotation on `is95CredibleSet` and `is99CredibleSet`.\n\n    Raises:\n        ValueError: If `locus` column is not available.\n    \"\"\"\n    if \"locus\" not in self.df.columns:\n        raise ValueError(\"Locus column not available.\")\n\n    self.df = self.df.withColumn(\n        # Sort credible set by posterior probability in descending order\n        \"locus\",\n        f.when(\n            f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n            order_array_of_structs_by_field(\"locus\", \"posteriorProbability\"),\n        ),\n    ).withColumn(\n        # Calculate array of cumulative sums of posterior probabilities to determine which variants are in the 95% and 99% credible sets\n        # and zip the cumulative sums array with the credible set array to add the flags\n        \"locus\",\n        f.when(\n            f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n            f.zip_with(\n                f.col(\"locus\"),\n                f.transform(\n                    f.sequence(f.lit(1), f.size(f.col(\"locus\"))),\n                    lambda index: f.aggregate(\n                        f.slice(\n                            # By using `index - 1` we introduce a value of `0.0` in the cumulative sums array. to ensure that the last variant\n                            # that exceeds the 0.95 threshold is included in the cumulative sum, as its probability is necessary to satisfy the threshold.\n                            f.col(\"locus.posteriorProbability\"),\n                            1,\n                            index - 1,\n                        ),\n                        f.lit(0.0),\n                        lambda acc, el: acc + el,\n                    ),\n                ),\n                lambda struct_e, acc: struct_e.withField(\n                    CredibleInterval.IS95.value, (acc &lt; 0.95) &amp; acc.isNotNull()\n                ).withField(\n                    CredibleInterval.IS99.value, (acc &lt; 0.99) &amp; acc.isNotNull()\n                ),\n            ),\n        ),\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.assign_study_locus_id","title":"<code>assign_study_locus_id(study_id_col: Column, variant_id_col: Column) -&gt; Column</code>  <code>staticmethod</code>","text":"<p>Hashes a column with a variant ID and a study ID to extract a consistent studyLocusId.</p> <p>Parameters:</p> Name Type Description Default <code>study_id_col</code> <code>Column</code> <p>column name with a study ID</p> required <code>variant_id_col</code> <code>Column</code> <p>column name with a variant ID</p> required <p>Returns:</p> Name Type Description <code>Column</code> <code>Column</code> <p>column with a study locus ID</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = spark.createDataFrame([(\"GCST000001\", \"1_1000_A_C\"), (\"GCST000002\", \"1_1000_A_C\")]).toDF(\"studyId\", \"variantId\")\n&gt;&gt;&gt; df.withColumn(\"study_locus_id\", StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\"))).show()\n+----------+----------+-------------------+\n|   studyId| variantId|     study_locus_id|\n+----------+----------+-------------------+\n|GCST000001|1_1000_A_C|1553357789130151995|\n|GCST000002|1_1000_A_C|-415050894682709184|\n+----------+----------+-------------------+\n</code></pre> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>@staticmethod\ndef assign_study_locus_id(study_id_col: Column, variant_id_col: Column) -&gt; Column:\n    \"\"\"Hashes a column with a variant ID and a study ID to extract a consistent studyLocusId.\n\n    Args:\n        study_id_col (Column): column name with a study ID\n        variant_id_col (Column): column name with a variant ID\n\n    Returns:\n        Column: column with a study locus ID\n\n    Examples:\n        &gt;&gt;&gt; df = spark.createDataFrame([(\"GCST000001\", \"1_1000_A_C\"), (\"GCST000002\", \"1_1000_A_C\")]).toDF(\"studyId\", \"variantId\")\n        &gt;&gt;&gt; df.withColumn(\"study_locus_id\", StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\"))).show()\n        +----------+----------+-------------------+\n        |   studyId| variantId|     study_locus_id|\n        +----------+----------+-------------------+\n        |GCST000001|1_1000_A_C|1553357789130151995|\n        |GCST000002|1_1000_A_C|-415050894682709184|\n        +----------+----------+-------------------+\n        &lt;BLANKLINE&gt;\n    \"\"\"\n    variant_id_col = f.coalesce(variant_id_col, f.rand().cast(\"string\"))\n    return f.xxhash64(study_id_col, variant_id_col).alias(\"studyLocusId\")\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.clump","title":"<code>clump() -&gt; StudyLocus</code>","text":"<p>Perform LD clumping of the studyLocus.</p> <p>Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.</p> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>with empty credible sets for linked variants and QC flag.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def clump(self: StudyLocus) -&gt; StudyLocus:\n    \"\"\"Perform LD clumping of the studyLocus.\n\n    Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.\n\n    Returns:\n        StudyLocus: with empty credible sets for linked variants and QC flag.\n    \"\"\"\n    self.df = (\n        self.df.withColumn(\n            \"is_lead_linked\",\n            LDclumping._is_lead_linked(\n                self.df.studyId,\n                self.df.variantId,\n                self.df.pValueExponent,\n                self.df.pValueMantissa,\n                self.df.ldSet,\n            ),\n        )\n        .withColumn(\n            \"ldSet\",\n            f.when(f.col(\"is_lead_linked\"), f.array()).otherwise(f.col(\"ldSet\")),\n        )\n        .withColumn(\n            \"qualityControls\",\n            StudyLocus._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.col(\"is_lead_linked\"),\n                StudyLocusQualityCheck.LD_CLUMPED,\n            ),\n        )\n        .drop(\"is_lead_linked\")\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.filter_credible_set","title":"<code>filter_credible_set(credible_interval: CredibleInterval) -&gt; StudyLocus</code>","text":"<p>Filter study-locus tag variants based on given credible interval.</p> <p>Parameters:</p> Name Type Description Default <code>credible_interval</code> <code>CredibleInterval</code> <p>Credible interval to filter for.</p> required <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>Filtered study-locus dataset.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def filter_credible_set(\n    self: StudyLocus,\n    credible_interval: CredibleInterval,\n) -&gt; StudyLocus:\n    \"\"\"Filter study-locus tag variants based on given credible interval.\n\n    Args:\n        credible_interval (CredibleInterval): Credible interval to filter for.\n\n    Returns:\n        StudyLocus: Filtered study-locus dataset.\n    \"\"\"\n    self.df = self._df.withColumn(\n        \"locus\",\n        f.filter(\n            f.col(\"locus\"),\n            lambda tag: (tag[credible_interval.value]),\n        ),\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.find_overlaps","title":"<code>find_overlaps(study_index: StudyIndex) -&gt; StudyLocusOverlap</code>","text":"<p>Calculate overlapping study-locus.</p> <p>Find overlapping study-locus that share at least one tagging variant. All GWAS-GWAS and all GWAS-Molecular traits are computed with the Molecular traits always appearing on the right side.</p> <p>Parameters:</p> Name Type Description Default <code>study_index</code> <code>StudyIndex</code> <p>Study index to resolve study types.</p> required <p>Returns:</p> Name Type Description <code>StudyLocusOverlap</code> <code>StudyLocusOverlap</code> <p>Pairs of overlapping study-locus with aligned tags.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def find_overlaps(self: StudyLocus, study_index: StudyIndex) -&gt; StudyLocusOverlap:\n    \"\"\"Calculate overlapping study-locus.\n\n    Find overlapping study-locus that share at least one tagging variant. All GWAS-GWAS and all GWAS-Molecular traits are computed with the Molecular traits always\n    appearing on the right side.\n\n    Args:\n        study_index (StudyIndex): Study index to resolve study types.\n\n    Returns:\n        StudyLocusOverlap: Pairs of overlapping study-locus with aligned tags.\n    \"\"\"\n    loci_to_overlap = (\n        self.df.join(study_index.study_type_lut(), on=\"studyId\", how=\"inner\")\n        .withColumn(\"locus\", f.explode(\"locus\"))\n        .select(\n            \"studyLocusId\",\n            \"studyType\",\n            \"chromosome\",\n            f.col(\"locus.variantId\").alias(\"tagVariantId\"),\n            f.col(\"locus.logABF\").alias(\"logABF\"),\n            f.col(\"locus.posteriorProbability\").alias(\"posteriorProbability\"),\n            f.col(\"locus.pValueMantissa\").alias(\"pValueMantissa\"),\n            f.col(\"locus.pValueExponent\").alias(\"pValueExponent\"),\n            f.col(\"locus.beta\").alias(\"beta\"),\n        )\n        .persist()\n    )\n\n    # overlapping study-locus\n    peak_overlaps = self._overlapping_peaks(loci_to_overlap)\n\n    # study-locus overlap by aligning overlapping variants\n    return self._align_overlapping_tags(loci_to_overlap, peak_overlaps)\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the StudyLocus dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>schema for the StudyLocus dataset.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[StudyLocus]) -&gt; StructType:\n    \"\"\"Provides the schema for the StudyLocus dataset.\n\n    Returns:\n        StructType: schema for the StudyLocus dataset.\n    \"\"\"\n    return parse_spark_schema(\"study_locus.json\")\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.neglog_pvalue","title":"<code>neglog_pvalue() -&gt; Column</code>","text":"<p>Returns the negative log p-value.</p> <p>Returns:</p> Name Type Description <code>Column</code> <code>Column</code> <p>Negative log p-value</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def neglog_pvalue(self: StudyLocus) -&gt; Column:\n    \"\"\"Returns the negative log p-value.\n\n    Returns:\n        Column: Negative log p-value\n    \"\"\"\n    return calculate_neglog_pvalue(\n        self.df.pValueMantissa,\n        self.df.pValueExponent,\n    )\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.unique_variants_in_locus","title":"<code>unique_variants_in_locus() -&gt; DataFrame</code>","text":"<p>All unique variants collected in a <code>StudyLocus</code> dataframe.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A dataframe containing <code>variantId</code> and <code>chromosome</code> columns.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def unique_variants_in_locus(self: StudyLocus) -&gt; DataFrame:\n    \"\"\"All unique variants collected in a `StudyLocus` dataframe.\n\n    Returns:\n        DataFrame: A dataframe containing `variantId` and `chromosome` columns.\n    \"\"\"\n    return (\n        self.df.withColumn(\n            \"variantId\",\n            # Joint array of variants in that studylocus. Locus can be null\n            f.explode(\n                f.array_union(\n                    f.array(f.col(\"variantId\")),\n                    f.coalesce(f.col(\"locus.variantId\"), f.array()),\n                )\n            ),\n        )\n        .select(\n            \"variantId\", f.split(f.col(\"variantId\"), \"_\")[0].alias(\"chromosome\")\n        )\n        .distinct()\n    )\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocusQualityCheck","title":"<code>otg.dataset.study_locus.StudyLocusQualityCheck</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Study-Locus quality control options listing concerns on the quality of the association.</p> <p>Attributes:</p> Name Type Description <code>SUBSIGNIFICANT_FLAG</code> <code>str</code> <p>p-value below significance threshold</p> <code>NO_GENOMIC_LOCATION_FLAG</code> <code>str</code> <p>Incomplete genomic mapping</p> <code>COMPOSITE_FLAG</code> <code>str</code> <p>Composite association due to variant x variant interactions</p> <code>VARIANT_INCONSISTENCY_FLAG</code> <code>str</code> <p>Inconsistencies in the reported variants</p> <code>NON_MAPPED_VARIANT_FLAG</code> <code>str</code> <p>Variant not mapped to GnomAd</p> <code>PALINDROMIC_ALLELE_FLAG</code> <code>str</code> <p>Alleles are palindromic - cannot harmonize</p> <code>AMBIGUOUS_STUDY</code> <code>str</code> <p>Association with ambiguous study</p> <code>UNRESOLVED_LD</code> <code>str</code> <p>Variant not found in LD reference</p> <code>LD_CLUMPED</code> <code>str</code> <p>Explained by a more significant variant in high LD (clumped)</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>class StudyLocusQualityCheck(Enum):\n    \"\"\"Study-Locus quality control options listing concerns on the quality of the association.\n\n    Attributes:\n        SUBSIGNIFICANT_FLAG (str): p-value below significance threshold\n        NO_GENOMIC_LOCATION_FLAG (str): Incomplete genomic mapping\n        COMPOSITE_FLAG (str): Composite association due to variant x variant interactions\n        VARIANT_INCONSISTENCY_FLAG (str): Inconsistencies in the reported variants\n        NON_MAPPED_VARIANT_FLAG (str): Variant not mapped to GnomAd\n        PALINDROMIC_ALLELE_FLAG (str): Alleles are palindromic - cannot harmonize\n        AMBIGUOUS_STUDY (str): Association with ambiguous study\n        UNRESOLVED_LD (str): Variant not found in LD reference\n        LD_CLUMPED (str): Explained by a more significant variant in high LD (clumped)\n    \"\"\"\n\n    SUBSIGNIFICANT_FLAG = \"Subsignificant p-value\"\n    NO_GENOMIC_LOCATION_FLAG = \"Incomplete genomic mapping\"\n    COMPOSITE_FLAG = \"Composite association\"\n    INCONSISTENCY_FLAG = \"Variant inconsistency\"\n    NON_MAPPED_VARIANT_FLAG = \"No mapping in GnomAd\"\n    PALINDROMIC_ALLELE_FLAG = \"Palindrome alleles - cannot harmonize\"\n    AMBIGUOUS_STUDY = \"Association with ambiguous study\"\n    UNRESOLVED_LD = \"Variant not found in LD reference\"\n    LD_CLUMPED = \"Explained by a more significant variant in high LD (clumped)\"\n    NO_POPULATION = \"Study does not have population annotation to resolve LD\"\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.CredibleInterval","title":"<code>otg.dataset.study_locus.CredibleInterval</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Credible interval enum.</p> <p>Interval within which an unobserved parameter value falls with a particular probability.</p> <p>Attributes:</p> Name Type Description <code>IS95</code> <code>str</code> <p>95% credible interval</p> <code>IS99</code> <code>str</code> <p>99% credible interval</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>class CredibleInterval(Enum):\n    \"\"\"Credible interval enum.\n\n    Interval within which an unobserved parameter value falls with a particular probability.\n\n    Attributes:\n        IS95 (str): 95% credible interval\n        IS99 (str): 99% credible interval\n    \"\"\"\n\n    IS95 = \"is95CredibleSet\"\n    IS99 = \"is99CredibleSet\"\n</code></pre>"},{"location":"python_api/dataset/study_locus/#schema","title":"Schema","text":"<pre><code>root\n |-- studyLocusId: long (nullable = false)\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = true)\n |-- position: integer (nullable = true)\n |-- studyId: string (nullable = false)\n |-- beta: double (nullable = true)\n |-- pValueMantissa: float (nullable = true)\n |-- pValueExponent: integer (nullable = true)\n |-- effectAlleleFrequencyFromSource: float (nullable = true)\n |-- standardError: double (nullable = true)\n |-- subStudyDescription: string (nullable = true)\n |-- qualityControls: array (nullable = true)\n |    |-- element: string (containsNull = false)\n |-- finemappingMethod: string (nullable = true)\n |-- sampleSize: integer (nullable = true)\n |-- ldSet: array (nullable = true)\n |    |-- element: struct (containsNull = true)\n |    |    |-- tagVariantId: string (nullable = true)\n |    |    |-- r2Overall: double (nullable = true)\n |-- locus: array (nullable = true)\n |    |-- element: struct (containsNull = true)\n |    |    |-- is95CredibleSet: boolean (nullable = true)\n |    |    |-- is99CredibleSet: boolean (nullable = true)\n |    |    |-- logABF: double (nullable = true)\n |    |    |-- posteriorProbability: double (nullable = true)\n |    |    |-- variantId: string (nullable = true)\n |    |    |-- pValueMantissa: float (nullable = true)\n |    |    |-- pValueExponent: integer (nullable = true)\n |    |    |-- pValueMantissaConditioned: float (nullable = true)\n |    |    |-- pValueExponentConditioned: integer (nullable = true)\n |    |    |-- beta: double (nullable = true)\n |    |    |-- standardError: double (nullable = true)\n |    |    |-- betaConditioned: double (nullable = true)\n |    |    |-- standardErrorConditioned: double (nullable = true)\n |    |    |-- r2Overall: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/","title":"Study Locus Overlap","text":""},{"location":"python_api/dataset/study_locus_overlap/#otg.dataset.study_locus_overlap.StudyLocusOverlap","title":"<code>otg.dataset.study_locus_overlap.StudyLocusOverlap</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Study-Locus overlap.</p> <p>This dataset captures pairs of overlapping <code>StudyLocus</code>: that is associations whose credible sets share at least one tagging variant.</p> <p>Note</p> <p>This is a helpful dataset for other downstream analyses, such as colocalisation. This dataset will contain the overlapping signals between studyLocus associations once they have been clumped and fine-mapped.</p> Source code in <code>src/otg/dataset/study_locus_overlap.py</code> <pre><code>@dataclass\nclass StudyLocusOverlap(Dataset):\n    \"\"\"Study-Locus overlap.\n\n    This dataset captures pairs of overlapping `StudyLocus`: that is associations whose credible sets share at least one tagging variant.\n\n    !!! note\n        This is a helpful dataset for other downstream analyses, such as colocalisation. This dataset will contain the overlapping signals between studyLocus associations once they have been clumped and fine-mapped.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[StudyLocusOverlap]) -&gt; StructType:\n        \"\"\"Provides the schema for the StudyLocusOverlap dataset.\n\n        Returns:\n            StructType: Schema for the StudyLocusOverlap dataset\n        \"\"\"\n        return parse_spark_schema(\"study_locus_overlap.json\")\n\n    @classmethod\n    def from_associations(\n        cls: type[StudyLocusOverlap], study_locus: StudyLocus, study_index: StudyIndex\n    ) -&gt; StudyLocusOverlap:\n        \"\"\"Find the overlapping signals in a particular set of associations (StudyLocus dataset).\n\n        Args:\n            study_locus (StudyLocus): Study-locus associations to find the overlapping signals\n            study_index (StudyIndex): Study index to find the overlapping signals\n\n        Returns:\n            StudyLocusOverlap: Study-locus overlap dataset\n        \"\"\"\n        return study_locus.find_overlaps(study_index)\n\n    def _convert_to_square_matrix(self: StudyLocusOverlap) -&gt; StudyLocusOverlap:\n        \"\"\"Convert the dataset to a square matrix.\n\n        Returns:\n            StudyLocusOverlap: Square matrix of the dataset\n        \"\"\"\n        return StudyLocusOverlap(\n            _df=self.df.unionByName(\n                self.df.selectExpr(\n                    \"leftStudyLocusId as rightStudyLocusId\",\n                    \"rightStudyLocusId as leftStudyLocusId\",\n                    \"tagVariantId\",\n                )\n            ).distinct(),\n            _schema=self.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/#otg.dataset.study_locus_overlap.StudyLocusOverlap.from_associations","title":"<code>from_associations(study_locus: StudyLocus, study_index: StudyIndex) -&gt; StudyLocusOverlap</code>  <code>classmethod</code>","text":"<p>Find the overlapping signals in a particular set of associations (StudyLocus dataset).</p> <p>Parameters:</p> Name Type Description Default <code>study_locus</code> <code>StudyLocus</code> <p>Study-locus associations to find the overlapping signals</p> required <code>study_index</code> <code>StudyIndex</code> <p>Study index to find the overlapping signals</p> required <p>Returns:</p> Name Type Description <code>StudyLocusOverlap</code> <code>StudyLocusOverlap</code> <p>Study-locus overlap dataset</p> Source code in <code>src/otg/dataset/study_locus_overlap.py</code> <pre><code>@classmethod\ndef from_associations(\n    cls: type[StudyLocusOverlap], study_locus: StudyLocus, study_index: StudyIndex\n) -&gt; StudyLocusOverlap:\n    \"\"\"Find the overlapping signals in a particular set of associations (StudyLocus dataset).\n\n    Args:\n        study_locus (StudyLocus): Study-locus associations to find the overlapping signals\n        study_index (StudyIndex): Study index to find the overlapping signals\n\n    Returns:\n        StudyLocusOverlap: Study-locus overlap dataset\n    \"\"\"\n    return study_locus.find_overlaps(study_index)\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/#otg.dataset.study_locus_overlap.StudyLocusOverlap.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the StudyLocusOverlap dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the StudyLocusOverlap dataset</p> Source code in <code>src/otg/dataset/study_locus_overlap.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[StudyLocusOverlap]) -&gt; StructType:\n    \"\"\"Provides the schema for the StudyLocusOverlap dataset.\n\n    Returns:\n        StructType: Schema for the StudyLocusOverlap dataset\n    \"\"\"\n    return parse_spark_schema(\"study_locus_overlap.json\")\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/#schema","title":"Schema","text":"<pre><code>root\n |-- leftStudyLocusId: long (nullable = false)\n |-- rightStudyLocusId: long (nullable = false)\n |-- chromosome: string (nullable = true)\n |-- tagVariantId: string (nullable = false)\n |-- statistics: struct (nullable = true)\n |    |-- left_pValueMantissa: float (nullable = true)\n |    |-- left_pValueExponent: integer (nullable = true)\n |    |-- right_pValueMantissa: float (nullable = true)\n |    |-- right_pValueExponent: integer (nullable = true)\n |    |-- left_beta: double (nullable = true)\n |    |-- right_beta: double (nullable = true)\n |    |-- left_logABF: double (nullable = true)\n |    |-- right_logABF: double (nullable = true)\n |    |-- left_posteriorProbability: double (nullable = true)\n |    |-- right_posteriorProbability: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/","title":"Summary Statistics","text":""},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics","title":"<code>otg.dataset.summary_statistics.SummaryStatistics</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Summary Statistics dataset.</p> <p>A summary statistics dataset contains all single point statistics resulting from a GWAS.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>@dataclass\nclass SummaryStatistics(Dataset):\n    \"\"\"Summary Statistics dataset.\n\n    A summary statistics dataset contains all single point statistics resulting from a GWAS.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[SummaryStatistics]) -&gt; StructType:\n        \"\"\"Provides the schema for the SummaryStatistics dataset.\n\n        Returns:\n            StructType: Schema for the SummaryStatistics dataset\n        \"\"\"\n        return parse_spark_schema(\"summary_statistics.json\")\n\n    def pvalue_filter(self: SummaryStatistics, pvalue: float) -&gt; SummaryStatistics:\n        \"\"\"Filter summary statistics based on the provided p-value threshold.\n\n        Args:\n            pvalue (float): upper limit of the p-value to be filtered upon.\n\n        Returns:\n            SummaryStatistics: summary statistics object containing single point associations with p-values at least as significant as the provided threshold.\n        \"\"\"\n        # Converting p-value to mantissa and exponent:\n        (mantissa, exponent) = split_pvalue(pvalue)\n\n        # Applying filter:\n        df = self._df.filter(\n            (f.col(\"pValueExponent\") &lt; exponent)\n            | (\n                (f.col(\"pValueExponent\") == exponent)\n                &amp; (f.col(\"pValueMantissa\") &lt;= mantissa)\n            )\n        )\n        return SummaryStatistics(_df=df, _schema=self._schema)\n\n    def window_based_clumping(\n        self: SummaryStatistics,\n        distance: int,\n        gwas_significance: float = 5e-8,\n        baseline_significance: float = 0.05,\n        locus_collect_distance: int | None = None,\n    ) -&gt; StudyLocus:\n        \"\"\"Generate study-locus from summary statistics by distance based clumping + collect locus.\n\n        Args:\n            distance (int): Distance in base pairs to be used for clumping.\n            gwas_significance (float, optional): GWAS significance threshold. Defaults to 5e-8.\n            baseline_significance (float, optional): Baseline significance threshold for inclusion in the locus. Defaults to 0.05.\n            locus_collect_distance (int | None): The distance to collect locus around semi-indices. If not provided, defaults to `distance`.\n\n        Returns:\n            StudyLocus: Clumped study-locus containing variants based on window.\n        \"\"\"\n        # If locus collect distance is present, collect locus with the provided distance:\n        if locus_collect_distance:\n            clumped_df = WindowBasedClumping.clump_with_locus(\n                self,\n                window_length=distance,\n                p_value_significance=gwas_significance,\n                p_value_baseline=baseline_significance,\n                locus_window_length=locus_collect_distance,\n            )\n        else:\n            clumped_df = WindowBasedClumping.clump(\n                self, window_length=distance, p_value_significance=gwas_significance\n            )\n\n        return clumped_df\n\n    def exclude_region(self: SummaryStatistics, region: str) -&gt; SummaryStatistics:\n        \"\"\"Exclude a region from the summary stats dataset.\n\n        Args:\n            region (str): region given in \"chr##:#####-####\" format\n\n        Returns:\n            SummaryStatistics: filtered summary statistics.\n        \"\"\"\n        (chromosome, start_position, end_position) = parse_region(region)\n\n        return SummaryStatistics(\n            _df=(\n                self.df.filter(\n                    ~(\n                        (f.col(\"chromosome\") == chromosome)\n                        &amp; (\n                            (f.col(\"position\") &gt;= start_position)\n                            &amp; (f.col(\"position\") &lt;= end_position)\n                        )\n                    )\n                )\n            ),\n            _schema=SummaryStatistics.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.exclude_region","title":"<code>exclude_region(region: str) -&gt; SummaryStatistics</code>","text":"<p>Exclude a region from the summary stats dataset.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>region given in \"chr##:#####-####\" format</p> required <p>Returns:</p> Name Type Description <code>SummaryStatistics</code> <code>SummaryStatistics</code> <p>filtered summary statistics.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>def exclude_region(self: SummaryStatistics, region: str) -&gt; SummaryStatistics:\n    \"\"\"Exclude a region from the summary stats dataset.\n\n    Args:\n        region (str): region given in \"chr##:#####-####\" format\n\n    Returns:\n        SummaryStatistics: filtered summary statistics.\n    \"\"\"\n    (chromosome, start_position, end_position) = parse_region(region)\n\n    return SummaryStatistics(\n        _df=(\n            self.df.filter(\n                ~(\n                    (f.col(\"chromosome\") == chromosome)\n                    &amp; (\n                        (f.col(\"position\") &gt;= start_position)\n                        &amp; (f.col(\"position\") &lt;= end_position)\n                    )\n                )\n            )\n        ),\n        _schema=SummaryStatistics.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the SummaryStatistics dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the SummaryStatistics dataset</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[SummaryStatistics]) -&gt; StructType:\n    \"\"\"Provides the schema for the SummaryStatistics dataset.\n\n    Returns:\n        StructType: Schema for the SummaryStatistics dataset\n    \"\"\"\n    return parse_spark_schema(\"summary_statistics.json\")\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.pvalue_filter","title":"<code>pvalue_filter(pvalue: float) -&gt; SummaryStatistics</code>","text":"<p>Filter summary statistics based on the provided p-value threshold.</p> <p>Parameters:</p> Name Type Description Default <code>pvalue</code> <code>float</code> <p>upper limit of the p-value to be filtered upon.</p> required <p>Returns:</p> Name Type Description <code>SummaryStatistics</code> <code>SummaryStatistics</code> <p>summary statistics object containing single point associations with p-values at least as significant as the provided threshold.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>def pvalue_filter(self: SummaryStatistics, pvalue: float) -&gt; SummaryStatistics:\n    \"\"\"Filter summary statistics based on the provided p-value threshold.\n\n    Args:\n        pvalue (float): upper limit of the p-value to be filtered upon.\n\n    Returns:\n        SummaryStatistics: summary statistics object containing single point associations with p-values at least as significant as the provided threshold.\n    \"\"\"\n    # Converting p-value to mantissa and exponent:\n    (mantissa, exponent) = split_pvalue(pvalue)\n\n    # Applying filter:\n    df = self._df.filter(\n        (f.col(\"pValueExponent\") &lt; exponent)\n        | (\n            (f.col(\"pValueExponent\") == exponent)\n            &amp; (f.col(\"pValueMantissa\") &lt;= mantissa)\n        )\n    )\n    return SummaryStatistics(_df=df, _schema=self._schema)\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.window_based_clumping","title":"<code>window_based_clumping(distance: int, gwas_significance: float = 5e-08, baseline_significance: float = 0.05, locus_collect_distance: int | None = None) -&gt; StudyLocus</code>","text":"<p>Generate study-locus from summary statistics by distance based clumping + collect locus.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>int</code> <p>Distance in base pairs to be used for clumping.</p> required <code>gwas_significance</code> <code>float</code> <p>GWAS significance threshold. Defaults to 5e-8.</p> <code>5e-08</code> <code>baseline_significance</code> <code>float</code> <p>Baseline significance threshold for inclusion in the locus. Defaults to 0.05.</p> <code>0.05</code> <code>locus_collect_distance</code> <code>int | None</code> <p>The distance to collect locus around semi-indices. If not provided, defaults to <code>distance</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>Clumped study-locus containing variants based on window.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>def window_based_clumping(\n    self: SummaryStatistics,\n    distance: int,\n    gwas_significance: float = 5e-8,\n    baseline_significance: float = 0.05,\n    locus_collect_distance: int | None = None,\n) -&gt; StudyLocus:\n    \"\"\"Generate study-locus from summary statistics by distance based clumping + collect locus.\n\n    Args:\n        distance (int): Distance in base pairs to be used for clumping.\n        gwas_significance (float, optional): GWAS significance threshold. Defaults to 5e-8.\n        baseline_significance (float, optional): Baseline significance threshold for inclusion in the locus. Defaults to 0.05.\n        locus_collect_distance (int | None): The distance to collect locus around semi-indices. If not provided, defaults to `distance`.\n\n    Returns:\n        StudyLocus: Clumped study-locus containing variants based on window.\n    \"\"\"\n    # If locus collect distance is present, collect locus with the provided distance:\n    if locus_collect_distance:\n        clumped_df = WindowBasedClumping.clump_with_locus(\n            self,\n            window_length=distance,\n            p_value_significance=gwas_significance,\n            p_value_baseline=baseline_significance,\n            locus_window_length=locus_collect_distance,\n        )\n    else:\n        clumped_df = WindowBasedClumping.clump(\n            self, window_length=distance, p_value_significance=gwas_significance\n        )\n\n    return clumped_df\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#schema","title":"Schema","text":"<pre><code>root\n |-- studyId: string (nullable = false)\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- position: integer (nullable = false)\n |-- beta: double (nullable = false)\n |-- sampleSize: integer (nullable = true)\n |-- pValueMantissa: float (nullable = false)\n |-- pValueExponent: integer (nullable = false)\n |-- effectAlleleFrequencyFromSource: float (nullable = true)\n |-- standardError: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/","title":"Variant annotation","text":""},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation","title":"<code>otg.dataset.variant_annotation.VariantAnnotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Dataset with variant-level annotations.</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>@dataclass\nclass VariantAnnotation(Dataset):\n    \"\"\"Dataset with variant-level annotations.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[VariantAnnotation]) -&gt; StructType:\n        \"\"\"Provides the schema for the VariantAnnotation dataset.\n\n        Returns:\n            StructType: Schema for the VariantAnnotation dataset\n        \"\"\"\n        return parse_spark_schema(\"variant_annotation.json\")\n\n    def max_maf(self: VariantAnnotation) -&gt; Column:\n        \"\"\"Maximum minor allele frequency accross all populations.\n\n        Returns:\n            Column: Maximum minor allele frequency accross all populations.\n        \"\"\"\n        return f.array_max(\n            f.transform(\n                self.df.alleleFrequencies,\n                lambda af: f.when(\n                    af.alleleFrequency &gt; 0.5, 1 - af.alleleFrequency\n                ).otherwise(af.alleleFrequency),\n            )\n        )\n\n    def filter_by_variant_df(\n        self: VariantAnnotation, df: DataFrame\n    ) -&gt; VariantAnnotation:\n        \"\"\"Filter variant annotation dataset by a variant dataframe.\n\n        Args:\n            df (DataFrame): A dataframe of variants\n\n        Returns:\n            VariantAnnotation: A filtered variant annotation dataset\n        \"\"\"\n        self.df = self._df.join(\n            f.broadcast(df.select(\"variantId\", \"chromosome\")),\n            on=[\"variantId\", \"chromosome\"],\n            how=\"inner\",\n        )\n        return self\n\n    def get_transcript_consequence_df(\n        self: VariantAnnotation, gene_index: GeneIndex | None = None\n    ) -&gt; DataFrame:\n        \"\"\"Dataframe of exploded transcript consequences.\n\n        Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n        Args:\n            gene_index (GeneIndex | None): A gene index. Defaults to None.\n\n        Returns:\n            DataFrame: A dataframe exploded by transcript consequences with the columns variantId, chromosome, transcriptConsequence\n        \"\"\"\n        # exploding the array removes records without VEP annotation\n        transript_consequences = self.df.withColumn(\n            \"transcriptConsequence\", f.explode(\"vep.transcriptConsequences\")\n        ).select(\n            \"variantId\",\n            \"chromosome\",\n            \"position\",\n            \"transcriptConsequence\",\n            f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n        )\n        if gene_index:\n            transript_consequences = transript_consequences.join(\n                f.broadcast(gene_index.df),\n                on=[\"chromosome\", \"geneId\"],\n            )\n        return transript_consequences.persist()\n\n    def get_most_severe_vep_v2g(\n        self: VariantAnnotation,\n        vep_consequences: DataFrame,\n        gene_index: GeneIndex,\n    ) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments based on VEP's predicted consequence of the transcript.\n\n        Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n        Args:\n            vep_consequences (DataFrame): A dataframe of VEP consequences\n            gene_index (GeneIndex): A gene index to filter by. Defaults to None.\n\n        Returns:\n            V2G: High and medium severity variant to gene assignments\n        \"\"\"\n        return V2G(\n            _df=self.get_transcript_consequence_df(gene_index)\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n                f.explode(\"transcriptConsequence.consequenceTerms\").alias(\"label\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"variantConsequence\").alias(\"datasourceId\"),\n            )\n            .join(\n                f.broadcast(vep_consequences),\n                on=\"label\",\n                how=\"inner\",\n            )\n            .drop(\"label\")\n            .filter(f.col(\"score\") != 0)\n            # A variant can have multiple predicted consequences on a transcript, the most severe one is selected\n            .transform(\n                lambda df: get_record_with_maximum_value(\n                    df, [\"variantId\", \"geneId\"], \"score\"\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_polyphen_v2g(\n        self: VariantAnnotation, gene_index: GeneIndex | None = None\n    ) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments with a PolyPhen's predicted score on the transcript.\n\n        Polyphen informs about the probability that a substitution is damaging.The score can be interpreted as follows:\n            - 0.0 to 0.15 -- Predicted to be benign.\n            - 0.15 to 1.0 -- Possibly damaging.\n            - 0.85 to 1.0 -- Predicted to be damaging.\n\n        Args:\n            gene_index (GeneIndex | None): A gene index to filter by. Defaults to None.\n\n        Returns:\n            V2G: variant to gene assignments with their polyphen scores\n        \"\"\"\n        return V2G(\n            _df=(\n                self.get_transcript_consequence_df(gene_index)\n                .filter(f.col(\"transcriptConsequence.polyphenScore\").isNotNull())\n                .select(\n                    \"variantId\",\n                    \"chromosome\",\n                    \"geneId\",\n                    f.col(\"transcriptConsequence.polyphenScore\").alias(\"score\"),\n                    f.lit(\"vep\").alias(\"datatypeId\"),\n                    f.lit(\"polyphen\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_sift_v2g(self: VariantAnnotation, gene_index: GeneIndex) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments with a SIFT's predicted score on the transcript.\n\n        SIFT informs about the probability that a substitution is tolerated. The score can be interpreted as follows:\n            - 0.0 to 0.05 -- Likely to be deleterious.\n            - 0.05 to 1.0 -- Likely to be tolerated.\n\n        Args:\n            gene_index (GeneIndex): A gene index to filter by.\n\n        Returns:\n            V2G: variant to gene assignments with their SIFT scores\n        \"\"\"\n        return V2G(\n            _df=(\n                self.get_transcript_consequence_df(gene_index)\n                .filter(f.col(\"transcriptConsequence.siftScore\").isNotNull())\n                .select(\n                    \"variantId\",\n                    \"chromosome\",\n                    \"geneId\",\n                    f.expr(\"1 - transcriptConsequence.siftScore\").alias(\"score\"),\n                    f.lit(\"vep\").alias(\"datatypeId\"),\n                    f.lit(\"sift\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_plof_v2g(self: VariantAnnotation, gene_index: GeneIndex) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments with a flag indicating if the variant is predicted to be a loss-of-function variant by the LOFTEE algorithm.\n\n        Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n        Args:\n            gene_index (GeneIndex): A gene index to filter by.\n\n        Returns:\n            V2G: variant to gene assignments from the LOFTEE algorithm\n        \"\"\"\n        return V2G(\n            _df=(\n                self.get_transcript_consequence_df(gene_index)\n                .filter(f.col(\"transcriptConsequence.lof\").isNotNull())\n                .withColumn(\n                    \"isHighQualityPlof\",\n                    f.when(f.col(\"transcriptConsequence.lof\") == \"HC\", True).when(\n                        f.col(\"transcriptConsequence.lof\") == \"LC\", False\n                    ),\n                )\n                .withColumn(\n                    \"score\",\n                    f.when(f.col(\"isHighQualityPlof\"), 1.0).when(\n                        ~f.col(\"isHighQualityPlof\"), 0\n                    ),\n                )\n                .select(\n                    \"variantId\",\n                    \"chromosome\",\n                    \"geneId\",\n                    \"isHighQualityPlof\",\n                    f.col(\"score\"),\n                    f.lit(\"vep\").alias(\"datatypeId\"),\n                    f.lit(\"loftee\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_distance_to_tss(\n        self: VariantAnnotation,\n        gene_index: GeneIndex,\n        max_distance: int = 500_000,\n    ) -&gt; V2G:\n        \"\"\"Extracts variant to gene assignments for variants falling within a window of a gene's TSS.\n\n        Args:\n            gene_index (GeneIndex): A gene index to filter by.\n            max_distance (int): The maximum distance from the TSS to consider. Defaults to 500_000.\n\n        Returns:\n            V2G: variant to gene assignments with their distance to the TSS\n        \"\"\"\n        return V2G(\n            _df=(\n                self.df.alias(\"variant\")\n                .join(\n                    f.broadcast(gene_index.locations_lut()).alias(\"gene\"),\n                    on=[\n                        f.col(\"variant.chromosome\") == f.col(\"gene.chromosome\"),\n                        f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n                        &lt;= max_distance,\n                    ],\n                    how=\"inner\",\n                )\n                .withColumn(\n                    \"distance\", f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n                )\n                .withColumn(\n                    \"inverse_distance\",\n                    max_distance - f.col(\"distance\"),\n                )\n                .transform(lambda df: normalise_column(df, \"inverse_distance\", \"score\"))\n                .select(\n                    \"variantId\",\n                    f.col(\"variant.chromosome\").alias(\"chromosome\"),\n                    \"distance\",\n                    \"geneId\",\n                    \"score\",\n                    f.lit(\"distance\").alias(\"datatypeId\"),\n                    f.lit(\"canonical_tss\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.filter_by_variant_df","title":"<code>filter_by_variant_df(df: DataFrame) -&gt; VariantAnnotation</code>","text":"<p>Filter variant annotation dataset by a variant dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe of variants</p> required <p>Returns:</p> Name Type Description <code>VariantAnnotation</code> <code>VariantAnnotation</code> <p>A filtered variant annotation dataset</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def filter_by_variant_df(\n    self: VariantAnnotation, df: DataFrame\n) -&gt; VariantAnnotation:\n    \"\"\"Filter variant annotation dataset by a variant dataframe.\n\n    Args:\n        df (DataFrame): A dataframe of variants\n\n    Returns:\n        VariantAnnotation: A filtered variant annotation dataset\n    \"\"\"\n    self.df = self._df.join(\n        f.broadcast(df.select(\"variantId\", \"chromosome\")),\n        on=[\"variantId\", \"chromosome\"],\n        how=\"inner\",\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_distance_to_tss","title":"<code>get_distance_to_tss(gene_index: GeneIndex, max_distance: int = 500000) -&gt; V2G</code>","text":"<p>Extracts variant to gene assignments for variants falling within a window of a gene's TSS.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by.</p> required <code>max_distance</code> <code>int</code> <p>The maximum distance from the TSS to consider. Defaults to 500_000.</p> <code>500000</code> <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments with their distance to the TSS</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_distance_to_tss(\n    self: VariantAnnotation,\n    gene_index: GeneIndex,\n    max_distance: int = 500_000,\n) -&gt; V2G:\n    \"\"\"Extracts variant to gene assignments for variants falling within a window of a gene's TSS.\n\n    Args:\n        gene_index (GeneIndex): A gene index to filter by.\n        max_distance (int): The maximum distance from the TSS to consider. Defaults to 500_000.\n\n    Returns:\n        V2G: variant to gene assignments with their distance to the TSS\n    \"\"\"\n    return V2G(\n        _df=(\n            self.df.alias(\"variant\")\n            .join(\n                f.broadcast(gene_index.locations_lut()).alias(\"gene\"),\n                on=[\n                    f.col(\"variant.chromosome\") == f.col(\"gene.chromosome\"),\n                    f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n                    &lt;= max_distance,\n                ],\n                how=\"inner\",\n            )\n            .withColumn(\n                \"distance\", f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n            )\n            .withColumn(\n                \"inverse_distance\",\n                max_distance - f.col(\"distance\"),\n            )\n            .transform(lambda df: normalise_column(df, \"inverse_distance\", \"score\"))\n            .select(\n                \"variantId\",\n                f.col(\"variant.chromosome\").alias(\"chromosome\"),\n                \"distance\",\n                \"geneId\",\n                \"score\",\n                f.lit(\"distance\").alias(\"datatypeId\"),\n                f.lit(\"canonical_tss\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_most_severe_vep_v2g","title":"<code>get_most_severe_vep_v2g(vep_consequences: DataFrame, gene_index: GeneIndex) -&gt; V2G</code>","text":"<p>Creates a dataset with variant to gene assignments based on VEP's predicted consequence of the transcript.</p> <p>Optionally the trancript consequences can be reduced to the universe of a gene index.</p> <p>Parameters:</p> Name Type Description Default <code>vep_consequences</code> <code>DataFrame</code> <p>A dataframe of VEP consequences</p> required <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by. Defaults to None.</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>High and medium severity variant to gene assignments</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_most_severe_vep_v2g(\n    self: VariantAnnotation,\n    vep_consequences: DataFrame,\n    gene_index: GeneIndex,\n) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments based on VEP's predicted consequence of the transcript.\n\n    Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n    Args:\n        vep_consequences (DataFrame): A dataframe of VEP consequences\n        gene_index (GeneIndex): A gene index to filter by. Defaults to None.\n\n    Returns:\n        V2G: High and medium severity variant to gene assignments\n    \"\"\"\n    return V2G(\n        _df=self.get_transcript_consequence_df(gene_index)\n        .select(\n            \"variantId\",\n            \"chromosome\",\n            f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n            f.explode(\"transcriptConsequence.consequenceTerms\").alias(\"label\"),\n            f.lit(\"vep\").alias(\"datatypeId\"),\n            f.lit(\"variantConsequence\").alias(\"datasourceId\"),\n        )\n        .join(\n            f.broadcast(vep_consequences),\n            on=\"label\",\n            how=\"inner\",\n        )\n        .drop(\"label\")\n        .filter(f.col(\"score\") != 0)\n        # A variant can have multiple predicted consequences on a transcript, the most severe one is selected\n        .transform(\n            lambda df: get_record_with_maximum_value(\n                df, [\"variantId\", \"geneId\"], \"score\"\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_plof_v2g","title":"<code>get_plof_v2g(gene_index: GeneIndex) -&gt; V2G</code>","text":"<p>Creates a dataset with variant to gene assignments with a flag indicating if the variant is predicted to be a loss-of-function variant by the LOFTEE algorithm.</p> <p>Optionally the trancript consequences can be reduced to the universe of a gene index.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by.</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments from the LOFTEE algorithm</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_plof_v2g(self: VariantAnnotation, gene_index: GeneIndex) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments with a flag indicating if the variant is predicted to be a loss-of-function variant by the LOFTEE algorithm.\n\n    Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n    Args:\n        gene_index (GeneIndex): A gene index to filter by.\n\n    Returns:\n        V2G: variant to gene assignments from the LOFTEE algorithm\n    \"\"\"\n    return V2G(\n        _df=(\n            self.get_transcript_consequence_df(gene_index)\n            .filter(f.col(\"transcriptConsequence.lof\").isNotNull())\n            .withColumn(\n                \"isHighQualityPlof\",\n                f.when(f.col(\"transcriptConsequence.lof\") == \"HC\", True).when(\n                    f.col(\"transcriptConsequence.lof\") == \"LC\", False\n                ),\n            )\n            .withColumn(\n                \"score\",\n                f.when(f.col(\"isHighQualityPlof\"), 1.0).when(\n                    ~f.col(\"isHighQualityPlof\"), 0\n                ),\n            )\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                \"geneId\",\n                \"isHighQualityPlof\",\n                f.col(\"score\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"loftee\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_polyphen_v2g","title":"<code>get_polyphen_v2g(gene_index: GeneIndex | None = None) -&gt; V2G</code>","text":"<p>Creates a dataset with variant to gene assignments with a PolyPhen's predicted score on the transcript.</p> <p>Polyphen informs about the probability that a substitution is damaging.The score can be interpreted as follows:     - 0.0 to 0.15 -- Predicted to be benign.     - 0.15 to 1.0 -- Possibly damaging.     - 0.85 to 1.0 -- Predicted to be damaging.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex | None</code> <p>A gene index to filter by. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments with their polyphen scores</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_polyphen_v2g(\n    self: VariantAnnotation, gene_index: GeneIndex | None = None\n) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments with a PolyPhen's predicted score on the transcript.\n\n    Polyphen informs about the probability that a substitution is damaging.The score can be interpreted as follows:\n        - 0.0 to 0.15 -- Predicted to be benign.\n        - 0.15 to 1.0 -- Possibly damaging.\n        - 0.85 to 1.0 -- Predicted to be damaging.\n\n    Args:\n        gene_index (GeneIndex | None): A gene index to filter by. Defaults to None.\n\n    Returns:\n        V2G: variant to gene assignments with their polyphen scores\n    \"\"\"\n    return V2G(\n        _df=(\n            self.get_transcript_consequence_df(gene_index)\n            .filter(f.col(\"transcriptConsequence.polyphenScore\").isNotNull())\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                \"geneId\",\n                f.col(\"transcriptConsequence.polyphenScore\").alias(\"score\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"polyphen\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the VariantAnnotation dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the VariantAnnotation dataset</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[VariantAnnotation]) -&gt; StructType:\n    \"\"\"Provides the schema for the VariantAnnotation dataset.\n\n    Returns:\n        StructType: Schema for the VariantAnnotation dataset\n    \"\"\"\n    return parse_spark_schema(\"variant_annotation.json\")\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_sift_v2g","title":"<code>get_sift_v2g(gene_index: GeneIndex) -&gt; V2G</code>","text":"<p>Creates a dataset with variant to gene assignments with a SIFT's predicted score on the transcript.</p> <p>SIFT informs about the probability that a substitution is tolerated. The score can be interpreted as follows:     - 0.0 to 0.05 -- Likely to be deleterious.     - 0.05 to 1.0 -- Likely to be tolerated.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by.</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments with their SIFT scores</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_sift_v2g(self: VariantAnnotation, gene_index: GeneIndex) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments with a SIFT's predicted score on the transcript.\n\n    SIFT informs about the probability that a substitution is tolerated. The score can be interpreted as follows:\n        - 0.0 to 0.05 -- Likely to be deleterious.\n        - 0.05 to 1.0 -- Likely to be tolerated.\n\n    Args:\n        gene_index (GeneIndex): A gene index to filter by.\n\n    Returns:\n        V2G: variant to gene assignments with their SIFT scores\n    \"\"\"\n    return V2G(\n        _df=(\n            self.get_transcript_consequence_df(gene_index)\n            .filter(f.col(\"transcriptConsequence.siftScore\").isNotNull())\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                \"geneId\",\n                f.expr(\"1 - transcriptConsequence.siftScore\").alias(\"score\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"sift\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_transcript_consequence_df","title":"<code>get_transcript_consequence_df(gene_index: GeneIndex | None = None) -&gt; DataFrame</code>","text":"<p>Dataframe of exploded transcript consequences.</p> <p>Optionally the trancript consequences can be reduced to the universe of a gene index.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex | None</code> <p>A gene index. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A dataframe exploded by transcript consequences with the columns variantId, chromosome, transcriptConsequence</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_transcript_consequence_df(\n    self: VariantAnnotation, gene_index: GeneIndex | None = None\n) -&gt; DataFrame:\n    \"\"\"Dataframe of exploded transcript consequences.\n\n    Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n    Args:\n        gene_index (GeneIndex | None): A gene index. Defaults to None.\n\n    Returns:\n        DataFrame: A dataframe exploded by transcript consequences with the columns variantId, chromosome, transcriptConsequence\n    \"\"\"\n    # exploding the array removes records without VEP annotation\n    transript_consequences = self.df.withColumn(\n        \"transcriptConsequence\", f.explode(\"vep.transcriptConsequences\")\n    ).select(\n        \"variantId\",\n        \"chromosome\",\n        \"position\",\n        \"transcriptConsequence\",\n        f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n    )\n    if gene_index:\n        transript_consequences = transript_consequences.join(\n            f.broadcast(gene_index.df),\n            on=[\"chromosome\", \"geneId\"],\n        )\n    return transript_consequences.persist()\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.max_maf","title":"<code>max_maf() -&gt; Column</code>","text":"<p>Maximum minor allele frequency accross all populations.</p> <p>Returns:</p> Name Type Description <code>Column</code> <code>Column</code> <p>Maximum minor allele frequency accross all populations.</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def max_maf(self: VariantAnnotation) -&gt; Column:\n    \"\"\"Maximum minor allele frequency accross all populations.\n\n    Returns:\n        Column: Maximum minor allele frequency accross all populations.\n    \"\"\"\n    return f.array_max(\n        f.transform(\n            self.df.alleleFrequencies,\n            lambda af: f.when(\n                af.alleleFrequency &gt; 0.5, 1 - af.alleleFrequency\n            ).otherwise(af.alleleFrequency),\n        )\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#schema","title":"Schema","text":"<pre><code>root\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- position: integer (nullable = false)\n |-- gnomad3VariantId: string (nullable = false)\n |-- referenceAllele: string (nullable = false)\n |-- alternateAllele: string (nullable = false)\n |-- chromosomeB37: string (nullable = true)\n |-- positionB37: integer (nullable = true)\n |-- alleleType: string (nullable = true)\n |-- rsIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- alleleFrequencies: array (nullable = false)\n |    |-- element: struct (containsNull = true)\n |    |    |-- populationName: string (nullable = true)\n |    |    |-- alleleFrequency: double (nullable = true)\n |-- cadd: struct (nullable = true)\n |    |-- phred: float (nullable = true)\n |    |-- raw: float (nullable = true)\n |-- vep: struct (nullable = false)\n |    |-- mostSevereConsequence: string (nullable = true)\n |    |-- transcriptConsequences: array (nullable = true)\n |    |    |-- element: struct (containsNull = true)\n |    |    |    |-- aminoAcids: string (nullable = true)\n |    |    |    |-- consequenceTerms: array (nullable = true)\n |    |    |    |    |-- element: string (containsNull = true)\n |    |    |    |-- geneId: string (nullable = true)\n |    |    |    |-- lof: string (nullable = true)\n |    |    |    |-- polyphenScore: double (nullable = true)\n |    |    |    |-- polyphenPrediction: string (nullable = true)\n |    |    |    |-- siftScore: double (nullable = true)\n |    |    |    |-- siftPrediction: string (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/variant_index/","title":"Variant index","text":""},{"location":"python_api/dataset/variant_index/#otg.dataset.variant_index.VariantIndex","title":"<code>otg.dataset.variant_index.VariantIndex</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Variant index dataset.</p> <p>Variant index dataset is the result of intersecting the variant annotation dataset with the variants with V2D available information.</p> Source code in <code>src/otg/dataset/variant_index.py</code> <pre><code>@dataclass\nclass VariantIndex(Dataset):\n    \"\"\"Variant index dataset.\n\n    Variant index dataset is the result of intersecting the variant annotation dataset with the variants with V2D available information.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[VariantIndex]) -&gt; StructType:\n        \"\"\"Provides the schema for the VariantIndex dataset.\n\n        Returns:\n            StructType: Schema for the VariantIndex dataset\n        \"\"\"\n        return parse_spark_schema(\"variant_index.json\")\n\n    @classmethod\n    def from_variant_annotation(\n        cls: type[VariantIndex],\n        variant_annotation: VariantAnnotation,\n        study_locus: StudyLocus,\n    ) -&gt; VariantIndex:\n        \"\"\"Initialise VariantIndex from pre-existing variant annotation dataset.\n\n        Args:\n            variant_annotation (VariantAnnotation): Variant annotation dataset\n            study_locus (StudyLocus): Study locus dataset with the variants to intersect with the variant annotation dataset\n\n        Returns:\n            VariantIndex: Variant index dataset\n        \"\"\"\n        unchanged_cols = [\n            \"variantId\",\n            \"chromosome\",\n            \"position\",\n            \"referenceAllele\",\n            \"alternateAllele\",\n            \"chromosomeB37\",\n            \"positionB37\",\n            \"alleleType\",\n            \"alleleFrequencies\",\n            \"cadd\",\n        ]\n        va_slimmed = variant_annotation.filter_by_variant_df(\n            study_locus.unique_variants_in_locus()\n        )\n        return cls(\n            _df=(\n                va_slimmed.df.select(\n                    *unchanged_cols,\n                    f.col(\"vep.mostSevereConsequence\").alias(\"mostSevereConsequence\"),\n                    # filters/rsid are arrays that can be empty, in this case we convert them to null\n                    nullify_empty_array(f.col(\"rsIds\")).alias(\"rsIds\"),\n                )\n                .repartition(400, \"chromosome\")\n                .sortWithinPartitions(\"chromosome\", \"position\")\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/variant_index/#otg.dataset.variant_index.VariantIndex.from_variant_annotation","title":"<code>from_variant_annotation(variant_annotation: VariantAnnotation, study_locus: StudyLocus) -&gt; VariantIndex</code>  <code>classmethod</code>","text":"<p>Initialise VariantIndex from pre-existing variant annotation dataset.</p> <p>Parameters:</p> Name Type Description Default <code>variant_annotation</code> <code>VariantAnnotation</code> <p>Variant annotation dataset</p> required <code>study_locus</code> <code>StudyLocus</code> <p>Study locus dataset with the variants to intersect with the variant annotation dataset</p> required <p>Returns:</p> Name Type Description <code>VariantIndex</code> <code>VariantIndex</code> <p>Variant index dataset</p> Source code in <code>src/otg/dataset/variant_index.py</code> <pre><code>@classmethod\ndef from_variant_annotation(\n    cls: type[VariantIndex],\n    variant_annotation: VariantAnnotation,\n    study_locus: StudyLocus,\n) -&gt; VariantIndex:\n    \"\"\"Initialise VariantIndex from pre-existing variant annotation dataset.\n\n    Args:\n        variant_annotation (VariantAnnotation): Variant annotation dataset\n        study_locus (StudyLocus): Study locus dataset with the variants to intersect with the variant annotation dataset\n\n    Returns:\n        VariantIndex: Variant index dataset\n    \"\"\"\n    unchanged_cols = [\n        \"variantId\",\n        \"chromosome\",\n        \"position\",\n        \"referenceAllele\",\n        \"alternateAllele\",\n        \"chromosomeB37\",\n        \"positionB37\",\n        \"alleleType\",\n        \"alleleFrequencies\",\n        \"cadd\",\n    ]\n    va_slimmed = variant_annotation.filter_by_variant_df(\n        study_locus.unique_variants_in_locus()\n    )\n    return cls(\n        _df=(\n            va_slimmed.df.select(\n                *unchanged_cols,\n                f.col(\"vep.mostSevereConsequence\").alias(\"mostSevereConsequence\"),\n                # filters/rsid are arrays that can be empty, in this case we convert them to null\n                nullify_empty_array(f.col(\"rsIds\")).alias(\"rsIds\"),\n            )\n            .repartition(400, \"chromosome\")\n            .sortWithinPartitions(\"chromosome\", \"position\")\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_index/#otg.dataset.variant_index.VariantIndex.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the VariantIndex dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the VariantIndex dataset</p> Source code in <code>src/otg/dataset/variant_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[VariantIndex]) -&gt; StructType:\n    \"\"\"Provides the schema for the VariantIndex dataset.\n\n    Returns:\n        StructType: Schema for the VariantIndex dataset\n    \"\"\"\n    return parse_spark_schema(\"variant_index.json\")\n</code></pre>"},{"location":"python_api/dataset/variant_index/#schema","title":"Schema","text":"<pre><code>root\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- position: integer (nullable = false)\n |-- referenceAllele: string (nullable = false)\n |-- alternateAllele: string (nullable = false)\n |-- chromosomeB37: string (nullable = true)\n |-- positionB37: integer (nullable = true)\n |-- alleleType: string (nullable = false)\n |-- alleleFrequencies: array (nullable = false)\n |    |-- element: struct (containsNull = true)\n |    |    |-- populationName: string (nullable = true)\n |    |    |-- alleleFrequency: double (nullable = true)\n |-- cadd: struct (nullable = true)\n |    |-- phred: float (nullable = true)\n |    |-- raw: float (nullable = true)\n |-- mostSevereConsequence: string (nullable = true)\n |-- rsIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/","title":"Variant-to-gene","text":""},{"location":"python_api/dataset/variant_to_gene/#otg.dataset.v2g.V2G","title":"<code>otg.dataset.v2g.V2G</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Variant-to-gene (V2G) evidence dataset.</p> <p>A variant-to-gene (V2G) evidence is understood as any piece of evidence that supports the association of a variant with a likely causal gene. The evidence can sometimes be context-specific and refer to specific <code>biofeatures</code> (e.g. cell types)</p> Source code in <code>src/otg/dataset/v2g.py</code> <pre><code>@dataclass\nclass V2G(Dataset):\n    \"\"\"Variant-to-gene (V2G) evidence dataset.\n\n    A variant-to-gene (V2G) evidence is understood as any piece of evidence that supports the association of a variant with a likely causal gene. The evidence can sometimes be context-specific and refer to specific `biofeatures` (e.g. cell types)\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[V2G]) -&gt; StructType:\n        \"\"\"Provides the schema for the V2G dataset.\n\n        Returns:\n            StructType: Schema for the V2G dataset\n        \"\"\"\n        return parse_spark_schema(\"v2g.json\")\n\n    def filter_by_genes(self: V2G, genes: GeneIndex) -&gt; V2G:\n        \"\"\"Filter V2G dataset by genes.\n\n        Args:\n            genes (GeneIndex): Gene index dataset to filter by\n\n        Returns:\n            V2G: V2G dataset filtered by genes\n        \"\"\"\n        self.df = self._df.join(genes.df.select(\"geneId\"), on=\"geneId\", how=\"inner\")\n        return self\n\n    def extract_distance_tss_minimum(self: V2G) -&gt; None:\n        \"\"\"Extract minimum distance to TSS.\"\"\"\n        self.df = self._df.filter(f.col(\"distance\")).withColumn(\n            \"distanceTssMinimum\",\n            f.expr(\"min(distTss) OVER (PARTITION BY studyLocusId)\"),\n        )\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/#otg.dataset.v2g.V2G.extract_distance_tss_minimum","title":"<code>extract_distance_tss_minimum() -&gt; None</code>","text":"<p>Extract minimum distance to TSS.</p> Source code in <code>src/otg/dataset/v2g.py</code> <pre><code>def extract_distance_tss_minimum(self: V2G) -&gt; None:\n    \"\"\"Extract minimum distance to TSS.\"\"\"\n    self.df = self._df.filter(f.col(\"distance\")).withColumn(\n        \"distanceTssMinimum\",\n        f.expr(\"min(distTss) OVER (PARTITION BY studyLocusId)\"),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/#otg.dataset.v2g.V2G.filter_by_genes","title":"<code>filter_by_genes(genes: GeneIndex) -&gt; V2G</code>","text":"<p>Filter V2G dataset by genes.</p> <p>Parameters:</p> Name Type Description Default <code>genes</code> <code>GeneIndex</code> <p>Gene index dataset to filter by</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>V2G dataset filtered by genes</p> Source code in <code>src/otg/dataset/v2g.py</code> <pre><code>def filter_by_genes(self: V2G, genes: GeneIndex) -&gt; V2G:\n    \"\"\"Filter V2G dataset by genes.\n\n    Args:\n        genes (GeneIndex): Gene index dataset to filter by\n\n    Returns:\n        V2G: V2G dataset filtered by genes\n    \"\"\"\n    self.df = self._df.join(genes.df.select(\"geneId\"), on=\"geneId\", how=\"inner\")\n    return self\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/#otg.dataset.v2g.V2G.get_schema","title":"<code>get_schema() -&gt; StructType</code>  <code>classmethod</code>","text":"<p>Provides the schema for the V2G dataset.</p> <p>Returns:</p> Name Type Description <code>StructType</code> <code>StructType</code> <p>Schema for the V2G dataset</p> Source code in <code>src/otg/dataset/v2g.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[V2G]) -&gt; StructType:\n    \"\"\"Provides the schema for the V2G dataset.\n\n    Returns:\n        StructType: Schema for the V2G dataset\n    \"\"\"\n    return parse_spark_schema(\"v2g.json\")\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/#schema","title":"Schema","text":"<pre><code>root\n |-- geneId: string (nullable = false)\n |-- variantId: string (nullable = false)\n |-- distance: long (nullable = true)\n |-- chromosome: string (nullable = false)\n |-- datatypeId: string (nullable = false)\n |-- datasourceId: string (nullable = false)\n |-- score: double (nullable = true)\n |-- resourceScore: double (nullable = true)\n |-- pmid: string (nullable = true)\n |-- biofeature: string (nullable = true)\n |-- variantFunctionalConsequenceId: string (nullable = true)\n |-- isHighQualityPlof: boolean (nullable = true)\n</code></pre>"},{"location":"python_api/datasource/_datasource/","title":"Data Source","text":"<p>TBC</p>"},{"location":"python_api/datasource/eqtl_catalogue/study_index/","title":"Study Index","text":""},{"location":"python_api/datasource/eqtl_catalogue/study_index/#otg.datasource.eqtl_catalogue.study_index.EqtlCatalogueStudyIndex","title":"<code>otg.datasource.eqtl_catalogue.study_index.EqtlCatalogueStudyIndex</code>","text":"<p>             Bases: <code>StudyIndex</code></p> <p>Study index dataset from eQTL Catalogue.</p> Source code in <code>src/otg/datasource/eqtl_catalogue/study_index.py</code> <pre><code>class EqtlCatalogueStudyIndex(StudyIndex):\n    \"\"\"Study index dataset from eQTL Catalogue.\"\"\"\n\n    @staticmethod\n    def _all_attributes() -&gt; List[Column]:\n        \"\"\"A helper function to return all study index attribute expressions.\n\n        Returns:\n            List[Column]: all study index attribute expressions.\n        \"\"\"\n        study_attributes = [\n            # Project ID, example: \"GTEx_V8\".\n            f.col(\"study\").alias(\"projectId\"),\n            # Partial study ID, example: \"GTEx_V8_Adipose_Subcutaneous\". This ID will be converted to final only when\n            # summary statistics are parsed, because it must also include a gene ID.\n            f.concat(f.col(\"study\"), f.lit(\"_\"), f.col(\"qtl_group\")).alias(\"studyId\"),\n            # Summary stats location.\n            f.col(\"ftp_path\").alias(\"summarystatsLocation\"),\n            # Constant value fields.\n            f.lit(True).alias(\"hasSumstats\"),\n            f.lit(\"eqtl\").alias(\"studyType\"),\n        ]\n        tissue_attributes = [\n            # Human readable tissue label, example: \"Adipose - Subcutaneous\".\n            f.col(\"tissue_label\").alias(\"traitFromSource\"),\n            # Ontology identifier for the tissue, for example: \"UBERON:0001157\".\n            f.array(\n                f.regexp_replace(\n                    f.regexp_replace(\n                        f.col(\"tissue_ontology_id\"),\n                        \"UBER_\",\n                        \"UBERON_\",\n                    ),\n                    \"_\",\n                    \":\",\n                )\n            ).alias(\"traitFromSourceMappedIds\"),\n        ]\n        sample_attributes = [\n            f.lit(838).cast(\"long\").alias(\"nSamples\"),\n            f.lit(\"838 (281 females and 557 males)\").alias(\"initialSampleSize\"),\n            f.array(\n                f.struct(\n                    f.lit(715).cast(\"long\").alias(\"sampleSize\"),\n                    f.lit(\"European American\").alias(\"ancestry\"),\n                ),\n                f.struct(\n                    f.lit(103).cast(\"long\").alias(\"sampleSize\"),\n                    f.lit(\"African American\").alias(\"ancestry\"),\n                ),\n                f.struct(\n                    f.lit(12).cast(\"long\").alias(\"sampleSize\"),\n                    f.lit(\"Asian American\").alias(\"ancestry\"),\n                ),\n                f.struct(\n                    f.lit(16).cast(\"long\").alias(\"sampleSize\"),\n                    f.lit(\"Hispanic or Latino\").alias(\"ancestry\"),\n                ),\n            ).alias(\"discoverySamples\"),\n        ]\n        publication_attributes = [\n            f.lit(\"32913098\").alias(\"pubmedId\"),\n            f.lit(\n                \"The GTEx Consortium atlas of genetic regulatory effects across human tissues\"\n            ).alias(\"publicationTitle\"),\n            f.lit(\"GTEx Consortium\").alias(\"publicationFirstAuthor\"),\n            f.lit(\"2020-09-11\").alias(\"publicationDate\"),\n            f.lit(\"Science\").alias(\"publicationJournal\"),\n        ]\n        return (\n            study_attributes\n            + tissue_attributes\n            + sample_attributes\n            + publication_attributes\n        )\n\n    @classmethod\n    def from_source(\n        cls: type[EqtlCatalogueStudyIndex],\n        eqtl_studies: DataFrame,\n    ) -&gt; EqtlCatalogueStudyIndex:\n        \"\"\"Ingest study level metadata from eQTL Catalogue.\n\n        Args:\n            eqtl_studies (DataFrame): ingested but unprocessed eQTL Catalogue studies.\n\n        Returns:\n            EqtlCatalogueStudyIndex: preliminary processed study index for eQTL Catalogue studies.\n        \"\"\"\n        return EqtlCatalogueStudyIndex(\n            _df=eqtl_studies.select(*cls._all_attributes()).withColumn(\n                \"ldPopulationStructure\",\n                cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n            ),\n            _schema=cls.get_schema(),\n        )\n\n    @classmethod\n    def add_gene_id_column(\n        cls: type[EqtlCatalogueStudyIndex],\n        study_index_df: DataFrame,\n        summary_stats_df: DataFrame,\n    ) -&gt; EqtlCatalogueStudyIndex:\n        \"\"\"Add a geneId column to the study index and explode.\n\n        While the original list contains one entry per tissue, what we consider as a single study is one mini-GWAS for\n        an expression of a _particular gene_ in a particular study.  At this stage we have a study index with partial\n        study IDs like \"PROJECT_QTLGROUP\", and a summary statistics object with full study IDs like\n        \"PROJECT_QTLGROUP_GENEID\", so we need to perform a merge and explosion to obtain our final study index.\n\n        Args:\n            study_index_df (DataFrame): preliminary study index for eQTL Catalogue studies.\n            summary_stats_df (DataFrame): summary statistics dataframe for eQTL Catalogue data.\n\n        Returns:\n            EqtlCatalogueStudyIndex: final study index for eQTL Catalogue studies.\n        \"\"\"\n        partial_to_full_study_id = (\n            summary_stats_df.select(f.col(\"studyId\"))\n            .distinct()\n            .select(\n                f.col(\"studyId\").alias(\"fullStudyId\"),  # PROJECT_QTLGROUP_GENEID\n                f.regexp_extract(f.col(\"studyId\"), r\"(.*)_[\\_]+\", 1).alias(\n                    \"studyId\"\n                ),  # PROJECT_QTLGROUP\n            )\n            .groupBy(\"studyId\")\n            .agg(f.collect_list(\"fullStudyId\").alias(\"fullStudyIdList\"))\n        )\n        study_index_df = (\n            study_index_df.join(partial_to_full_study_id, \"studyId\", \"inner\")\n            .withColumn(\"fullStudyId\", f.explode(\"fullStudyIdList\"))\n            .drop(\"fullStudyIdList\")\n            .withColumn(\"geneId\", f.regexp_extract(f.col(\"studyId\"), r\".*_([\\_]+)\", 1))\n            .drop(\"fullStudyId\")\n        )\n        return EqtlCatalogueStudyIndex(_df=study_index_df, _schema=cls.get_schema())\n</code></pre>"},{"location":"python_api/datasource/eqtl_catalogue/study_index/#otg.datasource.eqtl_catalogue.study_index.EqtlCatalogueStudyIndex.add_gene_id_column","title":"<code>add_gene_id_column(study_index_df: DataFrame, summary_stats_df: DataFrame) -&gt; EqtlCatalogueStudyIndex</code>  <code>classmethod</code>","text":"<p>Add a geneId column to the study index and explode.</p> <p>While the original list contains one entry per tissue, what we consider as a single study is one mini-GWAS for an expression of a particular gene in a particular study.  At this stage we have a study index with partial study IDs like \"PROJECT_QTLGROUP\", and a summary statistics object with full study IDs like \"PROJECT_QTLGROUP_GENEID\", so we need to perform a merge and explosion to obtain our final study index.</p> <p>Parameters:</p> Name Type Description Default <code>study_index_df</code> <code>DataFrame</code> <p>preliminary study index for eQTL Catalogue studies.</p> required <code>summary_stats_df</code> <code>DataFrame</code> <p>summary statistics dataframe for eQTL Catalogue data.</p> required <p>Returns:</p> Name Type Description <code>EqtlCatalogueStudyIndex</code> <code>EqtlCatalogueStudyIndex</code> <p>final study index for eQTL Catalogue studies.</p> Source code in <code>src/otg/datasource/eqtl_catalogue/study_index.py</code> <pre><code>@classmethod\ndef add_gene_id_column(\n    cls: type[EqtlCatalogueStudyIndex],\n    study_index_df: DataFrame,\n    summary_stats_df: DataFrame,\n) -&gt; EqtlCatalogueStudyIndex:\n    \"\"\"Add a geneId column to the study index and explode.\n\n    While the original list contains one entry per tissue, what we consider as a single study is one mini-GWAS for\n    an expression of a _particular gene_ in a particular study.  At this stage we have a study index with partial\n    study IDs like \"PROJECT_QTLGROUP\", and a summary statistics object with full study IDs like\n    \"PROJECT_QTLGROUP_GENEID\", so we need to perform a merge and explosion to obtain our final study index.\n\n    Args:\n        study_index_df (DataFrame): preliminary study index for eQTL Catalogue studies.\n        summary_stats_df (DataFrame): summary statistics dataframe for eQTL Catalogue data.\n\n    Returns:\n        EqtlCatalogueStudyIndex: final study index for eQTL Catalogue studies.\n    \"\"\"\n    partial_to_full_study_id = (\n        summary_stats_df.select(f.col(\"studyId\"))\n        .distinct()\n        .select(\n            f.col(\"studyId\").alias(\"fullStudyId\"),  # PROJECT_QTLGROUP_GENEID\n            f.regexp_extract(f.col(\"studyId\"), r\"(.*)_[\\_]+\", 1).alias(\n                \"studyId\"\n            ),  # PROJECT_QTLGROUP\n        )\n        .groupBy(\"studyId\")\n        .agg(f.collect_list(\"fullStudyId\").alias(\"fullStudyIdList\"))\n    )\n    study_index_df = (\n        study_index_df.join(partial_to_full_study_id, \"studyId\", \"inner\")\n        .withColumn(\"fullStudyId\", f.explode(\"fullStudyIdList\"))\n        .drop(\"fullStudyIdList\")\n        .withColumn(\"geneId\", f.regexp_extract(f.col(\"studyId\"), r\".*_([\\_]+)\", 1))\n        .drop(\"fullStudyId\")\n    )\n    return EqtlCatalogueStudyIndex(_df=study_index_df, _schema=cls.get_schema())\n</code></pre>"},{"location":"python_api/datasource/eqtl_catalogue/study_index/#otg.datasource.eqtl_catalogue.study_index.EqtlCatalogueStudyIndex.from_source","title":"<code>from_source(eqtl_studies: DataFrame) -&gt; EqtlCatalogueStudyIndex</code>  <code>classmethod</code>","text":"<p>Ingest study level metadata from eQTL Catalogue.</p> <p>Parameters:</p> Name Type Description Default <code>eqtl_studies</code> <code>DataFrame</code> <p>ingested but unprocessed eQTL Catalogue studies.</p> required <p>Returns:</p> Name Type Description <code>EqtlCatalogueStudyIndex</code> <code>EqtlCatalogueStudyIndex</code> <p>preliminary processed study index for eQTL Catalogue studies.</p> Source code in <code>src/otg/datasource/eqtl_catalogue/study_index.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[EqtlCatalogueStudyIndex],\n    eqtl_studies: DataFrame,\n) -&gt; EqtlCatalogueStudyIndex:\n    \"\"\"Ingest study level metadata from eQTL Catalogue.\n\n    Args:\n        eqtl_studies (DataFrame): ingested but unprocessed eQTL Catalogue studies.\n\n    Returns:\n        EqtlCatalogueStudyIndex: preliminary processed study index for eQTL Catalogue studies.\n    \"\"\"\n    return EqtlCatalogueStudyIndex(\n        _df=eqtl_studies.select(*cls._all_attributes()).withColumn(\n            \"ldPopulationStructure\",\n            cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/eqtl_catalogue/summary_stats/","title":"Summary Stats","text":""},{"location":"python_api/datasource/eqtl_catalogue/summary_stats/#otg.datasource.eqtl_catalogue.summary_stats.EqtlCatalogueSummaryStats","title":"<code>otg.datasource.eqtl_catalogue.summary_stats.EqtlCatalogueSummaryStats</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SummaryStatistics</code></p> <p>Summary statistics dataset for eQTL Catalogue.</p> Source code in <code>src/otg/datasource/eqtl_catalogue/summary_stats.py</code> <pre><code>@dataclass\nclass EqtlCatalogueSummaryStats(SummaryStatistics):\n    \"\"\"Summary statistics dataset for eQTL Catalogue.\"\"\"\n\n    @staticmethod\n    def _full_study_id_regexp() -&gt; Column:\n        \"\"\"Constructs a full study ID from the URI.\n\n        Returns:\n            Column: expression to extract a full study ID from the URI.\n        \"\"\"\n        # Example of a URI which is used for parsing:\n        # \"gs://genetics_etl_python_playground/input/preprocess/eqtl_catalogue/imported/GTEx_V8/ge/Adipose_Subcutaneous.tsv.gz\".\n\n        # Regular expession to extract project ID from URI.  Example: \"GTEx_V8\".\n        _project_id = f.regexp_extract(\n            f.input_file_name(),\n            r\"imported/([^/]+)/.*\",\n            1,\n        )\n        # Regular expression to extract QTL group from URI.  Example: \"Adipose_Subcutaneous\".\n        _qtl_group = f.regexp_extract(f.input_file_name(), r\"([^/]+)\\.tsv\\.gz\", 1)\n        # Extracting gene ID from the column.  Example: \"ENSG00000225630\".\n        _gene_id = f.col(\"gene_id\")\n\n        # We can now construct the full study ID based on all fields.\n        # Example: \"GTEx_V8_Adipose_Subcutaneous_ENSG00000225630\".\n        return f.concat(_project_id, f.lit(\"_\"), _qtl_group, f.lit(\"_\"), _gene_id)\n\n    @classmethod\n    def from_source(\n        cls: type[EqtlCatalogueSummaryStats],\n        summary_stats_df: DataFrame,\n    ) -&gt; EqtlCatalogueSummaryStats:\n        \"\"\"Ingests all summary stats for all eQTL Catalogue studies.\n\n        Args:\n            summary_stats_df (DataFrame): an ingested but unprocessed summary statistics dataframe from eQTL Catalogue.\n\n        Returns:\n            EqtlCatalogueSummaryStats: a processed summary statistics dataframe for eQTL Catalogue.\n        \"\"\"\n        processed_summary_stats_df = (\n            summary_stats_df.select(\n                # Construct study ID from the appropriate columns.\n                cls._full_study_id_regexp().alias(\"studyId\"),\n                # Add variant information.\n                f.concat_ws(\n                    \"_\",\n                    f.col(\"chromosome\"),\n                    f.col(\"position\"),\n                    f.col(\"ref\"),\n                    f.col(\"alt\"),\n                ).alias(\"variantId\"),\n                f.col(\"chromosome\"),\n                f.col(\"position\").cast(t.IntegerType()),\n                # Parse p-value into mantissa and exponent.\n                *parse_pvalue(f.col(\"pvalue\")),\n                # Add beta, standard error, and allele frequency information.\n                f.col(\"beta\").cast(\"double\"),\n                f.col(\"se\").cast(\"double\").alias(\"standardError\"),\n                f.col(\"maf\").cast(\"float\").alias(\"effectAlleleFrequencyFromSource\"),\n            )\n            # Drop rows which don't have proper position or beta value.\n            .filter(\n                f.col(\"position\").cast(t.IntegerType()).isNotNull()\n                &amp; (f.col(\"beta\") != 0)\n            )\n        )\n\n        # Initialise a summary statistics object.\n        return cls(\n            _df=processed_summary_stats_df,\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/eqtl_catalogue/summary_stats/#otg.datasource.eqtl_catalogue.summary_stats.EqtlCatalogueSummaryStats.from_source","title":"<code>from_source(summary_stats_df: DataFrame) -&gt; EqtlCatalogueSummaryStats</code>  <code>classmethod</code>","text":"<p>Ingests all summary stats for all eQTL Catalogue studies.</p> <p>Parameters:</p> Name Type Description Default <code>summary_stats_df</code> <code>DataFrame</code> <p>an ingested but unprocessed summary statistics dataframe from eQTL Catalogue.</p> required <p>Returns:</p> Name Type Description <code>EqtlCatalogueSummaryStats</code> <code>EqtlCatalogueSummaryStats</code> <p>a processed summary statistics dataframe for eQTL Catalogue.</p> Source code in <code>src/otg/datasource/eqtl_catalogue/summary_stats.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[EqtlCatalogueSummaryStats],\n    summary_stats_df: DataFrame,\n) -&gt; EqtlCatalogueSummaryStats:\n    \"\"\"Ingests all summary stats for all eQTL Catalogue studies.\n\n    Args:\n        summary_stats_df (DataFrame): an ingested but unprocessed summary statistics dataframe from eQTL Catalogue.\n\n    Returns:\n        EqtlCatalogueSummaryStats: a processed summary statistics dataframe for eQTL Catalogue.\n    \"\"\"\n    processed_summary_stats_df = (\n        summary_stats_df.select(\n            # Construct study ID from the appropriate columns.\n            cls._full_study_id_regexp().alias(\"studyId\"),\n            # Add variant information.\n            f.concat_ws(\n                \"_\",\n                f.col(\"chromosome\"),\n                f.col(\"position\"),\n                f.col(\"ref\"),\n                f.col(\"alt\"),\n            ).alias(\"variantId\"),\n            f.col(\"chromosome\"),\n            f.col(\"position\").cast(t.IntegerType()),\n            # Parse p-value into mantissa and exponent.\n            *parse_pvalue(f.col(\"pvalue\")),\n            # Add beta, standard error, and allele frequency information.\n            f.col(\"beta\").cast(\"double\"),\n            f.col(\"se\").cast(\"double\").alias(\"standardError\"),\n            f.col(\"maf\").cast(\"float\").alias(\"effectAlleleFrequencyFromSource\"),\n        )\n        # Drop rows which don't have proper position or beta value.\n        .filter(\n            f.col(\"position\").cast(t.IntegerType()).isNotNull()\n            &amp; (f.col(\"beta\") != 0)\n        )\n    )\n\n    # Initialise a summary statistics object.\n    return cls(\n        _df=processed_summary_stats_df,\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/finngen/_finngen/","title":"FinnGen","text":""},{"location":"python_api/datasource/finngen/study_index/","title":"Study Index","text":""},{"location":"python_api/datasource/finngen/study_index/#otg.datasource.finngen.study_index.FinnGenStudyIndex","title":"<code>otg.datasource.finngen.study_index.FinnGenStudyIndex</code>","text":"<p>             Bases: <code>StudyIndex</code></p> <p>Study index dataset from FinnGen.</p> <p>The following information is aggregated/extracted:</p> <ul> <li>Study ID in the special format (FINNGEN_R9_*)</li> <li>Trait name (for example, Amoebiasis)</li> <li>Number of cases and controls</li> <li>Link to the summary statistics location</li> </ul> <p>Some fields are also populated as constants, such as study type and the initial sample size.</p> Source code in <code>src/otg/datasource/finngen/study_index.py</code> <pre><code>class FinnGenStudyIndex(StudyIndex):\n    \"\"\"Study index dataset from FinnGen.\n\n    The following information is aggregated/extracted:\n\n    - Study ID in the special format (FINNGEN_R9_*)\n    - Trait name (for example, Amoebiasis)\n    - Number of cases and controls\n    - Link to the summary statistics location\n\n    Some fields are also populated as constants, such as study type and the initial sample size.\n    \"\"\"\n\n    @classmethod\n    def from_source(\n        cls: type[FinnGenStudyIndex],\n        finngen_studies: DataFrame,\n        finngen_release_prefix: str,\n        finngen_summary_stats_url_prefix: str,\n        finngen_summary_stats_url_suffix: str,\n    ) -&gt; FinnGenStudyIndex:\n        \"\"\"This function ingests study level metadata from FinnGen.\n\n        Args:\n            finngen_studies (DataFrame): FinnGen raw study table\n            finngen_release_prefix (str): Release prefix pattern.\n            finngen_summary_stats_url_prefix (str): URL prefix for summary statistics location.\n            finngen_summary_stats_url_suffix (str): URL prefix suffix for summary statistics location.\n\n        Returns:\n            FinnGenStudyIndex: Parsed and annotated FinnGen study table.\n        \"\"\"\n        return FinnGenStudyIndex(\n            _df=finngen_studies.select(\n                f.concat(f.lit(f\"{finngen_release_prefix}_\"), f.col(\"phenocode\")).alias(\n                    \"studyId\"\n                ),\n                f.col(\"phenostring\").alias(\"traitFromSource\"),\n                f.col(\"num_cases\").alias(\"nCases\"),\n                f.col(\"num_controls\").alias(\"nControls\"),\n                (f.col(\"num_cases\") + f.col(\"num_controls\")).alias(\"nSamples\"),\n                f.lit(finngen_release_prefix).alias(\"projectId\"),\n                f.lit(\"gwas\").alias(\"studyType\"),\n                f.lit(True).alias(\"hasSumstats\"),\n                f.lit(\"377,277 (210,870 females and 166,407 males)\").alias(\n                    \"initialSampleSize\"\n                ),\n                f.array(\n                    f.struct(\n                        f.lit(377277).cast(\"long\").alias(\"sampleSize\"),\n                        f.lit(\"Finnish\").alias(\"ancestry\"),\n                    )\n                ).alias(\"discoverySamples\"),\n                f.concat(\n                    f.lit(finngen_summary_stats_url_prefix),\n                    f.col(\"phenocode\"),\n                    f.lit(finngen_summary_stats_url_suffix),\n                ).alias(\"summarystatsLocation\"),\n            ).withColumn(\n                \"ldPopulationStructure\",\n                cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/finngen/study_index/#otg.datasource.finngen.study_index.FinnGenStudyIndex.from_source","title":"<code>from_source(finngen_studies: DataFrame, finngen_release_prefix: str, finngen_summary_stats_url_prefix: str, finngen_summary_stats_url_suffix: str) -&gt; FinnGenStudyIndex</code>  <code>classmethod</code>","text":"<p>This function ingests study level metadata from FinnGen.</p> <p>Parameters:</p> Name Type Description Default <code>finngen_studies</code> <code>DataFrame</code> <p>FinnGen raw study table</p> required <code>finngen_release_prefix</code> <code>str</code> <p>Release prefix pattern.</p> required <code>finngen_summary_stats_url_prefix</code> <code>str</code> <p>URL prefix for summary statistics location.</p> required <code>finngen_summary_stats_url_suffix</code> <code>str</code> <p>URL prefix suffix for summary statistics location.</p> required <p>Returns:</p> Name Type Description <code>FinnGenStudyIndex</code> <code>FinnGenStudyIndex</code> <p>Parsed and annotated FinnGen study table.</p> Source code in <code>src/otg/datasource/finngen/study_index.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[FinnGenStudyIndex],\n    finngen_studies: DataFrame,\n    finngen_release_prefix: str,\n    finngen_summary_stats_url_prefix: str,\n    finngen_summary_stats_url_suffix: str,\n) -&gt; FinnGenStudyIndex:\n    \"\"\"This function ingests study level metadata from FinnGen.\n\n    Args:\n        finngen_studies (DataFrame): FinnGen raw study table\n        finngen_release_prefix (str): Release prefix pattern.\n        finngen_summary_stats_url_prefix (str): URL prefix for summary statistics location.\n        finngen_summary_stats_url_suffix (str): URL prefix suffix for summary statistics location.\n\n    Returns:\n        FinnGenStudyIndex: Parsed and annotated FinnGen study table.\n    \"\"\"\n    return FinnGenStudyIndex(\n        _df=finngen_studies.select(\n            f.concat(f.lit(f\"{finngen_release_prefix}_\"), f.col(\"phenocode\")).alias(\n                \"studyId\"\n            ),\n            f.col(\"phenostring\").alias(\"traitFromSource\"),\n            f.col(\"num_cases\").alias(\"nCases\"),\n            f.col(\"num_controls\").alias(\"nControls\"),\n            (f.col(\"num_cases\") + f.col(\"num_controls\")).alias(\"nSamples\"),\n            f.lit(finngen_release_prefix).alias(\"projectId\"),\n            f.lit(\"gwas\").alias(\"studyType\"),\n            f.lit(True).alias(\"hasSumstats\"),\n            f.lit(\"377,277 (210,870 females and 166,407 males)\").alias(\n                \"initialSampleSize\"\n            ),\n            f.array(\n                f.struct(\n                    f.lit(377277).cast(\"long\").alias(\"sampleSize\"),\n                    f.lit(\"Finnish\").alias(\"ancestry\"),\n                )\n            ).alias(\"discoverySamples\"),\n            f.concat(\n                f.lit(finngen_summary_stats_url_prefix),\n                f.col(\"phenocode\"),\n                f.lit(finngen_summary_stats_url_suffix),\n            ).alias(\"summarystatsLocation\"),\n        ).withColumn(\n            \"ldPopulationStructure\",\n            cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gnomad/_gnomad/","title":"GnomAD","text":""},{"location":"python_api/datasource/gnomad/gnomad_ld/","title":"LD Matrix","text":""},{"location":"python_api/datasource/gnomad/gnomad_ld/#otg.datasource.gnomad.ld.GnomADLDMatrix","title":"<code>otg.datasource.gnomad.ld.GnomADLDMatrix</code>  <code>dataclass</code>","text":"<p>Toolset ot interact with GnomAD LD dataset (version: r2.1.1).</p> <p>Datasets are accessed in Hail's native format, as provided by the GnomAD consortium.</p> <p>Attributes:</p> Name Type Description <code>ld_matrix_template</code> <code>str</code> <p>Template for the LD matrix path. Defaults to \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.adj.ld.bm\".</p> <code>ld_index_raw_template</code> <code>str</code> <p>Template for the LD index path. Defaults to \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.ld.variant_indices.ht\".</p> <code>grch37_to_grch38_chain_path</code> <code>str</code> <p>Path to the chain file used to lift over the coordinates. Defaults to \"gs://hail-common/references/grch37_to_grch38.over.chain.gz\".</p> <code>ld_populations</code> <code>list[str]</code> <p>List of populations to use to build the LDIndex. Defaults to [\"afr\", \"amr\", \"asj\", \"eas\", \"fin\", \"nfe\", \"nwe\", \"seu\"].</p> Source code in <code>src/otg/datasource/gnomad/ld.py</code> <pre><code>@dataclass\nclass GnomADLDMatrix:\n    \"\"\"Toolset ot interact with GnomAD LD dataset (version: r2.1.1).\n\n    Datasets are accessed in Hail's native format, as provided by the [GnomAD consortium](https://gnomad.broadinstitute.org/downloads/#v2-linkage-disequilibrium).\n\n    Attributes:\n        ld_matrix_template (str): Template for the LD matrix path. Defaults to \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.adj.ld.bm\".\n        ld_index_raw_template (str): Template for the LD index path. Defaults to \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.ld.variant_indices.ht\".\n        grch37_to_grch38_chain_path (str): Path to the chain file used to lift over the coordinates. Defaults to \"gs://hail-common/references/grch37_to_grch38.over.chain.gz\".\n        ld_populations (list[str]): List of populations to use to build the LDIndex. Defaults to [\"afr\", \"amr\", \"asj\", \"eas\", \"fin\", \"nfe\", \"nwe\", \"seu\"].\n    \"\"\"\n\n    ld_matrix_template: str = \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.adj.ld.bm\"\n    ld_index_raw_template: str = \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.ld.variant_indices.ht\"\n    grch37_to_grch38_chain_path: str = (\n        \"gs://hail-common/references/grch37_to_grch38.over.chain.gz\"\n    )\n    ld_populations: list[str] = field(\n        default_factory=lambda: [\n            \"afr\",  # African-American\n            \"amr\",  # American Admixed/Latino\n            \"asj\",  # Ashkenazi Jewish\n            \"eas\",  # East Asian\n            \"fin\",  # Finnish\n            \"nfe\",  # Non-Finnish European\n            \"nwe\",  # Northwestern European\n            \"seu\",  # Southeastern European\n        ]\n    )\n\n    @staticmethod\n    def _aggregate_ld_index_across_populations(\n        unaggregated_ld_index: DataFrame,\n    ) -&gt; DataFrame:\n        \"\"\"Aggregate LDIndex across populations.\n\n        Args:\n            unaggregated_ld_index (DataFrame): Unaggregate LDIndex index dataframe  each row is a variant pair in a population\n\n        Returns:\n            DataFrame: Aggregated LDIndex index dataframe  each row is a variant with the LD set across populations\n\n        Examples:\n            &gt;&gt;&gt; data = [(\"1.0\", \"var1\", \"X\", \"var1\", \"pop1\"), (\"1.0\", \"X\", \"var2\", \"var2\", \"pop1\"),\n            ...         (\"0.5\", \"var1\", \"X\", \"var2\", \"pop1\"), (\"0.5\", \"var1\", \"X\", \"var2\", \"pop2\"),\n            ...         (\"0.5\", \"var2\", \"X\", \"var1\", \"pop1\"), (\"0.5\", \"X\", \"var2\", \"var1\", \"pop2\")]\n            &gt;&gt;&gt; df = spark.createDataFrame(data, [\"r\", \"variantId\", \"chromosome\", \"tagvariantId\", \"population\"])\n            &gt;&gt;&gt; GnomADLDMatrix._aggregate_ld_index_across_populations(df).printSchema()\n            root\n             |-- variantId: string (nullable = true)\n             |-- chromosome: string (nullable = true)\n             |-- ldSet: array (nullable = false)\n             |    |-- element: struct (containsNull = false)\n             |    |    |-- tagVariantId: string (nullable = true)\n             |    |    |-- rValues: array (nullable = false)\n             |    |    |    |-- element: struct (containsNull = false)\n             |    |    |    |    |-- population: string (nullable = true)\n             |    |    |    |    |-- r: string (nullable = true)\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        return (\n            unaggregated_ld_index\n            # First level of aggregation: get r/population for each variant/tagVariant pair\n            .withColumn(\"r_pop_struct\", f.struct(\"population\", \"r\"))\n            .groupBy(\"chromosome\", \"variantId\", \"tagVariantId\")\n            .agg(\n                f.collect_set(\"r_pop_struct\").alias(\"rValues\"),\n            )\n            # Second level of aggregation: get r/population for each variant\n            .withColumn(\"r_pop_tag_struct\", f.struct(\"tagVariantId\", \"rValues\"))\n            .groupBy(\"variantId\", \"chromosome\")\n            .agg(\n                f.collect_set(\"r_pop_tag_struct\").alias(\"ldSet\"),\n            )\n        )\n\n    @staticmethod\n    def _convert_ld_matrix_to_table(\n        block_matrix: BlockMatrix, min_r2: float\n    ) -&gt; DataFrame:\n        \"\"\"Convert LD matrix to table.\n\n        Args:\n            block_matrix (BlockMatrix): LD matrix\n            min_r2 (float): Minimum r2 value to keep in the table\n\n        Returns:\n            DataFrame: LD matrix as a Spark DataFrame\n        \"\"\"\n        table = block_matrix.entries(keyed=False)\n        return (\n            table.filter(hl.abs(table.entry) &gt;= min_r2**0.5)\n            .to_spark()\n            .withColumnRenamed(\"entry\", \"r\")\n        )\n\n    @staticmethod\n    def _create_ldindex_for_population(\n        population_id: str,\n        ld_matrix_path: str,\n        ld_index_raw_path: str,\n        grch37_to_grch38_chain_path: str,\n        min_r2: float,\n    ) -&gt; DataFrame:\n        \"\"\"Create LDIndex for a specific population.\n\n        Args:\n            population_id (str): Population ID\n            ld_matrix_path (str): Path to the LD matrix\n            ld_index_raw_path (str): Path to the LD index\n            grch37_to_grch38_chain_path (str): Path to the chain file used to lift over the coordinates\n            min_r2 (float): Minimum r2 value to keep in the table\n\n        Returns:\n            DataFrame: LDIndex for a specific population\n        \"\"\"\n        # Prepare LD Block matrix\n        ld_matrix = GnomADLDMatrix._convert_ld_matrix_to_table(\n            BlockMatrix.read(ld_matrix_path), min_r2\n        )\n\n        # Prepare table with variant indices\n        ld_index = GnomADLDMatrix._process_variant_indices(\n            hl.read_table(ld_index_raw_path),\n            grch37_to_grch38_chain_path,\n        )\n\n        return GnomADLDMatrix._resolve_variant_indices(ld_index, ld_matrix).select(\n            \"*\",\n            f.lit(population_id).alias(\"population\"),\n        )\n\n    @staticmethod\n    def _process_variant_indices(\n        ld_index_raw: hl.Table, grch37_to_grch38_chain_path: str\n    ) -&gt; DataFrame:\n        \"\"\"Creates a look up table between variants and their coordinates in the LD Matrix.\n\n        !!! info \"Gnomad's LD Matrix and Index are based on GRCh37 coordinates. This function will lift over the coordinates to GRCh38 to build the lookup table.\"\n\n        Args:\n            ld_index_raw (hl.Table): LD index table from GnomAD\n            grch37_to_grch38_chain_path (str): Path to the chain file used to lift over the coordinates\n\n        Returns:\n            DataFrame: Look up table between variants in build hg38 and their coordinates in the LD Matrix\n        \"\"\"\n        ld_index_38 = _liftover_loci(\n            ld_index_raw, grch37_to_grch38_chain_path, \"GRCh38\"\n        )\n\n        return (\n            ld_index_38.to_spark()\n            # Filter out variants where the liftover failed\n            .filter(f.col(\"`locus_GRCh38.position`\").isNotNull())\n            .withColumn(\n                \"chromosome\", f.regexp_replace(\"`locus_GRCh38.contig`\", \"chr\", \"\")\n            )\n            .withColumn(\n                \"position\",\n                convert_gnomad_position_to_ensembl(\n                    f.col(\"`locus_GRCh38.position`\"),\n                    f.col(\"`alleles`\").getItem(0),\n                    f.col(\"`alleles`\").getItem(1),\n                ),\n            )\n            .select(\n                \"chromosome\",\n                \"position\",\n                f.concat_ws(\n                    \"_\",\n                    f.col(\"chromosome\"),\n                    f.col(\"position\"),\n                    f.col(\"`alleles`\").getItem(0),\n                    f.col(\"`alleles`\").getItem(1),\n                ).alias(\"variantId\"),\n                f.col(\"idx\"),\n            )\n            # Filter out ambiguous liftover results: multiple indices for the same variant\n            .withColumn(\"count\", f.count(\"*\").over(Window.partitionBy([\"variantId\"])))\n            .filter(f.col(\"count\") == 1)\n            .drop(\"count\")\n        )\n\n    @staticmethod\n    def _resolve_variant_indices(\n        ld_index: DataFrame, ld_matrix: DataFrame\n    ) -&gt; DataFrame:\n        \"\"\"Resolve the `i` and `j` indices of the block matrix to variant IDs (build 38).\n\n        Args:\n            ld_index (DataFrame): Dataframe with resolved variant indices\n            ld_matrix (DataFrame): Dataframe with the filtered LD matrix\n\n        Returns:\n            DataFrame: Dataframe with variant IDs instead of `i` and `j` indices\n        \"\"\"\n        ld_index_i = ld_index.selectExpr(\n            \"idx as i\", \"variantId as variantId_i\", \"chromosome\"\n        )\n        ld_index_j = ld_index.selectExpr(\"idx as j\", \"variantId as variantId_j\")\n        return (\n            ld_matrix.join(ld_index_i, on=\"i\", how=\"inner\")\n            .join(ld_index_j, on=\"j\", how=\"inner\")\n            .drop(\"i\", \"j\")\n        )\n\n    @staticmethod\n    def _transpose_ld_matrix(ld_matrix: DataFrame) -&gt; DataFrame:\n        \"\"\"Transpose LD matrix to a square matrix format.\n\n        Args:\n            ld_matrix (DataFrame): Triangular LD matrix converted to a Spark DataFrame\n\n        Returns:\n            DataFrame: Square LD matrix without diagonal duplicates\n\n        Examples:\n            &gt;&gt;&gt; df = spark.createDataFrame(\n            ...     [\n            ...         (1, 1, 1.0, \"1\", \"AFR\"),\n            ...         (1, 2, 0.5, \"1\", \"AFR\"),\n            ...         (2, 2, 1.0, \"1\", \"AFR\"),\n            ...     ],\n            ...     [\"variantId_i\", \"variantId_j\", \"r\", \"chromosome\", \"population\"],\n            ... )\n            &gt;&gt;&gt; GnomADLDMatrix._transpose_ld_matrix(df).show()\n            +-----------+-----------+---+----------+----------+\n            |variantId_i|variantId_j|  r|chromosome|population|\n            +-----------+-----------+---+----------+----------+\n            |          1|          2|0.5|         1|       AFR|\n            |          1|          1|1.0|         1|       AFR|\n            |          2|          1|0.5|         1|       AFR|\n            |          2|          2|1.0|         1|       AFR|\n            +-----------+-----------+---+----------+----------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        ld_matrix_transposed = ld_matrix.selectExpr(\n            \"variantId_i as variantId_j\",\n            \"variantId_j as variantId_i\",\n            \"r\",\n            \"chromosome\",\n            \"population\",\n        )\n        return ld_matrix.filter(\n            f.col(\"variantId_i\") != f.col(\"variantId_j\")\n        ).unionByName(ld_matrix_transposed)\n\n    def as_ld_index(\n        self: GnomADLDMatrix,\n        min_r2: float,\n    ) -&gt; LDIndex:\n        \"\"\"Create LDIndex dataset aggregating the LD information across a set of populations.\n\n        **The basic steps to generate the LDIndex are:**\n\n        1. Convert LD matrix to a Spark DataFrame.\n        2. Resolve the matrix indices to variant IDs by lifting over the coordinates to GRCh38.\n        3. Aggregate the LD information across populations.\n\n        Args:\n            min_r2 (float): Minimum r2 value to keep in the table\n\n        Returns:\n            LDIndex: LDIndex dataset\n        \"\"\"\n        ld_indices_unaggregated = []\n        for pop in self.ld_populations:\n            try:\n                ld_matrix_path = self.ld_matrix_template.format(POP=pop)\n                ld_index_raw_path = self.ld_index_raw_template.format(POP=pop)\n                pop_ld_index = self._create_ldindex_for_population(\n                    pop,\n                    ld_matrix_path,\n                    ld_index_raw_path.format(pop),\n                    self.grch37_to_grch38_chain_path,\n                    min_r2,\n                )\n                ld_indices_unaggregated.append(pop_ld_index)\n            except Exception as e:\n                print(f\"Failed to create LDIndex for population {pop}: {e}\")\n                sys.exit(1)\n\n        ld_index_unaggregated = (\n            GnomADLDMatrix._transpose_ld_matrix(\n                reduce(lambda df1, df2: df1.unionByName(df2), ld_indices_unaggregated)\n            )\n            .withColumnRenamed(\"variantId_i\", \"variantId\")\n            .withColumnRenamed(\"variantId_j\", \"tagVariantId\")\n        )\n        return LDIndex(\n            _df=self._aggregate_ld_index_across_populations(ld_index_unaggregated),\n            _schema=LDIndex.get_schema(),\n        )\n\n    def get_ld_variants(\n        self: GnomADLDMatrix,\n        gnomad_ancestry: str,\n        chromosome: str,\n        start: int,\n        end: int,\n    ) -&gt; DataFrame | None:\n        \"\"\"Return melted LD table with resolved variant id based on ancestry and genomic location.\n\n        Args:\n            gnomad_ancestry (str): GnomAD major ancestry label eg. `nfe`\n            chromosome (str): chromosome label\n            start (int): window upper bound\n            end (int): window lower bound\n\n        Returns:\n            DataFrame | None: LD table with resolved variant id based on ancestry and genomic location\n        \"\"\"\n        # Extracting locus:\n        ld_index_df = (\n            self._process_variant_indices(\n                hl.read_table(self.ld_index_raw_template.format(POP=gnomad_ancestry)),\n                self.grch37_to_grch38_chain_path,\n            )\n            .filter(\n                (f.col(\"chromosome\") == chromosome)\n                &amp; (f.col(\"position\") &gt;= start)\n                &amp; (f.col(\"position\") &lt;= end)\n            )\n            .select(\"chromosome\", \"position\", \"variantId\", \"idx\")\n            .persist()\n        )\n\n        if ld_index_df.limit(1).count() == 0:\n            # If the returned slice from the ld index is empty, return None\n            return None\n\n        # Compute start and end indices\n        start_index = get_value_from_row(\n            get_top_ranked_in_window(\n                ld_index_df, Window.partitionBy().orderBy(f.col(\"position\").asc())\n            ).collect()[0],\n            \"idx\",\n        )\n        end_index = get_value_from_row(\n            get_top_ranked_in_window(\n                ld_index_df, Window.partitionBy().orderBy(f.col(\"position\").desc())\n            ).collect()[0],\n            \"idx\",\n        )\n\n        return self._extract_square_matrix(\n            ld_index_df, gnomad_ancestry, start_index, end_index\n        )\n\n    def _extract_square_matrix(\n        self: GnomADLDMatrix,\n        ld_index_df: DataFrame,\n        gnomad_ancestry: str,\n        start_index: int,\n        end_index: int,\n    ) -&gt; DataFrame:\n        \"\"\"Return LD square matrix for a region where coordinates are normalised.\n\n        Args:\n            ld_index_df (DataFrame): Look up table between a variantId and its index in the LD matrix\n            gnomad_ancestry (str): GnomAD major ancestry label eg. `nfe`\n            start_index (int): start index of the slice\n            end_index (int): end index of the slice\n\n        Returns:\n            DataFrame: square LD matrix resolved to variants.\n        \"\"\"\n        return (\n            self.get_ld_matrix_slice(\n                gnomad_ancestry, start_index=start_index, end_index=end_index\n            )\n            .join(\n                ld_index_df.select(\n                    f.col(\"idx\").alias(\"idx_i\"),\n                    f.col(\"variantId\").alias(\"variantId_i\"),\n                ),\n                on=\"idx_i\",\n                how=\"inner\",\n            )\n            .join(\n                ld_index_df.select(\n                    f.col(\"idx\").alias(\"idx_j\"),\n                    f.col(\"variantId\").alias(\"variantId_j\"),\n                ),\n                on=\"idx_j\",\n                how=\"inner\",\n            )\n            .select(\"variantId_i\", \"variantId_j\", \"r\")\n        )\n\n    def get_ld_matrix_slice(\n        self: GnomADLDMatrix,\n        gnomad_ancestry: str,\n        start_index: int,\n        end_index: int,\n    ) -&gt; DataFrame:\n        \"\"\"Extract a slice of the LD matrix based on the provided ancestry and stop and end indices.\n\n        - The half matrix is completed into a full square.\n        - The returned indices are adjusted based on the start index.\n\n        Args:\n            gnomad_ancestry (str): LD population label eg. `nfe`\n            start_index (int): start index of the slice\n            end_index (int): end index of the slice\n\n        Returns:\n            DataFrame: square slice of the LD matrix melted as dataframe with idx_i, idx_j and r columns\n        \"\"\"\n        # Extracting block matrix slice:\n        half_matrix = BlockMatrix.read(\n            self.ld_matrix_template.format(POP=gnomad_ancestry)\n        ).filter(range(start_index, end_index + 1), range(start_index, end_index + 1))\n\n        # Return converted Dataframe:\n        return (\n            (half_matrix + half_matrix.T)\n            .entries()\n            .to_spark()\n            .select(\n                (f.col(\"i\") + start_index).alias(\"idx_i\"),\n                (f.col(\"j\") + start_index).alias(\"idx_j\"),\n                f.when(f.col(\"i\") == f.col(\"j\"), f.col(\"entry\") / 2)\n                .otherwise(f.col(\"entry\"))\n                .alias(\"r\"),\n            )\n        )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_ld/#otg.datasource.gnomad.ld.GnomADLDMatrix.as_ld_index","title":"<code>as_ld_index(min_r2: float) -&gt; LDIndex</code>","text":"<p>Create LDIndex dataset aggregating the LD information across a set of populations.</p> <p>The basic steps to generate the LDIndex are:</p> <ol> <li>Convert LD matrix to a Spark DataFrame.</li> <li>Resolve the matrix indices to variant IDs by lifting over the coordinates to GRCh38.</li> <li>Aggregate the LD information across populations.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>min_r2</code> <code>float</code> <p>Minimum r2 value to keep in the table</p> required <p>Returns:</p> Name Type Description <code>LDIndex</code> <code>LDIndex</code> <p>LDIndex dataset</p> Source code in <code>src/otg/datasource/gnomad/ld.py</code> <pre><code>def as_ld_index(\n    self: GnomADLDMatrix,\n    min_r2: float,\n) -&gt; LDIndex:\n    \"\"\"Create LDIndex dataset aggregating the LD information across a set of populations.\n\n    **The basic steps to generate the LDIndex are:**\n\n    1. Convert LD matrix to a Spark DataFrame.\n    2. Resolve the matrix indices to variant IDs by lifting over the coordinates to GRCh38.\n    3. Aggregate the LD information across populations.\n\n    Args:\n        min_r2 (float): Minimum r2 value to keep in the table\n\n    Returns:\n        LDIndex: LDIndex dataset\n    \"\"\"\n    ld_indices_unaggregated = []\n    for pop in self.ld_populations:\n        try:\n            ld_matrix_path = self.ld_matrix_template.format(POP=pop)\n            ld_index_raw_path = self.ld_index_raw_template.format(POP=pop)\n            pop_ld_index = self._create_ldindex_for_population(\n                pop,\n                ld_matrix_path,\n                ld_index_raw_path.format(pop),\n                self.grch37_to_grch38_chain_path,\n                min_r2,\n            )\n            ld_indices_unaggregated.append(pop_ld_index)\n        except Exception as e:\n            print(f\"Failed to create LDIndex for population {pop}: {e}\")\n            sys.exit(1)\n\n    ld_index_unaggregated = (\n        GnomADLDMatrix._transpose_ld_matrix(\n            reduce(lambda df1, df2: df1.unionByName(df2), ld_indices_unaggregated)\n        )\n        .withColumnRenamed(\"variantId_i\", \"variantId\")\n        .withColumnRenamed(\"variantId_j\", \"tagVariantId\")\n    )\n    return LDIndex(\n        _df=self._aggregate_ld_index_across_populations(ld_index_unaggregated),\n        _schema=LDIndex.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_ld/#otg.datasource.gnomad.ld.GnomADLDMatrix.get_ld_matrix_slice","title":"<code>get_ld_matrix_slice(gnomad_ancestry: str, start_index: int, end_index: int) -&gt; DataFrame</code>","text":"<p>Extract a slice of the LD matrix based on the provided ancestry and stop and end indices.</p> <ul> <li>The half matrix is completed into a full square.</li> <li>The returned indices are adjusted based on the start index.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>gnomad_ancestry</code> <code>str</code> <p>LD population label eg. <code>nfe</code></p> required <code>start_index</code> <code>int</code> <p>start index of the slice</p> required <code>end_index</code> <code>int</code> <p>end index of the slice</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>square slice of the LD matrix melted as dataframe with idx_i, idx_j and r columns</p> Source code in <code>src/otg/datasource/gnomad/ld.py</code> <pre><code>def get_ld_matrix_slice(\n    self: GnomADLDMatrix,\n    gnomad_ancestry: str,\n    start_index: int,\n    end_index: int,\n) -&gt; DataFrame:\n    \"\"\"Extract a slice of the LD matrix based on the provided ancestry and stop and end indices.\n\n    - The half matrix is completed into a full square.\n    - The returned indices are adjusted based on the start index.\n\n    Args:\n        gnomad_ancestry (str): LD population label eg. `nfe`\n        start_index (int): start index of the slice\n        end_index (int): end index of the slice\n\n    Returns:\n        DataFrame: square slice of the LD matrix melted as dataframe with idx_i, idx_j and r columns\n    \"\"\"\n    # Extracting block matrix slice:\n    half_matrix = BlockMatrix.read(\n        self.ld_matrix_template.format(POP=gnomad_ancestry)\n    ).filter(range(start_index, end_index + 1), range(start_index, end_index + 1))\n\n    # Return converted Dataframe:\n    return (\n        (half_matrix + half_matrix.T)\n        .entries()\n        .to_spark()\n        .select(\n            (f.col(\"i\") + start_index).alias(\"idx_i\"),\n            (f.col(\"j\") + start_index).alias(\"idx_j\"),\n            f.when(f.col(\"i\") == f.col(\"j\"), f.col(\"entry\") / 2)\n            .otherwise(f.col(\"entry\"))\n            .alias(\"r\"),\n        )\n    )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_ld/#otg.datasource.gnomad.ld.GnomADLDMatrix.get_ld_variants","title":"<code>get_ld_variants(gnomad_ancestry: str, chromosome: str, start: int, end: int) -&gt; DataFrame | None</code>","text":"<p>Return melted LD table with resolved variant id based on ancestry and genomic location.</p> <p>Parameters:</p> Name Type Description Default <code>gnomad_ancestry</code> <code>str</code> <p>GnomAD major ancestry label eg. <code>nfe</code></p> required <code>chromosome</code> <code>str</code> <p>chromosome label</p> required <code>start</code> <code>int</code> <p>window upper bound</p> required <code>end</code> <code>int</code> <p>window lower bound</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>DataFrame | None: LD table with resolved variant id based on ancestry and genomic location</p> Source code in <code>src/otg/datasource/gnomad/ld.py</code> <pre><code>def get_ld_variants(\n    self: GnomADLDMatrix,\n    gnomad_ancestry: str,\n    chromosome: str,\n    start: int,\n    end: int,\n) -&gt; DataFrame | None:\n    \"\"\"Return melted LD table with resolved variant id based on ancestry and genomic location.\n\n    Args:\n        gnomad_ancestry (str): GnomAD major ancestry label eg. `nfe`\n        chromosome (str): chromosome label\n        start (int): window upper bound\n        end (int): window lower bound\n\n    Returns:\n        DataFrame | None: LD table with resolved variant id based on ancestry and genomic location\n    \"\"\"\n    # Extracting locus:\n    ld_index_df = (\n        self._process_variant_indices(\n            hl.read_table(self.ld_index_raw_template.format(POP=gnomad_ancestry)),\n            self.grch37_to_grch38_chain_path,\n        )\n        .filter(\n            (f.col(\"chromosome\") == chromosome)\n            &amp; (f.col(\"position\") &gt;= start)\n            &amp; (f.col(\"position\") &lt;= end)\n        )\n        .select(\"chromosome\", \"position\", \"variantId\", \"idx\")\n        .persist()\n    )\n\n    if ld_index_df.limit(1).count() == 0:\n        # If the returned slice from the ld index is empty, return None\n        return None\n\n    # Compute start and end indices\n    start_index = get_value_from_row(\n        get_top_ranked_in_window(\n            ld_index_df, Window.partitionBy().orderBy(f.col(\"position\").asc())\n        ).collect()[0],\n        \"idx\",\n    )\n    end_index = get_value_from_row(\n        get_top_ranked_in_window(\n            ld_index_df, Window.partitionBy().orderBy(f.col(\"position\").desc())\n        ).collect()[0],\n        \"idx\",\n    )\n\n    return self._extract_square_matrix(\n        ld_index_df, gnomad_ancestry, start_index, end_index\n    )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_variants/","title":"Variants","text":""},{"location":"python_api/datasource/gnomad/gnomad_variants/#otg.datasource.gnomad.variants.GnomADVariants","title":"<code>otg.datasource.gnomad.variants.GnomADVariants</code>  <code>dataclass</code>","text":"<p>GnomAD variants included in the GnomAD genomes dataset.</p> <p>Attributes:</p> Name Type Description <code>gnomad_genomes</code> <code>str</code> <p>Path to gnomAD genomes hail table. Defaults to gnomAD's 3.1.2 release.</p> <code>chain_hail_38_37</code> <code>str</code> <p>Path to GRCh38 to GRCh37 chain file. Defaults to Hail's chain file.</p> <code>populations</code> <code>list[str]</code> <p>List of populations to include. Defaults to all populations.</p> Source code in <code>src/otg/datasource/gnomad/variants.py</code> <pre><code>@dataclass\nclass GnomADVariants:\n    \"\"\"GnomAD variants included in the GnomAD genomes dataset.\n\n    Attributes:\n        gnomad_genomes (str): Path to gnomAD genomes hail table. Defaults to gnomAD's 3.1.2 release.\n        chain_hail_38_37 (str): Path to GRCh38 to GRCh37 chain file. Defaults to Hail's chain file.\n        populations (list[str]): List of populations to include. Defaults to all populations.\n    \"\"\"\n\n    gnomad_genomes: str = \"gs://gcp-public-data--gnomad/release/3.1.2/ht/genomes/gnomad.genomes.v3.1.2.sites.ht\"\n    chain_hail_38_37: str = \"gs://hail-common/references/grch38_to_grch37.over.chain.gz\"\n    populations: list[str] = field(\n        default_factory=lambda: [\n            \"afr\",  # African-American\n            \"amr\",  # American Admixed/Latino\n            \"ami\",  # Amish ancestry\n            \"asj\",  # Ashkenazi Jewish\n            \"eas\",  # East Asian\n            \"fin\",  # Finnish\n            \"nfe\",  # Non-Finnish European\n            \"mid\",  # Middle Eastern\n            \"sas\",  # South Asian\n            \"oth\",  # Other\n        ]\n    )\n\n    @staticmethod\n    def _convert_gnomad_position_to_ensembl_hail(\n        position: Int32Expression,\n        reference: StringExpression,\n        alternate: StringExpression,\n    ) -&gt; Int32Expression:\n        \"\"\"Convert GnomAD variant position to Ensembl variant position in hail table.\n\n        For indels (the reference or alternate allele is longer than 1), then adding 1 to the position, for SNPs, the position is unchanged.\n        More info about the problem: https://www.biostars.org/p/84686/\n\n        Args:\n            position (Int32Expression): Position of the variant in the GnomAD genome.\n            reference (StringExpression): The reference allele.\n            alternate (StringExpression): The alternate allele\n\n        Returns:\n            Int32Expression: The position of the variant according to Ensembl genome.\n        \"\"\"\n        return hl.if_else(\n            (reference.length() &gt; 1) | (alternate.length() &gt; 1), position + 1, position\n        )\n\n    def as_variant_annotation(self: GnomADVariants) -&gt; VariantAnnotation:\n        \"\"\"Generate variant annotation dataset from gnomAD.\n\n        Some relevant modifications to the original dataset are:\n\n        1. The transcript consequences features provided by VEP are filtered to only refer to the Ensembl canonical transcript.\n        2. Genome coordinates are liftovered from GRCh38 to GRCh37 to keep as annotation.\n        3. Field names are converted to camel case to follow the convention.\n\n        Returns:\n            VariantAnnotation: Variant annotation dataset\n        \"\"\"\n        # Load variants dataset\n        ht = hl.read_table(\n            self.gnomad_genomes,\n            _load_refs=False,\n        )\n\n        # Liftover\n        grch37 = hl.get_reference(\"GRCh37\")\n        grch38 = hl.get_reference(\"GRCh38\")\n        grch38.add_liftover(self.chain_hail_38_37, grch37)\n\n        # Drop non biallelic variants\n        ht = ht.filter(ht.alleles.length() == 2)\n        # Liftover\n        ht = ht.annotate(locus_GRCh37=hl.liftover(ht.locus, \"GRCh37\"))\n        # Select relevant fields and nested records to create class\n        return VariantAnnotation(\n            _df=(\n                ht.select(\n                    gnomad3VariantId=hl.str(\"-\").join(\n                        [\n                            ht.locus.contig.replace(\"chr\", \"\"),\n                            hl.str(ht.locus.position),\n                            ht.alleles[0],\n                            ht.alleles[1],\n                        ]\n                    ),\n                    chromosome=ht.locus.contig.replace(\"chr\", \"\"),\n                    position=GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                        ht.locus.position, ht.alleles[0], ht.alleles[1]\n                    ),\n                    variantId=hl.str(\"_\").join(\n                        [\n                            ht.locus.contig.replace(\"chr\", \"\"),\n                            hl.str(\n                                GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                                    ht.locus.position, ht.alleles[0], ht.alleles[1]\n                                )\n                            ),\n                            ht.alleles[0],\n                            ht.alleles[1],\n                        ]\n                    ),\n                    chromosomeB37=ht.locus_GRCh37.contig.replace(\"chr\", \"\"),\n                    positionB37=ht.locus_GRCh37.position,\n                    referenceAllele=ht.alleles[0],\n                    alternateAllele=ht.alleles[1],\n                    rsIds=ht.rsid,\n                    alleleType=ht.allele_info.allele_type,\n                    cadd=hl.struct(\n                        phred=ht.cadd.phred,\n                        raw=ht.cadd.raw_score,\n                    ),\n                    alleleFrequencies=hl.set(\n                        [f\"{pop}-adj\" for pop in self.populations]\n                    ).map(\n                        lambda p: hl.struct(\n                            populationName=p,\n                            alleleFrequency=ht.freq[ht.globals.freq_index_dict[p]].AF,\n                        )\n                    ),\n                    vep=hl.struct(\n                        mostSevereConsequence=ht.vep.most_severe_consequence,\n                        transcriptConsequences=hl.map(\n                            lambda x: hl.struct(\n                                aminoAcids=x.amino_acids,\n                                consequenceTerms=x.consequence_terms,\n                                geneId=x.gene_id,\n                                lof=x.lof,\n                                polyphenScore=x.polyphen_score,\n                                polyphenPrediction=x.polyphen_prediction,\n                                siftScore=x.sift_score,\n                                siftPrediction=x.sift_prediction,\n                            ),\n                            # Only keeping canonical transcripts\n                            ht.vep.transcript_consequences.filter(\n                                lambda x: (x.canonical == 1)\n                                &amp; (x.gene_symbol_source == \"HGNC\")\n                            ),\n                        ),\n                    ),\n                )\n                .key_by(\"chromosome\", \"position\")\n                .drop(\"locus\", \"alleles\")\n                .select_globals()\n                .to_spark(flatten=False)\n            ),\n            _schema=VariantAnnotation.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_variants/#otg.datasource.gnomad.variants.GnomADVariants.as_variant_annotation","title":"<code>as_variant_annotation() -&gt; VariantAnnotation</code>","text":"<p>Generate variant annotation dataset from gnomAD.</p> <p>Some relevant modifications to the original dataset are:</p> <ol> <li>The transcript consequences features provided by VEP are filtered to only refer to the Ensembl canonical transcript.</li> <li>Genome coordinates are liftovered from GRCh38 to GRCh37 to keep as annotation.</li> <li>Field names are converted to camel case to follow the convention.</li> </ol> <p>Returns:</p> Name Type Description <code>VariantAnnotation</code> <code>VariantAnnotation</code> <p>Variant annotation dataset</p> Source code in <code>src/otg/datasource/gnomad/variants.py</code> <pre><code>def as_variant_annotation(self: GnomADVariants) -&gt; VariantAnnotation:\n    \"\"\"Generate variant annotation dataset from gnomAD.\n\n    Some relevant modifications to the original dataset are:\n\n    1. The transcript consequences features provided by VEP are filtered to only refer to the Ensembl canonical transcript.\n    2. Genome coordinates are liftovered from GRCh38 to GRCh37 to keep as annotation.\n    3. Field names are converted to camel case to follow the convention.\n\n    Returns:\n        VariantAnnotation: Variant annotation dataset\n    \"\"\"\n    # Load variants dataset\n    ht = hl.read_table(\n        self.gnomad_genomes,\n        _load_refs=False,\n    )\n\n    # Liftover\n    grch37 = hl.get_reference(\"GRCh37\")\n    grch38 = hl.get_reference(\"GRCh38\")\n    grch38.add_liftover(self.chain_hail_38_37, grch37)\n\n    # Drop non biallelic variants\n    ht = ht.filter(ht.alleles.length() == 2)\n    # Liftover\n    ht = ht.annotate(locus_GRCh37=hl.liftover(ht.locus, \"GRCh37\"))\n    # Select relevant fields and nested records to create class\n    return VariantAnnotation(\n        _df=(\n            ht.select(\n                gnomad3VariantId=hl.str(\"-\").join(\n                    [\n                        ht.locus.contig.replace(\"chr\", \"\"),\n                        hl.str(ht.locus.position),\n                        ht.alleles[0],\n                        ht.alleles[1],\n                    ]\n                ),\n                chromosome=ht.locus.contig.replace(\"chr\", \"\"),\n                position=GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                    ht.locus.position, ht.alleles[0], ht.alleles[1]\n                ),\n                variantId=hl.str(\"_\").join(\n                    [\n                        ht.locus.contig.replace(\"chr\", \"\"),\n                        hl.str(\n                            GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                                ht.locus.position, ht.alleles[0], ht.alleles[1]\n                            )\n                        ),\n                        ht.alleles[0],\n                        ht.alleles[1],\n                    ]\n                ),\n                chromosomeB37=ht.locus_GRCh37.contig.replace(\"chr\", \"\"),\n                positionB37=ht.locus_GRCh37.position,\n                referenceAllele=ht.alleles[0],\n                alternateAllele=ht.alleles[1],\n                rsIds=ht.rsid,\n                alleleType=ht.allele_info.allele_type,\n                cadd=hl.struct(\n                    phred=ht.cadd.phred,\n                    raw=ht.cadd.raw_score,\n                ),\n                alleleFrequencies=hl.set(\n                    [f\"{pop}-adj\" for pop in self.populations]\n                ).map(\n                    lambda p: hl.struct(\n                        populationName=p,\n                        alleleFrequency=ht.freq[ht.globals.freq_index_dict[p]].AF,\n                    )\n                ),\n                vep=hl.struct(\n                    mostSevereConsequence=ht.vep.most_severe_consequence,\n                    transcriptConsequences=hl.map(\n                        lambda x: hl.struct(\n                            aminoAcids=x.amino_acids,\n                            consequenceTerms=x.consequence_terms,\n                            geneId=x.gene_id,\n                            lof=x.lof,\n                            polyphenScore=x.polyphen_score,\n                            polyphenPrediction=x.polyphen_prediction,\n                            siftScore=x.sift_score,\n                            siftPrediction=x.sift_prediction,\n                        ),\n                        # Only keeping canonical transcripts\n                        ht.vep.transcript_consequences.filter(\n                            lambda x: (x.canonical == 1)\n                            &amp; (x.gene_symbol_source == \"HGNC\")\n                        ),\n                    ),\n                ),\n            )\n            .key_by(\"chromosome\", \"position\")\n            .drop(\"locus\", \"alleles\")\n            .select_globals()\n            .to_spark(flatten=False)\n        ),\n        _schema=VariantAnnotation.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/_gwas_catalog/","title":"GWAS Catalog","text":"GWAS Catalog"},{"location":"python_api/datasource/gwas_catalog/associations/","title":"Associations","text":""},{"location":"python_api/datasource/gwas_catalog/associations/#otg.datasource.gwas_catalog.associations.GWASCatalogAssociations","title":"<code>otg.datasource.gwas_catalog.associations.GWASCatalogAssociations</code>  <code>dataclass</code>","text":"<p>             Bases: <code>StudyLocus</code></p> <p>Study-locus dataset derived from GWAS Catalog.</p> Source code in <code>src/otg/datasource/gwas_catalog/associations.py</code> <pre><code>@dataclass\nclass GWASCatalogAssociations(StudyLocus):\n    \"\"\"Study-locus dataset derived from GWAS Catalog.\"\"\"\n\n    @staticmethod\n    def _parse_pvalue(pvalue: Column) -&gt; tuple[Column, Column]:\n        \"\"\"Parse p-value column.\n\n        Args:\n            pvalue (Column): p-value [string]\n\n        Returns:\n            tuple[Column, Column]: p-value mantissa and exponent\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [(\"1.0\"), (\"0.5\"), (\"1E-20\"), (\"3E-3\"), (\"1E-1000\")]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StringType())\n            &gt;&gt;&gt; df.select('value',*GWASCatalogAssociations._parse_pvalue(f.col('value'))).show()\n            +-------+--------------+--------------+\n            |  value|pValueMantissa|pValueExponent|\n            +-------+--------------+--------------+\n            |    1.0|           1.0|             1|\n            |    0.5|           0.5|             1|\n            |  1E-20|           1.0|           -20|\n            |   3E-3|           3.0|            -3|\n            |1E-1000|           1.0|         -1000|\n            +-------+--------------+--------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        split = f.split(pvalue, \"E\")\n        return split.getItem(0).cast(\"float\").alias(\"pValueMantissa\"), f.coalesce(\n            split.getItem(1).cast(\"integer\"), f.lit(1)\n        ).alias(\"pValueExponent\")\n\n    @staticmethod\n    def _normalise_pvaluetext(p_value_text: Column) -&gt; Column:\n        \"\"\"Normalised p-value text column to a standardised format.\n\n        For cases where there is no mapping, the value is set to null.\n\n        Args:\n            p_value_text (Column): `pValueText` column from GWASCatalog\n\n        Returns:\n            Column: Array column after using GWAS Catalog mappings. There might be multiple mappings for a single p-value text.\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [(\"European Ancestry\"), (\"African ancestry\"), (\"Alzheimer\u2019s Disease\"), (\"(progression)\"), (\"\"), (None)]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StringType())\n            &gt;&gt;&gt; df.withColumn('normalised', GWASCatalogAssociations._normalise_pvaluetext(f.col('value'))).show()\n            +-------------------+----------+\n            |              value|normalised|\n            +-------------------+----------+\n            |  European Ancestry|      [EA]|\n            |   African ancestry|      [AA]|\n            |Alzheimer\u2019s Disease|      [AD]|\n            |      (progression)|      null|\n            |                   |      null|\n            |               null|      null|\n            +-------------------+----------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # GWAS Catalog to p-value mapping\n        json_dict = json.loads(\n            pkg_resources.read_text(data, \"gwas_pValueText_map.json\", encoding=\"utf-8\")\n        )\n        map_expr = f.create_map(*[f.lit(x) for x in chain(*json_dict.items())])\n\n        splitted_col = f.split(f.regexp_replace(p_value_text, r\"[\\(\\)]\", \"\"), \",\")\n        mapped_col = f.transform(splitted_col, lambda x: map_expr[x])\n        return f.when(f.forall(mapped_col, lambda x: x.isNull()), None).otherwise(\n            mapped_col\n        )\n\n    @staticmethod\n    def _normalise_risk_allele(risk_allele: Column) -&gt; Column:\n        \"\"\"Normalised risk allele column to a standardised format.\n\n        If multiple risk alleles are present, the first one is returned.\n\n        Args:\n            risk_allele (Column): `riskAllele` column from GWASCatalog\n\n        Returns:\n            Column: mapped using GWAS Catalog mapping\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [(\"rs1234-A-G\"), (\"rs1234-A\"), (\"rs1234-A; rs1235-G\")]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StringType())\n            &gt;&gt;&gt; df.withColumn('normalised', GWASCatalogAssociations._normalise_risk_allele(f.col('value'))).show()\n            +------------------+----------+\n            |             value|normalised|\n            +------------------+----------+\n            |        rs1234-A-G|         A|\n            |          rs1234-A|         A|\n            |rs1234-A; rs1235-G|         A|\n            +------------------+----------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # GWAS Catalog to risk allele mapping\n        return f.split(f.split(risk_allele, \"; \").getItem(0), \"-\").getItem(1)\n\n    @staticmethod\n    def _collect_rsids(\n        snp_id: Column, snp_id_current: Column, risk_allele: Column\n    ) -&gt; Column:\n        \"\"\"It takes three columns, and returns an array of distinct values from those columns.\n\n        Args:\n            snp_id (Column): The original snp id from the GWAS catalog.\n            snp_id_current (Column): The current snp id field is just a number at the moment (stored as a string). Adding 'rs' prefix if looks good.\n            risk_allele (Column): The risk allele for the SNP.\n\n        Returns:\n            Column: An array of distinct values.\n        \"\"\"\n        # The current snp id field is just a number at the moment (stored as a string). Adding 'rs' prefix if looks good.\n        snp_id_current = f.when(\n            snp_id_current.rlike(\"^[0-9]*$\"),\n            f.format_string(\"rs%s\", snp_id_current),\n        )\n        # Cleaning risk allele:\n        risk_allele = f.split(risk_allele, \"-\").getItem(0)\n\n        # Collecting all values:\n        return f.array_distinct(f.array(snp_id, snp_id_current, risk_allele))\n\n    @staticmethod\n    def _map_to_variant_annotation_variants(\n        gwas_associations: DataFrame, variant_annotation: VariantAnnotation\n    ) -&gt; DataFrame:\n        \"\"\"Add variant metadata in associations.\n\n        Args:\n            gwas_associations (DataFrame): raw GWAS Catalog associations\n            variant_annotation (VariantAnnotation): variant annotation dataset\n\n        Returns:\n            DataFrame: GWAS Catalog associations data including `variantId`, `referenceAllele`,\n            `alternateAllele`, `chromosome`, `position` with variant metadata\n        \"\"\"\n        # Subset of GWAS Catalog associations required for resolving variant IDs:\n        gwas_associations_subset = gwas_associations.select(\n            \"studyLocusId\",\n            f.col(\"CHR_ID\").alias(\"chromosome\"),\n            f.col(\"CHR_POS\").cast(IntegerType()).alias(\"position\"),\n            # List of all SNPs associated with the variant\n            GWASCatalogAssociations._collect_rsids(\n                f.split(f.col(\"SNPS\"), \"; \").getItem(0),\n                f.col(\"SNP_ID_CURRENT\"),\n                f.split(f.col(\"STRONGEST SNP-RISK ALLELE\"), \"; \").getItem(0),\n            ).alias(\"rsIdsGwasCatalog\"),\n            GWASCatalogAssociations._normalise_risk_allele(\n                f.col(\"STRONGEST SNP-RISK ALLELE\")\n            ).alias(\"riskAllele\"),\n        )\n\n        # Subset of variant annotation required for GWAS Catalog annotations:\n        va_subset = variant_annotation.df.select(\n            \"variantId\",\n            \"chromosome\",\n            \"position\",\n            f.col(\"rsIds\").alias(\"rsIdsGnomad\"),\n            \"referenceAllele\",\n            \"alternateAllele\",\n            \"alleleFrequencies\",\n            variant_annotation.max_maf().alias(\"maxMaf\"),\n        ).join(\n            f.broadcast(\n                gwas_associations_subset.select(\"chromosome\", \"position\").distinct()\n            ),\n            on=[\"chromosome\", \"position\"],\n            how=\"inner\",\n        )\n\n        # Semi-resolved ids (still contains duplicates when conclusion was not possible to make\n        # based on rsIds or allele concordance)\n        filtered_associations = (\n            gwas_associations_subset.join(\n                f.broadcast(va_subset),\n                on=[\"chromosome\", \"position\"],\n                how=\"left\",\n            )\n            .withColumn(\n                \"rsIdFilter\",\n                GWASCatalogAssociations._flag_mappings_to_retain(\n                    f.col(\"studyLocusId\"),\n                    GWASCatalogAssociations._compare_rsids(\n                        f.col(\"rsIdsGnomad\"), f.col(\"rsIdsGwasCatalog\")\n                    ),\n                ),\n            )\n            .withColumn(\n                \"concordanceFilter\",\n                GWASCatalogAssociations._flag_mappings_to_retain(\n                    f.col(\"studyLocusId\"),\n                    GWASCatalogAssociations._check_concordance(\n                        f.col(\"riskAllele\"),\n                        f.col(\"referenceAllele\"),\n                        f.col(\"alternateAllele\"),\n                    ),\n                ),\n            )\n            .filter(\n                # Filter out rows where GWAS Catalog rsId does not match with GnomAD rsId,\n                # but there is corresponding variant for the same association\n                f.col(\"rsIdFilter\")\n                # or filter out rows where GWAS Catalog alleles are not concordant with GnomAD alleles,\n                # but there is corresponding variant for the same association\n                | f.col(\"concordanceFilter\")\n            )\n        )\n\n        # Keep only highest maxMaf variant per studyLocusId\n        fully_mapped_associations = get_record_with_maximum_value(\n            filtered_associations, grouping_col=\"studyLocusId\", sorting_col=\"maxMaf\"\n        ).select(\n            \"studyLocusId\",\n            \"variantId\",\n            \"referenceAllele\",\n            \"alternateAllele\",\n            \"chromosome\",\n            \"position\",\n        )\n\n        return gwas_associations.join(\n            fully_mapped_associations, on=\"studyLocusId\", how=\"left\"\n        )\n\n    @staticmethod\n    def _compare_rsids(gnomad: Column, gwas: Column) -&gt; Column:\n        \"\"\"If the intersection of the two arrays is greater than 0, return True, otherwise return False.\n\n        Args:\n            gnomad (Column): rsids from gnomad\n            gwas (Column): rsids from the GWAS Catalog\n\n        Returns:\n            Column: A boolean column that is true if the GnomAD rsIDs can be found in the GWAS rsIDs.\n\n        Examples:\n            &gt;&gt;&gt; d = [\n            ...    (1, [\"rs123\", \"rs523\"], [\"rs123\"]),\n            ...    (2, [], [\"rs123\"]),\n            ...    (3, [\"rs123\", \"rs523\"], []),\n            ...    (4, [], []),\n            ... ]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, ['associationId', 'gnomad', 'gwas'])\n            &gt;&gt;&gt; df.withColumn(\"rsid_matches\", GWASCatalogAssociations._compare_rsids(f.col(\"gnomad\"),f.col('gwas'))).show()\n            +-------------+--------------+-------+------------+\n            |associationId|        gnomad|   gwas|rsid_matches|\n            +-------------+--------------+-------+------------+\n            |            1|[rs123, rs523]|[rs123]|        true|\n            |            2|            []|[rs123]|       false|\n            |            3|[rs123, rs523]|     []|       false|\n            |            4|            []|     []|       false|\n            +-------------+--------------+-------+------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return f.when(f.size(f.array_intersect(gnomad, gwas)) &gt; 0, True).otherwise(\n            False\n        )\n\n    @staticmethod\n    def _flag_mappings_to_retain(\n        association_id: Column, filter_column: Column\n    ) -&gt; Column:\n        \"\"\"Flagging mappings to drop for each association.\n\n        Some associations have multiple mappings. Some has matching rsId others don't. We only\n        want to drop the non-matching mappings, when a matching is available for the given association.\n        This logic can be generalised for other measures eg. allele concordance.\n\n        Args:\n            association_id (Column): association identifier column\n            filter_column (Column): boolean col indicating to keep a mapping\n\n        Returns:\n            Column: A column with a boolean value.\n\n        Examples:\n        &gt;&gt;&gt; d = [\n        ...    (1, False),\n        ...    (1, False),\n        ...    (2, False),\n        ...    (2, True),\n        ...    (3, True),\n        ...    (3, True),\n        ... ]\n        &gt;&gt;&gt; df = spark.createDataFrame(d, ['associationId', 'filter'])\n        &gt;&gt;&gt; df.withColumn(\"isConcordant\", GWASCatalogAssociations._flag_mappings_to_retain(f.col(\"associationId\"),f.col('filter'))).show()\n        +-------------+------+------------+\n        |associationId|filter|isConcordant|\n        +-------------+------+------------+\n        |            1| false|        true|\n        |            1| false|        true|\n        |            2| false|       false|\n        |            2|  true|        true|\n        |            3|  true|        true|\n        |            3|  true|        true|\n        +-------------+------+------------+\n        &lt;BLANKLINE&gt;\n\n        \"\"\"\n        w = Window.partitionBy(association_id)\n\n        # Generating a boolean column informing if the filter column contains true anywhere for the association:\n        aggregated_filter = f.when(\n            f.array_contains(f.collect_set(filter_column).over(w), True), True\n        ).otherwise(False)\n\n        # Generate a filter column:\n        return f.when(aggregated_filter &amp; (~filter_column), False).otherwise(True)\n\n    @staticmethod\n    def _check_concordance(\n        risk_allele: Column, reference_allele: Column, alternate_allele: Column\n    ) -&gt; Column:\n        \"\"\"A function to check if the risk allele is concordant with the alt or ref allele.\n\n        If the risk allele is the same as the reference or alternate allele, or if the reverse complement of\n        the risk allele is the same as the reference or alternate allele, then the allele is concordant.\n        If no mapping is available (ref/alt is null), the function returns True.\n\n        Args:\n            risk_allele (Column): The allele that is associated with the risk of the disease.\n            reference_allele (Column): The reference allele from the GWAS catalog\n            alternate_allele (Column): The alternate allele of the variant.\n\n        Returns:\n            Column: A boolean column that is True if the risk allele is the same as the reference or alternate allele,\n            or if the reverse complement of the risk allele is the same as the reference or alternate allele.\n\n        Examples:\n            &gt;&gt;&gt; d = [\n            ...     ('A', 'A', 'G'),\n            ...     ('A', 'T', 'G'),\n            ...     ('A', 'C', 'G'),\n            ...     ('A', 'A', '?'),\n            ...     (None, None, 'A'),\n            ... ]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, ['riskAllele', 'referenceAllele', 'alternateAllele'])\n            &gt;&gt;&gt; df.withColumn(\"isConcordant\", GWASCatalogAssociations._check_concordance(f.col(\"riskAllele\"),f.col('referenceAllele'), f.col('alternateAllele'))).show()\n            +----------+---------------+---------------+------------+\n            |riskAllele|referenceAllele|alternateAllele|isConcordant|\n            +----------+---------------+---------------+------------+\n            |         A|              A|              G|        true|\n            |         A|              T|              G|        true|\n            |         A|              C|              G|       false|\n            |         A|              A|              ?|        true|\n            |      null|           null|              A|        true|\n            +----------+---------------+---------------+------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # Calculating the reverse complement of the risk allele:\n        risk_allele_reverse_complement = f.when(\n            risk_allele.rlike(r\"^[ACTG]+$\"),\n            f.reverse(f.translate(risk_allele, \"ACTG\", \"TGAC\")),\n        ).otherwise(risk_allele)\n\n        # OK, is the risk allele or the reverse complent is the same as the mapped alleles:\n        return (\n            f.when(\n                (risk_allele == reference_allele) | (risk_allele == alternate_allele),\n                True,\n            )\n            # If risk allele is found on the negative strand:\n            .when(\n                (risk_allele_reverse_complement == reference_allele)\n                | (risk_allele_reverse_complement == alternate_allele),\n                True,\n            )\n            # If risk allele is ambiguous, still accepted: &lt; This condition could be reconsidered\n            .when(risk_allele == \"?\", True)\n            # If the association could not be mapped we keep it:\n            .when(reference_allele.isNull(), True)\n            # Allele is discordant:\n            .otherwise(False)\n        )\n\n    @staticmethod\n    def _get_reverse_complement(allele_col: Column) -&gt; Column:\n        \"\"\"A function to return the reverse complement of an allele column.\n\n        It takes a string and returns the reverse complement of that string if it's a DNA sequence,\n        otherwise it returns the original string. Assumes alleles in upper case.\n\n        Args:\n            allele_col (Column): The column containing the allele to reverse complement.\n\n        Returns:\n            Column: A column that is the reverse complement of the allele column.\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"allele\": 'A'}, {\"allele\": 'T'},{\"allele\": 'G'}, {\"allele\": 'C'},{\"allele\": 'AC'}, {\"allele\": 'GTaatc'},{\"allele\": '?'}, {\"allele\": None}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"revcom_allele\", GWASCatalogAssociations._get_reverse_complement(f.col(\"allele\"))).show()\n            +------+-------------+\n            |allele|revcom_allele|\n            +------+-------------+\n            |     A|            T|\n            |     T|            A|\n            |     G|            C|\n            |     C|            G|\n            |    AC|           GT|\n            |GTaatc|       GATTAC|\n            |     ?|            ?|\n            |  null|         null|\n            +------+-------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        allele_col = f.upper(allele_col)\n        return f.when(\n            allele_col.rlike(\"[ACTG]+\"),\n            f.reverse(f.translate(allele_col, \"ACTG\", \"TGAC\")),\n        ).otherwise(allele_col)\n\n    @staticmethod\n    def _effect_needs_harmonisation(\n        risk_allele: Column, reference_allele: Column\n    ) -&gt; Column:\n        \"\"\"A function to check if the effect allele needs to be harmonised.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Effect allele column\n\n        Returns:\n            Column: A boolean column indicating if the effect allele needs to be harmonised.\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"risk\": 'A', \"reference\": 'A'}, {\"risk\": 'A', \"reference\": 'T'}, {\"risk\": 'AT', \"reference\": 'TA'}, {\"risk\": 'AT', \"reference\": 'AT'}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"needs_harmonisation\", GWASCatalogAssociations._effect_needs_harmonisation(f.col(\"risk\"), f.col(\"reference\"))).show()\n            +---------+----+-------------------+\n            |reference|risk|needs_harmonisation|\n            +---------+----+-------------------+\n            |        A|   A|               true|\n            |        T|   A|               true|\n            |       TA|  AT|              false|\n            |       AT|  AT|               true|\n            +---------+----+-------------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return (risk_allele == reference_allele) | (\n            risk_allele\n            == GWASCatalogAssociations._get_reverse_complement(reference_allele)\n        )\n\n    @staticmethod\n    def _are_alleles_palindromic(\n        reference_allele: Column, alternate_allele: Column\n    ) -&gt; Column:\n        \"\"\"A function to check if the alleles are palindromic.\n\n        Args:\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n\n        Returns:\n            Column: A boolean column indicating if the alleles are palindromic.\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"reference\": 'A', \"alternate\": 'T'}, {\"reference\": 'AT', \"alternate\": 'AG'}, {\"reference\": 'AT', \"alternate\": 'AT'}, {\"reference\": 'CATATG', \"alternate\": 'CATATG'}, {\"reference\": '-', \"alternate\": None}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"is_palindromic\", GWASCatalogAssociations._are_alleles_palindromic(f.col(\"reference\"), f.col(\"alternate\"))).show()\n            +---------+---------+--------------+\n            |alternate|reference|is_palindromic|\n            +---------+---------+--------------+\n            |        T|        A|          true|\n            |       AG|       AT|         false|\n            |       AT|       AT|          true|\n            |   CATATG|   CATATG|          true|\n            |     null|        -|         false|\n            +---------+---------+--------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        revcomp = GWASCatalogAssociations._get_reverse_complement(alternate_allele)\n        return (\n            f.when(reference_allele == revcomp, True)\n            .when(revcomp.isNull(), False)\n            .otherwise(False)\n        )\n\n    @staticmethod\n    def _harmonise_beta(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n    ) -&gt; Column:\n        \"\"\"A function to extract the beta value from the effect size and confidence interval.\n\n        If the confidence interval contains the word \"increase\" or \"decrease\" it indicates, we are dealing with betas.\n        If it's \"increase\" and the effect size needs to be harmonized, then multiply the effect size by -1\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n\n        Returns:\n            Column: A column containing the beta value.\n        \"\"\"\n        return (\n            f.when(\n                GWASCatalogAssociations._are_alleles_palindromic(\n                    reference_allele, alternate_allele\n                ),\n                None,\n            )\n            .when(\n                (\n                    GWASCatalogAssociations._effect_needs_harmonisation(\n                        risk_allele, reference_allele\n                    )\n                    &amp; confidence_interval.contains(\"increase\")\n                )\n                | (\n                    ~GWASCatalogAssociations._effect_needs_harmonisation(\n                        risk_allele, reference_allele\n                    )\n                    &amp; confidence_interval.contains(\"decrease\")\n                ),\n                -effect_size,\n            )\n            .otherwise(effect_size)\n            .cast(DoubleType())\n        )\n\n    @staticmethod\n    def _harmonise_beta_ci(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n        p_value: Column,\n        direction: str,\n    ) -&gt; Column:\n        \"\"\"Calculating confidence intervals for beta values.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n            p_value (Column): GWAS Catalog p-value column\n            direction (str): This is the direction of the confidence interval. It can be either \"upper\" or \"lower\".\n\n        Returns:\n            Column: The upper and lower bounds of the confidence interval for the beta coefficient.\n        \"\"\"\n        zscore_95 = f.lit(1.96)\n        beta = GWASCatalogAssociations._harmonise_beta(\n            risk_allele,\n            reference_allele,\n            alternate_allele,\n            effect_size,\n            confidence_interval,\n        )\n        zscore = pvalue_to_zscore(p_value)\n        return (\n            f.when(f.lit(direction) == \"upper\", beta + f.abs(zscore_95 * beta) / zscore)\n            .when(f.lit(direction) == \"lower\", beta - f.abs(zscore_95 * beta) / zscore)\n            .otherwise(None)\n        )\n\n    @staticmethod\n    def _harmonise_odds_ratio(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n    ) -&gt; Column:\n        \"\"\"Harmonizing odds ratio.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n\n        Returns:\n            Column: A column with the odds ratio, or 1/odds_ratio if harmonization required.\n        \"\"\"\n        return (\n            f.when(\n                GWASCatalogAssociations._are_alleles_palindromic(\n                    reference_allele, alternate_allele\n                ),\n                None,\n            )\n            .when(\n                (\n                    GWASCatalogAssociations._effect_needs_harmonisation(\n                        risk_allele, reference_allele\n                    )\n                    &amp; ~confidence_interval.rlike(\"|\".join([\"decrease\", \"increase\"]))\n                ),\n                1 / effect_size,\n            )\n            .otherwise(effect_size)\n            .cast(DoubleType())\n        )\n\n    @staticmethod\n    def _harmonise_odds_ratio_ci(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n        p_value: Column,\n        direction: str,\n    ) -&gt; Column:\n        \"\"\"Calculating confidence intervals for beta values.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n            p_value (Column): GWAS Catalog p-value column\n            direction (str): This is the direction of the confidence interval. It can be either \"upper\" or \"lower\".\n\n        Returns:\n            Column: The upper and lower bounds of the 95% confidence interval for the odds ratio.\n        \"\"\"\n        zscore_95 = f.lit(1.96)\n        odds_ratio = GWASCatalogAssociations._harmonise_odds_ratio(\n            risk_allele,\n            reference_allele,\n            alternate_allele,\n            effect_size,\n            confidence_interval,\n        )\n        odds_ratio_estimate = f.log(odds_ratio)\n        zscore = pvalue_to_zscore(p_value)\n        odds_ratio_se = odds_ratio_estimate / zscore\n        return f.when(\n            f.lit(direction) == \"upper\",\n            f.exp(odds_ratio_estimate + f.abs(zscore_95 * odds_ratio_se)),\n        ).when(\n            f.lit(direction) == \"lower\",\n            f.exp(odds_ratio_estimate - f.abs(zscore_95 * odds_ratio_se)),\n        )\n\n    @staticmethod\n    def _concatenate_substudy_description(\n        association_trait: Column, pvalue_text: Column, mapped_trait_uri: Column\n    ) -&gt; Column:\n        \"\"\"Substudy description parsing. Complex string containing metadata about the substudy (e.g. QTL, specific EFO, etc.).\n\n        Args:\n            association_trait (Column): GWAS Catalog association trait column\n            pvalue_text (Column): GWAS Catalog p-value text column\n            mapped_trait_uri (Column): GWAS Catalog mapped trait URI column\n\n        Returns:\n            Column: A column with the substudy description in the shape trait|pvaluetext1_pvaluetext2|EFO1_EFO2.\n\n        Examples:\n        &gt;&gt;&gt; df = spark.createDataFrame([\n        ...    (\"Height\", \"http://www.ebi.ac.uk/efo/EFO_0000001,http://www.ebi.ac.uk/efo/EFO_0000002\", \"European Ancestry\"),\n        ...    (\"Schizophrenia\", \"http://www.ebi.ac.uk/efo/MONDO_0005090\", None)],\n        ...    [\"association_trait\", \"mapped_trait_uri\", \"pvalue_text\"]\n        ... )\n        &gt;&gt;&gt; df.withColumn('substudy_description', GWASCatalogAssociations._concatenate_substudy_description(df.association_trait, df.pvalue_text, df.mapped_trait_uri)).show(truncate=False)\n        +-----------------+-------------------------------------------------------------------------+-----------------+------------------------------------------+\n        |association_trait|mapped_trait_uri                                                         |pvalue_text      |substudy_description                      |\n        +-----------------+-------------------------------------------------------------------------+-----------------+------------------------------------------+\n        |Height           |http://www.ebi.ac.uk/efo/EFO_0000001,http://www.ebi.ac.uk/efo/EFO_0000002|European Ancestry|Height|EA|EFO_0000001/EFO_0000002         |\n        |Schizophrenia    |http://www.ebi.ac.uk/efo/MONDO_0005090                                   |null             |Schizophrenia|no_pvalue_text|MONDO_0005090|\n        +-----------------+-------------------------------------------------------------------------+-----------------+------------------------------------------+\n        &lt;BLANKLINE&gt;\n        \"\"\"\n        p_value_text = f.coalesce(\n            GWASCatalogAssociations._normalise_pvaluetext(pvalue_text),\n            f.array(f.lit(\"no_pvalue_text\")),\n        )\n        return f.concat_ws(\n            \"|\",\n            association_trait,\n            f.concat_ws(\n                \"/\",\n                p_value_text,\n            ),\n            f.concat_ws(\n                \"/\",\n                parse_efos(mapped_trait_uri),\n            ),\n        )\n\n    @staticmethod\n    def _qc_all(\n        qc: Column,\n        chromosome: Column,\n        position: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        strongest_snp_risk_allele: Column,\n        p_value_mantissa: Column,\n        p_value_exponent: Column,\n        p_value_cutoff: float,\n    ) -&gt; Column:\n        \"\"\"Flag associations that fail any QC.\n\n        Args:\n            qc (Column): QC column\n            chromosome (Column): Chromosome column\n            position (Column): Position column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            strongest_snp_risk_allele (Column): Strongest SNP risk allele column\n            p_value_mantissa (Column): P-value mantissa column\n            p_value_exponent (Column): P-value exponent column\n            p_value_cutoff (float): P-value cutoff\n\n        Returns:\n            Column: Updated QC column with flag.\n        \"\"\"\n        qc = GWASCatalogAssociations._qc_variant_interactions(\n            qc, strongest_snp_risk_allele\n        )\n        qc = GWASCatalogAssociations._qc_subsignificant_associations(\n            qc, p_value_mantissa, p_value_exponent, p_value_cutoff\n        )\n        qc = GWASCatalogAssociations._qc_genomic_location(qc, chromosome, position)\n        qc = GWASCatalogAssociations._qc_variant_inconsistencies(\n            qc, chromosome, position, strongest_snp_risk_allele\n        )\n        qc = GWASCatalogAssociations._qc_unmapped_variants(qc, alternate_allele)\n        qc = GWASCatalogAssociations._qc_palindromic_alleles(\n            qc, reference_allele, alternate_allele\n        )\n        return qc\n\n    @staticmethod\n    def _qc_variant_interactions(\n        qc: Column, strongest_snp_risk_allele: Column\n    ) -&gt; Column:\n        \"\"\"Flag associations based on variant x variant interactions.\n\n        Args:\n            qc (Column): QC column\n            strongest_snp_risk_allele (Column): Column with the strongest SNP risk allele\n\n        Returns:\n            Column: Updated QC column with flag.\n        \"\"\"\n        return GWASCatalogAssociations._update_quality_flag(\n            qc,\n            strongest_snp_risk_allele.contains(\";\"),\n            StudyLocusQualityCheck.COMPOSITE_FLAG,\n        )\n\n    @staticmethod\n    def _qc_subsignificant_associations(\n        qc: Column,\n        p_value_mantissa: Column,\n        p_value_exponent: Column,\n        pvalue_cutoff: float,\n    ) -&gt; Column:\n        \"\"\"Flag associations below significant threshold.\n\n        Args:\n            qc (Column): QC column\n            p_value_mantissa (Column): P-value mantissa column\n            p_value_exponent (Column): P-value exponent column\n            pvalue_cutoff (float): association p-value cut-off\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Examples:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [{'qc': None, 'p_value_mantissa': 1, 'p_value_exponent': -7}, {'qc': None, 'p_value_mantissa': 1, 'p_value_exponent': -8}, {'qc': None, 'p_value_mantissa': 5, 'p_value_exponent': -8}, {'qc': None, 'p_value_mantissa': 1, 'p_value_exponent': -9}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StructType([t.StructField('qc', t.ArrayType(t.StringType()), True), t.StructField('p_value_mantissa', t.IntegerType()), t.StructField('p_value_exponent', t.IntegerType())]))\n            &gt;&gt;&gt; df.withColumn('qc', GWASCatalogAssociations._qc_subsignificant_associations(f.col(\"qc\"), f.col(\"p_value_mantissa\"), f.col(\"p_value_exponent\"), 5e-8)).show(truncate = False)\n            +------------------------+----------------+----------------+\n            |qc                      |p_value_mantissa|p_value_exponent|\n            +------------------------+----------------+----------------+\n            |[Subsignificant p-value]|1               |-7              |\n            |[]                      |1               |-8              |\n            |[]                      |5               |-8              |\n            |[]                      |1               |-9              |\n            +------------------------+----------------+----------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return StudyLocus._update_quality_flag(\n            qc,\n            calculate_neglog_pvalue(p_value_mantissa, p_value_exponent)\n            &lt; f.lit(-np.log10(pvalue_cutoff)),\n            StudyLocusQualityCheck.SUBSIGNIFICANT_FLAG,\n        )\n\n    @staticmethod\n    def _qc_genomic_location(\n        qc: Column, chromosome: Column, position: Column\n    ) -&gt; Column:\n        \"\"\"Flag associations without genomic location in GWAS Catalog.\n\n        Args:\n            qc (Column): QC column\n            chromosome (Column): Chromosome column in GWAS Catalog\n            position (Column): Position column in GWAS Catalog\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Examples:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [{'qc': None, 'chromosome': None, 'position': None}, {'qc': None, 'chromosome': '1', 'position': None}, {'qc': None, 'chromosome': None, 'position': 1}, {'qc': None, 'chromosome': '1', 'position': 1}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, schema=t.StructType([t.StructField('qc', t.ArrayType(t.StringType()), True), t.StructField('chromosome', t.StringType()), t.StructField('position', t.IntegerType())]))\n            &gt;&gt;&gt; df.withColumn('qc', GWASCatalogAssociations._qc_genomic_location(df.qc, df.chromosome, df.position)).show(truncate=False)\n            +----------------------------+----------+--------+\n            |qc                          |chromosome|position|\n            +----------------------------+----------+--------+\n            |[Incomplete genomic mapping]|null      |null    |\n            |[Incomplete genomic mapping]|1         |null    |\n            |[Incomplete genomic mapping]|null      |1       |\n            |[]                          |1         |1       |\n            +----------------------------+----------+--------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return StudyLocus._update_quality_flag(\n            qc,\n            position.isNull() | chromosome.isNull(),\n            StudyLocusQualityCheck.NO_GENOMIC_LOCATION_FLAG,\n        )\n\n    @staticmethod\n    def _qc_variant_inconsistencies(\n        qc: Column,\n        chromosome: Column,\n        position: Column,\n        strongest_snp_risk_allele: Column,\n    ) -&gt; Column:\n        \"\"\"Flag associations with inconsistencies in the variant annotation.\n\n        Args:\n            qc (Column): QC column\n            chromosome (Column): Chromosome column in GWAS Catalog\n            position (Column): Position column in GWAS Catalog\n            strongest_snp_risk_allele (Column): Strongest SNP risk allele column in GWAS Catalog\n\n        Returns:\n            Column: Updated QC column with flag.\n        \"\"\"\n        return GWASCatalogAssociations._update_quality_flag(\n            qc,\n            # Number of chromosomes does not correspond to the number of positions:\n            (f.size(f.split(chromosome, \";\")) != f.size(f.split(position, \";\")))\n            # Number of chromosome values different from riskAllele values:\n            | (\n                f.size(f.split(chromosome, \";\"))\n                != f.size(f.split(strongest_snp_risk_allele, \";\"))\n            ),\n            StudyLocusQualityCheck.INCONSISTENCY_FLAG,\n        )\n\n    @staticmethod\n    def _qc_unmapped_variants(qc: Column, alternate_allele: Column) -&gt; Column:\n        \"\"\"Flag associations with variants not mapped to variantAnnotation.\n\n        Args:\n            qc (Column): QC column\n            alternate_allele (Column): alternate allele\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [{'alternate_allele': 'A', 'qc': None}, {'alternate_allele': None, 'qc': None}]\n            &gt;&gt;&gt; schema = t.StructType([t.StructField('alternate_allele', t.StringType(), True), t.StructField('qc', t.ArrayType(t.StringType()), True)])\n            &gt;&gt;&gt; df = spark.createDataFrame(data=d, schema=schema)\n            &gt;&gt;&gt; df.withColumn(\"new_qc\", GWASCatalogAssociations._qc_unmapped_variants(f.col(\"qc\"), f.col(\"alternate_allele\"))).show()\n            +----------------+----+--------------------+\n            |alternate_allele|  qc|              new_qc|\n            +----------------+----+--------------------+\n            |               A|null|                  []|\n            |            null|null|[No mapping in Gn...|\n            +----------------+----+--------------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return GWASCatalogAssociations._update_quality_flag(\n            qc,\n            alternate_allele.isNull(),\n            StudyLocusQualityCheck.NON_MAPPED_VARIANT_FLAG,\n        )\n\n    @staticmethod\n    def _qc_palindromic_alleles(\n        qc: Column, reference_allele: Column, alternate_allele: Column\n    ) -&gt; Column:\n        \"\"\"Flag associations with palindromic variants which effects can not be harmonised.\n\n        Args:\n            qc (Column): QC column\n            reference_allele (Column): reference allele\n            alternate_allele (Column): alternate allele\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; schema = t.StructType([t.StructField('reference_allele', t.StringType(), True), t.StructField('alternate_allele', t.StringType(), True), t.StructField('qc', t.ArrayType(t.StringType()), True)])\n            &gt;&gt;&gt; d = [{'reference_allele': 'A', 'alternate_allele': 'T', 'qc': None}, {'reference_allele': 'AT', 'alternate_allele': 'TA', 'qc': None}, {'reference_allele': 'AT', 'alternate_allele': 'AT', 'qc': None}]\n            &gt;&gt;&gt; df = spark.createDataFrame(data=d, schema=schema)\n            &gt;&gt;&gt; df.withColumn(\"qc\", GWASCatalogAssociations._qc_palindromic_alleles(f.col(\"qc\"), f.col(\"reference_allele\"), f.col(\"alternate_allele\"))).show(truncate=False)\n            +----------------+----------------+---------------------------------------+\n            |reference_allele|alternate_allele|qc                                     |\n            +----------------+----------------+---------------------------------------+\n            |A               |T               |[Palindrome alleles - cannot harmonize]|\n            |AT              |TA              |[]                                     |\n            |AT              |AT              |[Palindrome alleles - cannot harmonize]|\n            +----------------+----------------+---------------------------------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return StudyLocus._update_quality_flag(\n            qc,\n            GWASCatalogAssociations._are_alleles_palindromic(\n                reference_allele, alternate_allele\n            ),\n            StudyLocusQualityCheck.PALINDROMIC_ALLELE_FLAG,\n        )\n\n    @classmethod\n    def from_source(\n        cls: type[GWASCatalogAssociations],\n        gwas_associations: DataFrame,\n        variant_annotation: VariantAnnotation,\n        pvalue_threshold: float = 5e-8,\n    ) -&gt; GWASCatalogAssociations:\n        \"\"\"Read GWASCatalog associations.\n\n        It reads the GWAS Catalog association dataset, selects and renames columns, casts columns, and\n        applies some pre-defined filters on the data:\n\n        Args:\n            gwas_associations (DataFrame): GWAS Catalog raw associations dataset\n            variant_annotation (VariantAnnotation): Variant annotation dataset\n            pvalue_threshold (float): P-value threshold for flagging associations\n\n        Returns:\n            GWASCatalogAssociations: GWASCatalogAssociations dataset\n        \"\"\"\n        return GWASCatalogAssociations(\n            _df=gwas_associations.withColumn(\n                \"studyLocusId\", f.monotonically_increasing_id().cast(LongType())\n            )\n            .transform(\n                # Map/harmonise variants to variant annotation dataset:\n                # This function adds columns: variantId, referenceAllele, alternateAllele, chromosome, position\n                lambda df: GWASCatalogAssociations._map_to_variant_annotation_variants(\n                    df, variant_annotation\n                )\n            )\n            .withColumn(\n                # Perform all quality control checks:\n                \"qualityControls\",\n                GWASCatalogAssociations._qc_all(\n                    f.array().alias(\"qualityControls\"),\n                    f.col(\"CHR_ID\"),\n                    f.col(\"CHR_POS\").cast(IntegerType()),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"STRONGEST SNP-RISK ALLELE\"),\n                    *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n                    pvalue_threshold,\n                ),\n            )\n            .select(\n                # INSIDE STUDY-LOCUS SCHEMA:\n                \"studyLocusId\",\n                \"variantId\",\n                # Mapped genomic location of the variant (; separated list)\n                \"chromosome\",\n                \"position\",\n                f.col(\"STUDY ACCESSION\").alias(\"studyId\"),\n                # beta value of the association\n                GWASCatalogAssociations._harmonise_beta(\n                    GWASCatalogAssociations._normalise_risk_allele(\n                        f.col(\"STRONGEST SNP-RISK ALLELE\")\n                    ),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"OR or BETA\"),\n                    f.col(\"95% CI (TEXT)\"),\n                ).alias(\"beta\"),\n                # p-value of the association, string: split into exponent and mantissa.\n                *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n                # Capturing phenotype granularity at the association level\n                GWASCatalogAssociations._concatenate_substudy_description(\n                    f.col(\"DISEASE/TRAIT\"),\n                    f.col(\"P-VALUE (TEXT)\"),\n                    f.col(\"MAPPED_TRAIT_URI\"),\n                ).alias(\"subStudyDescription\"),\n                # Quality controls (array of strings)\n                \"qualityControls\",\n            ),\n            _schema=GWASCatalogAssociations.get_schema(),\n        )\n\n    def update_study_id(\n        self: GWASCatalogAssociations, study_annotation: DataFrame\n    ) -&gt; GWASCatalogAssociations:\n        \"\"\"Update final studyId and studyLocusId with a dataframe containing study annotation.\n\n        Args:\n            study_annotation (DataFrame): Dataframe containing `updatedStudyId` and key columns `studyId` and `subStudyDescription`.\n\n        Returns:\n            GWASCatalogAssociations: Updated study locus with new `studyId` and `studyLocusId`.\n        \"\"\"\n        self.df = (\n            self._df.join(\n                study_annotation, on=[\"studyId\", \"subStudyDescription\"], how=\"left\"\n            )\n            .withColumn(\"studyId\", f.coalesce(\"updatedStudyId\", \"studyId\"))\n            .drop(\"subStudyDescription\", \"updatedStudyId\")\n        ).withColumn(\n            \"studyLocusId\",\n            StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\")),\n        )\n        return self\n\n    def _qc_ambiguous_study(self: GWASCatalogAssociations) -&gt; GWASCatalogAssociations:\n        \"\"\"Flag associations with variants that can not be unambiguously associated with one study.\n\n        Returns:\n            GWASCatalogAssociations: Updated study locus.\n        \"\"\"\n        assoc_ambiguity_window = Window.partitionBy(\n            f.col(\"studyId\"), f.col(\"variantId\")\n        )\n\n        self._df.withColumn(\n            \"qualityControls\",\n            StudyLocus._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.count(f.col(\"variantId\")).over(assoc_ambiguity_window) &gt; 1,\n                StudyLocusQualityCheck.AMBIGUOUS_STUDY,\n            ),\n        )\n        return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/associations/#otg.datasource.gwas_catalog.associations.GWASCatalogAssociations.from_source","title":"<code>from_source(gwas_associations: DataFrame, variant_annotation: VariantAnnotation, pvalue_threshold: float = 5e-08) -&gt; GWASCatalogAssociations</code>  <code>classmethod</code>","text":"<p>Read GWASCatalog associations.</p> <p>It reads the GWAS Catalog association dataset, selects and renames columns, casts columns, and applies some pre-defined filters on the data:</p> <p>Parameters:</p> Name Type Description Default <code>gwas_associations</code> <code>DataFrame</code> <p>GWAS Catalog raw associations dataset</p> required <code>variant_annotation</code> <code>VariantAnnotation</code> <p>Variant annotation dataset</p> required <code>pvalue_threshold</code> <code>float</code> <p>P-value threshold for flagging associations</p> <code>5e-08</code> <p>Returns:</p> Name Type Description <code>GWASCatalogAssociations</code> <code>GWASCatalogAssociations</code> <p>GWASCatalogAssociations dataset</p> Source code in <code>src/otg/datasource/gwas_catalog/associations.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[GWASCatalogAssociations],\n    gwas_associations: DataFrame,\n    variant_annotation: VariantAnnotation,\n    pvalue_threshold: float = 5e-8,\n) -&gt; GWASCatalogAssociations:\n    \"\"\"Read GWASCatalog associations.\n\n    It reads the GWAS Catalog association dataset, selects and renames columns, casts columns, and\n    applies some pre-defined filters on the data:\n\n    Args:\n        gwas_associations (DataFrame): GWAS Catalog raw associations dataset\n        variant_annotation (VariantAnnotation): Variant annotation dataset\n        pvalue_threshold (float): P-value threshold for flagging associations\n\n    Returns:\n        GWASCatalogAssociations: GWASCatalogAssociations dataset\n    \"\"\"\n    return GWASCatalogAssociations(\n        _df=gwas_associations.withColumn(\n            \"studyLocusId\", f.monotonically_increasing_id().cast(LongType())\n        )\n        .transform(\n            # Map/harmonise variants to variant annotation dataset:\n            # This function adds columns: variantId, referenceAllele, alternateAllele, chromosome, position\n            lambda df: GWASCatalogAssociations._map_to_variant_annotation_variants(\n                df, variant_annotation\n            )\n        )\n        .withColumn(\n            # Perform all quality control checks:\n            \"qualityControls\",\n            GWASCatalogAssociations._qc_all(\n                f.array().alias(\"qualityControls\"),\n                f.col(\"CHR_ID\"),\n                f.col(\"CHR_POS\").cast(IntegerType()),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"STRONGEST SNP-RISK ALLELE\"),\n                *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n                pvalue_threshold,\n            ),\n        )\n        .select(\n            # INSIDE STUDY-LOCUS SCHEMA:\n            \"studyLocusId\",\n            \"variantId\",\n            # Mapped genomic location of the variant (; separated list)\n            \"chromosome\",\n            \"position\",\n            f.col(\"STUDY ACCESSION\").alias(\"studyId\"),\n            # beta value of the association\n            GWASCatalogAssociations._harmonise_beta(\n                GWASCatalogAssociations._normalise_risk_allele(\n                    f.col(\"STRONGEST SNP-RISK ALLELE\")\n                ),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"OR or BETA\"),\n                f.col(\"95% CI (TEXT)\"),\n            ).alias(\"beta\"),\n            # p-value of the association, string: split into exponent and mantissa.\n            *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n            # Capturing phenotype granularity at the association level\n            GWASCatalogAssociations._concatenate_substudy_description(\n                f.col(\"DISEASE/TRAIT\"),\n                f.col(\"P-VALUE (TEXT)\"),\n                f.col(\"MAPPED_TRAIT_URI\"),\n            ).alias(\"subStudyDescription\"),\n            # Quality controls (array of strings)\n            \"qualityControls\",\n        ),\n        _schema=GWASCatalogAssociations.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/associations/#otg.datasource.gwas_catalog.associations.GWASCatalogAssociations.update_study_id","title":"<code>update_study_id(study_annotation: DataFrame) -&gt; GWASCatalogAssociations</code>","text":"<p>Update final studyId and studyLocusId with a dataframe containing study annotation.</p> <p>Parameters:</p> Name Type Description Default <code>study_annotation</code> <code>DataFrame</code> <p>Dataframe containing <code>updatedStudyId</code> and key columns <code>studyId</code> and <code>subStudyDescription</code>.</p> required <p>Returns:</p> Name Type Description <code>GWASCatalogAssociations</code> <code>GWASCatalogAssociations</code> <p>Updated study locus with new <code>studyId</code> and <code>studyLocusId</code>.</p> Source code in <code>src/otg/datasource/gwas_catalog/associations.py</code> <pre><code>def update_study_id(\n    self: GWASCatalogAssociations, study_annotation: DataFrame\n) -&gt; GWASCatalogAssociations:\n    \"\"\"Update final studyId and studyLocusId with a dataframe containing study annotation.\n\n    Args:\n        study_annotation (DataFrame): Dataframe containing `updatedStudyId` and key columns `studyId` and `subStudyDescription`.\n\n    Returns:\n        GWASCatalogAssociations: Updated study locus with new `studyId` and `studyLocusId`.\n    \"\"\"\n    self.df = (\n        self._df.join(\n            study_annotation, on=[\"studyId\", \"subStudyDescription\"], how=\"left\"\n        )\n        .withColumn(\"studyId\", f.coalesce(\"updatedStudyId\", \"studyId\"))\n        .drop(\"subStudyDescription\", \"updatedStudyId\")\n    ).withColumn(\n        \"studyLocusId\",\n        StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\")),\n    )\n    return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_index/","title":"Study Index","text":""},{"location":"python_api/datasource/gwas_catalog/study_index/#otg.datasource.gwas_catalog.study_index.GWASCatalogStudyIndex","title":"<code>otg.datasource.gwas_catalog.study_index.GWASCatalogStudyIndex</code>  <code>dataclass</code>","text":"<p>             Bases: <code>StudyIndex</code></p> <p>Study index from GWAS Catalog.</p> <p>The following information is harmonised from the GWAS Catalog:</p> <ul> <li>All publication related information retained.</li> <li>Mapped measured and background traits parsed.</li> <li>Flagged if harmonized summary statistics datasets available.</li> <li>If available, the ftp path to these files presented.</li> <li>Ancestries from the discovery and replication stages are structured with sample counts.</li> <li>Case/control counts extracted.</li> <li>The number of samples with European ancestry extracted.</li> </ul> Source code in <code>src/otg/datasource/gwas_catalog/study_index.py</code> <pre><code>@dataclass\nclass GWASCatalogStudyIndex(StudyIndex):\n    \"\"\"Study index from GWAS Catalog.\n\n    The following information is harmonised from the GWAS Catalog:\n\n    - All publication related information retained.\n    - Mapped measured and background traits parsed.\n    - Flagged if harmonized summary statistics datasets available.\n    - If available, the ftp path to these files presented.\n    - Ancestries from the discovery and replication stages are structured with sample counts.\n    - Case/control counts extracted.\n    - The number of samples with European ancestry extracted.\n\n    \"\"\"\n\n    @staticmethod\n    def _parse_discovery_samples(discovery_samples: Column) -&gt; Column:\n        \"\"\"Parse discovery sample sizes from GWAS Catalog.\n\n        This is a curated field. From publication sometimes it is not clear how the samples were split\n        across the reported ancestries. In such cases we are assuming the ancestries were evenly presented\n        and the total sample size is split:\n\n        [\"European, African\", 100] -&gt; [\"European, 50], [\"African\", 50]\n\n        Args:\n            discovery_samples (Column): Raw discovery sample sizes\n\n        Returns:\n            Column: Parsed and de-duplicated list of discovery ancestries with sample size.\n\n        Examples:\n            &gt;&gt;&gt; data = [('s1', \"European\", 10), ('s1', \"African\", 10), ('s2', \"European, African, Asian\", 100), ('s2', \"European\", 50)]\n            &gt;&gt;&gt; df = (\n            ...    spark.createDataFrame(data, ['studyId', 'ancestry', 'sampleSize'])\n            ...    .groupBy('studyId')\n            ...    .agg(\n            ...        f.collect_set(\n            ...            f.struct('ancestry', 'sampleSize')\n            ...        ).alias('discoverySampleSize')\n            ...    )\n            ...    .orderBy('studyId')\n            ...    .withColumn('discoverySampleSize', GWASCatalogStudyIndex._parse_discovery_samples(f.col('discoverySampleSize')))\n            ...    .select('discoverySampleSize')\n            ...    .show(truncate=False)\n            ... )\n            +--------------------------------------------+\n            |discoverySampleSize                         |\n            +--------------------------------------------+\n            |[{African, 10}, {European, 10}]             |\n            |[{European, 83}, {African, 33}, {Asian, 33}]|\n            +--------------------------------------------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        # To initialize return objects for aggregate functions, schema has to be definied:\n        schema = t.ArrayType(\n            t.StructType(\n                [\n                    t.StructField(\"ancestry\", t.StringType(), True),\n                    t.StructField(\"sampleSize\", t.IntegerType(), True),\n                ]\n            )\n        )\n\n        # Splitting comma separated ancestries:\n        exploded_ancestries = f.transform(\n            discovery_samples,\n            lambda sample: f.split(sample.ancestry, r\",\\s(?![^()]*\\))\"),\n        )\n\n        # Initialize discoverySample object from unique list of ancestries:\n        unique_ancestries = f.transform(\n            f.aggregate(\n                exploded_ancestries,\n                f.array().cast(t.ArrayType(t.StringType())),\n                lambda x, y: f.array_union(x, y),\n                f.array_distinct,\n            ),\n            lambda ancestry: f.struct(\n                ancestry.alias(\"ancestry\"),\n                f.lit(0).cast(t.LongType()).alias(\"sampleSize\"),\n            ),\n        )\n\n        # Computing sample sizes for ancestries when splitting is needed:\n        resolved_sample_count = f.transform(\n            f.arrays_zip(\n                f.transform(exploded_ancestries, lambda pop: f.size(pop)).alias(\n                    \"pop_size\"\n                ),\n                f.transform(discovery_samples, lambda pop: pop.sampleSize).alias(\n                    \"pop_count\"\n                ),\n            ),\n            lambda pop: (pop.pop_count / pop.pop_size).cast(t.IntegerType()),\n        )\n\n        # Flattening out ancestries with sample sizes:\n        parsed_sample_size = f.aggregate(\n            f.transform(\n                f.arrays_zip(\n                    exploded_ancestries.alias(\"ancestries\"),\n                    resolved_sample_count.alias(\"sample_count\"),\n                ),\n                GWASCatalogStudyIndex._merge_ancestries_and_counts,\n            ),\n            f.array().cast(schema),\n            lambda x, y: f.array_union(x, y),\n        )\n\n        # Normalize ancestries:\n        return f.aggregate(\n            parsed_sample_size,\n            unique_ancestries,\n            GWASCatalogStudyIndex._normalize_ancestries,\n        )\n\n    @staticmethod\n    def _normalize_ancestries(merged: Column, ancestry: Column) -&gt; Column:\n        \"\"\"Normalize ancestries from a list of structs.\n\n        As some ancestry label might be repeated with different sample counts,\n        these counts need to be collected.\n\n        Args:\n            merged (Column): Resulting list of struct with unique ancestries.\n            ancestry (Column): One ancestry object coming from raw.\n\n        Returns:\n            Column: Unique list of ancestries with the sample counts.\n        \"\"\"\n        # Iterating over the list of unique ancestries and adding the sample size if label matches:\n        return f.transform(\n            merged,\n            lambda a: f.when(\n                a.ancestry == ancestry.ancestry,\n                f.struct(\n                    a.ancestry.alias(\"ancestry\"),\n                    (a.sampleSize + ancestry.sampleSize)\n                    .cast(t.LongType())\n                    .alias(\"sampleSize\"),\n                ),\n            ).otherwise(a),\n        )\n\n    @staticmethod\n    def _merge_ancestries_and_counts(ancestry_group: Column) -&gt; Column:\n        \"\"\"Merge ancestries with sample sizes.\n\n        After splitting ancestry annotations, all resulting ancestries needs to be assigned\n        with the proper sample size.\n\n        Args:\n            ancestry_group (Column): Each element is a struct with `sample_count` (int) and `ancestries` (list)\n\n        Returns:\n            Column: a list of structs with `ancestry` and `sampleSize` fields.\n\n        Examples:\n            &gt;&gt;&gt; data = [(12, ['African', 'European']),(12, ['African'])]\n            &gt;&gt;&gt; (\n            ...     spark.createDataFrame(data, ['sample_count', 'ancestries'])\n            ...     .select(GWASCatalogStudyIndex._merge_ancestries_and_counts(f.struct('sample_count', 'ancestries')).alias('test'))\n            ...     .show(truncate=False)\n            ... )\n            +-------------------------------+\n            |test                           |\n            +-------------------------------+\n            |[{African, 12}, {European, 12}]|\n            |[{African, 12}]                |\n            +-------------------------------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        # Extract sample size for the ancestry group:\n        count = ancestry_group.sample_count\n\n        # We need to loop through the ancestries:\n        return f.transform(\n            ancestry_group.ancestries,\n            lambda ancestry: f.struct(\n                ancestry.alias(\"ancestry\"),\n                count.alias(\"sampleSize\"),\n            ),\n        )\n\n    @classmethod\n    def _parse_study_table(\n        cls: type[GWASCatalogStudyIndex], catalog_studies: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Harmonise GWASCatalog study table with `StudyIndex` schema.\n\n        Args:\n            catalog_studies (DataFrame): GWAS Catalog study table\n\n        Returns:\n            GWASCatalogStudyIndex: Parsed and annotated GWAS Catalog study table.\n        \"\"\"\n        return GWASCatalogStudyIndex(\n            _df=catalog_studies.select(\n                f.coalesce(\n                    f.col(\"STUDY ACCESSION\"), f.monotonically_increasing_id()\n                ).alias(\"studyId\"),\n                f.lit(\"GCST\").alias(\"projectId\"),\n                f.lit(\"gwas\").alias(\"studyType\"),\n                f.col(\"PUBMED ID\").alias(\"pubmedId\"),\n                f.col(\"FIRST AUTHOR\").alias(\"publicationFirstAuthor\"),\n                f.col(\"DATE\").alias(\"publicationDate\"),\n                f.col(\"JOURNAL\").alias(\"publicationJournal\"),\n                f.col(\"STUDY\").alias(\"publicationTitle\"),\n                f.coalesce(f.col(\"DISEASE/TRAIT\"), f.lit(\"Unreported\")).alias(\n                    \"traitFromSource\"\n                ),\n                f.col(\"INITIAL SAMPLE SIZE\").alias(\"initialSampleSize\"),\n                parse_efos(f.col(\"MAPPED_TRAIT_URI\")).alias(\"traitFromSourceMappedIds\"),\n                parse_efos(f.col(\"MAPPED BACKGROUND TRAIT URI\")).alias(\n                    \"backgroundTraitFromSourceMappedIds\"\n                ),\n            ),\n            _schema=GWASCatalogStudyIndex.get_schema(),\n        )\n\n    @classmethod\n    def from_source(\n        cls: type[GWASCatalogStudyIndex],\n        catalog_studies: DataFrame,\n        ancestry_file: DataFrame,\n        sumstats_lut: DataFrame,\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Ingests study level metadata from the GWAS Catalog.\n\n        Args:\n            catalog_studies (DataFrame): GWAS Catalog raw study table\n            ancestry_file (DataFrame): GWAS Catalog ancestry table.\n            sumstats_lut (DataFrame): GWAS Catalog summary statistics list.\n\n        Returns:\n            GWASCatalogStudyIndex: Parsed and annotated GWAS Catalog study table.\n        \"\"\"\n        # Read GWAS Catalogue raw data\n        return (\n            cls._parse_study_table(catalog_studies)\n            ._annotate_ancestries(ancestry_file)\n            ._annotate_sumstats_info(sumstats_lut)\n            ._annotate_discovery_sample_sizes()\n        )\n\n    def update_study_id(\n        self: GWASCatalogStudyIndex, study_annotation: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Update studyId with a dataframe containing study.\n\n        Args:\n            study_annotation (DataFrame): Dataframe containing `updatedStudyId`, `traitFromSource`, `traitFromSourceMappedIds` and key column `studyId`.\n\n        Returns:\n            GWASCatalogStudyIndex: Updated study table.\n        \"\"\"\n        self.df = (\n            self._df.join(\n                study_annotation.select(\n                    *[\n                        f.col(c).alias(f\"updated{c}\")\n                        if c not in [\"studyId\", \"updatedStudyId\"]\n                        else f.col(c)\n                        for c in study_annotation.columns\n                    ]\n                ),\n                on=\"studyId\",\n                how=\"left\",\n            )\n            .withColumn(\n                \"studyId\",\n                f.coalesce(f.col(\"updatedStudyId\"), f.col(\"studyId\")),\n            )\n            .withColumn(\n                \"traitFromSource\",\n                f.coalesce(f.col(\"updatedtraitFromSource\"), f.col(\"traitFromSource\")),\n            )\n            .withColumn(\n                \"traitFromSourceMappedIds\",\n                f.coalesce(\n                    f.col(\"updatedtraitFromSourceMappedIds\"),\n                    f.col(\"traitFromSourceMappedIds\"),\n                ),\n            )\n            .select(self._df.columns)\n        )\n\n        return self\n\n    def _annotate_ancestries(\n        self: GWASCatalogStudyIndex, ancestry_lut: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Extracting sample sizes and ancestry information.\n\n        This function parses the ancestry data. Also get counts for the europeans in the same\n        discovery stage.\n\n        Args:\n            ancestry_lut (DataFrame): Ancestry table as downloaded from the GWAS Catalog\n\n        Returns:\n            GWASCatalogStudyIndex: Slimmed and cleaned version of the ancestry annotation.\n        \"\"\"\n        ancestry = (\n            ancestry_lut\n            # Convert column headers to camelcase:\n            .transform(\n                lambda df: df.select(\n                    *[f.expr(column2camel_case(x)) for x in df.columns]\n                )\n            ).withColumnRenamed(\n                \"studyAccession\", \"studyId\"\n            )  # studyId has not been split yet\n        )\n\n        # Get a high resolution dataset on experimental stage:\n        ancestry_stages = (\n            ancestry.groupBy(\"studyId\")\n            .pivot(\"stage\")\n            .agg(\n                f.collect_set(\n                    f.struct(\n                        f.col(\"broadAncestralCategory\").alias(\"ancestry\"),\n                        f.col(\"numberOfIndividuals\")\n                        .cast(t.LongType())\n                        .alias(\"sampleSize\"),\n                    )\n                )\n            )\n            .withColumn(\n                \"discoverySamples\", self._parse_discovery_samples(f.col(\"initial\"))\n            )\n            .withColumnRenamed(\"replication\", \"replicationSamples\")\n            # Mapping discovery stage ancestries to LD reference:\n            .withColumn(\n                \"ldPopulationStructure\",\n                self.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n            )\n            .drop(\"initial\")\n            .persist()\n        )\n\n        # Generate information on the ancestry composition of the discovery stage, and calculate\n        # the proportion of the Europeans:\n        europeans_deconvoluted = (\n            ancestry\n            # Focus on discovery stage:\n            .filter(f.col(\"stage\") == \"initial\")\n            # Sorting ancestries if European:\n            .withColumn(\n                \"ancestryFlag\",\n                # Excluding finnish:\n                f.when(\n                    f.col(\"initialSampleDescription\").contains(\"Finnish\"),\n                    f.lit(\"other\"),\n                )\n                # Excluding Icelandic population:\n                .when(\n                    f.col(\"initialSampleDescription\").contains(\"Icelandic\"),\n                    f.lit(\"other\"),\n                )\n                # Including European ancestry:\n                .when(f.col(\"broadAncestralCategory\") == \"European\", f.lit(\"european\"))\n                # Exclude all other population:\n                .otherwise(\"other\"),\n            )\n            # Grouping by study accession and initial sample description:\n            .groupBy(\"studyId\")\n            .pivot(\"ancestryFlag\")\n            .agg(\n                # Summarizing sample sizes for all ancestries:\n                f.sum(f.col(\"numberOfIndividuals\"))\n            )\n            # Do arithmetics to make sure we have the right proportion of european in the set:\n            .withColumn(\n                \"initialSampleCountEuropean\",\n                f.when(f.col(\"european\").isNull(), f.lit(0)).otherwise(\n                    f.col(\"european\")\n                ),\n            )\n            .withColumn(\n                \"initialSampleCountOther\",\n                f.when(f.col(\"other\").isNull(), f.lit(0)).otherwise(f.col(\"other\")),\n            )\n            .withColumn(\n                \"initialSampleCount\",\n                f.col(\"initialSampleCountEuropean\") + f.col(\"other\"),\n            )\n            .drop(\n                \"european\",\n                \"other\",\n                \"initialSampleCount\",\n                \"initialSampleCountEuropean\",\n                \"initialSampleCountOther\",\n            )\n        )\n\n        parsed_ancestry_lut = ancestry_stages.join(\n            europeans_deconvoluted, on=\"studyId\", how=\"outer\"\n        )\n\n        self.df = self.df.join(parsed_ancestry_lut, on=\"studyId\", how=\"left\")\n        return self\n\n    def _annotate_sumstats_info(\n        self: GWASCatalogStudyIndex, sumstats_lut: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Annotate summary stat locations.\n\n        Args:\n            sumstats_lut (DataFrame): listing GWAS Catalog summary stats paths\n\n        Returns:\n            GWASCatalogStudyIndex: including `summarystatsLocation` and `hasSumstats` columns\n        \"\"\"\n        gwas_sumstats_base_uri = (\n            \"ftp://ftp.ebi.ac.uk/pub/databases/gwas/summary_statistics/\"\n        )\n\n        parsed_sumstats_lut = sumstats_lut.withColumn(\n            \"summarystatsLocation\",\n            f.concat(\n                f.lit(gwas_sumstats_base_uri),\n                f.regexp_replace(f.col(\"_c0\"), r\"^\\.\\/\", \"\"),\n            ),\n        ).select(\n            f.regexp_extract(f.col(\"summarystatsLocation\"), r\"\\/(GCST\\d+)\\/\", 1).alias(\n                \"studyId\"\n            ),\n            \"summarystatsLocation\",\n            f.lit(True).alias(\"hasSumstats\"),\n        )\n\n        self.df = (\n            self.df.drop(\"hasSumstats\")\n            .join(parsed_sumstats_lut, on=\"studyId\", how=\"left\")\n            .withColumn(\"hasSumstats\", f.coalesce(f.col(\"hasSumstats\"), f.lit(False)))\n        )\n        return self\n\n    def _annotate_discovery_sample_sizes(\n        self: GWASCatalogStudyIndex,\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Extract the sample size of the discovery stage of the study as annotated in the GWAS Catalog.\n\n        For some studies that measure quantitative traits, nCases and nControls can't be extracted. Therefore, we assume these are 0.\n\n        Returns:\n            GWASCatalogStudyIndex: object with columns `nCases`, `nControls`, and `nSamples` per `studyId` correctly extracted.\n        \"\"\"\n        sample_size_lut = (\n            self.df.select(\n                \"studyId\",\n                f.explode_outer(f.split(f.col(\"initialSampleSize\"), r\",\\s+\")).alias(\n                    \"samples\"\n                ),\n            )\n            # Extracting the sample size from the string:\n            .withColumn(\n                \"sampleSize\",\n                f.regexp_extract(\n                    f.regexp_replace(f.col(\"samples\"), \",\", \"\"), r\"[0-9,]+\", 0\n                ).cast(t.IntegerType()),\n            )\n            .select(\n                \"studyId\",\n                \"sampleSize\",\n                f.when(f.col(\"samples\").contains(\"cases\"), f.col(\"sampleSize\"))\n                .otherwise(f.lit(0))\n                .alias(\"nCases\"),\n                f.when(f.col(\"samples\").contains(\"controls\"), f.col(\"sampleSize\"))\n                .otherwise(f.lit(0))\n                .alias(\"nControls\"),\n            )\n            # Aggregating sample sizes for all ancestries:\n            .groupBy(\"studyId\")  # studyId has not been split yet\n            .agg(\n                f.sum(\"nCases\").alias(\"nCases\"),\n                f.sum(\"nControls\").alias(\"nControls\"),\n                f.sum(\"sampleSize\").alias(\"nSamples\"),\n            )\n        )\n        self.df = self.df.join(sample_size_lut, on=\"studyId\", how=\"left\")\n        return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_index/#otg.datasource.gwas_catalog.study_index.GWASCatalogStudyIndex.from_source","title":"<code>from_source(catalog_studies: DataFrame, ancestry_file: DataFrame, sumstats_lut: DataFrame) -&gt; GWASCatalogStudyIndex</code>  <code>classmethod</code>","text":"<p>Ingests study level metadata from the GWAS Catalog.</p> <p>Parameters:</p> Name Type Description Default <code>catalog_studies</code> <code>DataFrame</code> <p>GWAS Catalog raw study table</p> required <code>ancestry_file</code> <code>DataFrame</code> <p>GWAS Catalog ancestry table.</p> required <code>sumstats_lut</code> <code>DataFrame</code> <p>GWAS Catalog summary statistics list.</p> required <p>Returns:</p> Name Type Description <code>GWASCatalogStudyIndex</code> <code>GWASCatalogStudyIndex</code> <p>Parsed and annotated GWAS Catalog study table.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_index.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[GWASCatalogStudyIndex],\n    catalog_studies: DataFrame,\n    ancestry_file: DataFrame,\n    sumstats_lut: DataFrame,\n) -&gt; GWASCatalogStudyIndex:\n    \"\"\"Ingests study level metadata from the GWAS Catalog.\n\n    Args:\n        catalog_studies (DataFrame): GWAS Catalog raw study table\n        ancestry_file (DataFrame): GWAS Catalog ancestry table.\n        sumstats_lut (DataFrame): GWAS Catalog summary statistics list.\n\n    Returns:\n        GWASCatalogStudyIndex: Parsed and annotated GWAS Catalog study table.\n    \"\"\"\n    # Read GWAS Catalogue raw data\n    return (\n        cls._parse_study_table(catalog_studies)\n        ._annotate_ancestries(ancestry_file)\n        ._annotate_sumstats_info(sumstats_lut)\n        ._annotate_discovery_sample_sizes()\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_index/#otg.datasource.gwas_catalog.study_index.GWASCatalogStudyIndex.update_study_id","title":"<code>update_study_id(study_annotation: DataFrame) -&gt; GWASCatalogStudyIndex</code>","text":"<p>Update studyId with a dataframe containing study.</p> <p>Parameters:</p> Name Type Description Default <code>study_annotation</code> <code>DataFrame</code> <p>Dataframe containing <code>updatedStudyId</code>, <code>traitFromSource</code>, <code>traitFromSourceMappedIds</code> and key column <code>studyId</code>.</p> required <p>Returns:</p> Name Type Description <code>GWASCatalogStudyIndex</code> <code>GWASCatalogStudyIndex</code> <p>Updated study table.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_index.py</code> <pre><code>def update_study_id(\n    self: GWASCatalogStudyIndex, study_annotation: DataFrame\n) -&gt; GWASCatalogStudyIndex:\n    \"\"\"Update studyId with a dataframe containing study.\n\n    Args:\n        study_annotation (DataFrame): Dataframe containing `updatedStudyId`, `traitFromSource`, `traitFromSourceMappedIds` and key column `studyId`.\n\n    Returns:\n        GWASCatalogStudyIndex: Updated study table.\n    \"\"\"\n    self.df = (\n        self._df.join(\n            study_annotation.select(\n                *[\n                    f.col(c).alias(f\"updated{c}\")\n                    if c not in [\"studyId\", \"updatedStudyId\"]\n                    else f.col(c)\n                    for c in study_annotation.columns\n                ]\n            ),\n            on=\"studyId\",\n            how=\"left\",\n        )\n        .withColumn(\n            \"studyId\",\n            f.coalesce(f.col(\"updatedStudyId\"), f.col(\"studyId\")),\n        )\n        .withColumn(\n            \"traitFromSource\",\n            f.coalesce(f.col(\"updatedtraitFromSource\"), f.col(\"traitFromSource\")),\n        )\n        .withColumn(\n            \"traitFromSourceMappedIds\",\n            f.coalesce(\n                f.col(\"updatedtraitFromSourceMappedIds\"),\n                f.col(\"traitFromSourceMappedIds\"),\n            ),\n        )\n        .select(self._df.columns)\n    )\n\n    return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_splitter/","title":"Study Splitter","text":""},{"location":"python_api/datasource/gwas_catalog/study_splitter/#otg.datasource.gwas_catalog.study_splitter.GWASCatalogStudySplitter","title":"<code>otg.datasource.gwas_catalog.study_splitter.GWASCatalogStudySplitter</code>","text":"<p>Splitting multi-trait GWAS Catalog studies.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_splitter.py</code> <pre><code>class GWASCatalogStudySplitter:\n    \"\"\"Splitting multi-trait GWAS Catalog studies.\"\"\"\n\n    @staticmethod\n    def _resolve_trait(\n        study_trait: Column, association_trait: Column, p_value_text: Column\n    ) -&gt; Column:\n        \"\"\"Resolve trait names by consolidating association-level and study-level trait names.\n\n        Args:\n            study_trait (Column): Study-level trait name.\n            association_trait (Column): Association-level trait name.\n            p_value_text (Column): P-value text.\n\n        Returns:\n            Column: Resolved trait name.\n        \"\"\"\n        return (\n            f.when(\n                (p_value_text.isNotNull()) &amp; (p_value_text != (\"no_pvalue_text\")),\n                f.concat(\n                    association_trait,\n                    f.lit(\" [\"),\n                    p_value_text,\n                    f.lit(\"]\"),\n                ),\n            )\n            .when(\n                association_trait.isNotNull(),\n                association_trait,\n            )\n            .otherwise(study_trait)\n        )\n\n    @staticmethod\n    def _resolve_efo(association_efo: Column, study_efo: Column) -&gt; Column:\n        \"\"\"Resolve EFOs by consolidating association-level and study-level EFOs.\n\n        Args:\n            association_efo (Column): EFO column from the association table.\n            study_efo (Column): EFO column from the study table.\n\n        Returns:\n            Column: Consolidated EFO column.\n        \"\"\"\n        return f.coalesce(f.split(association_efo, r\"\\/\"), study_efo)\n\n    @staticmethod\n    def _resolve_study_id(study_id: Column, sub_study_description: Column) -&gt; Column:\n        \"\"\"Resolve study IDs by exploding association-level information (e.g. pvalue_text, EFO).\n\n        Args:\n            study_id (Column): Study ID column.\n            sub_study_description (Column): Sub-study description column from the association table.\n\n        Returns:\n            Column: Resolved study ID column.\n        \"\"\"\n        split_w = Window.partitionBy(study_id).orderBy(sub_study_description)\n        row_number = f.dense_rank().over(split_w)\n        substudy_count = f.count(row_number).over(split_w)\n        return f.when(substudy_count == 1, study_id).otherwise(\n            f.concat_ws(\"_\", study_id, row_number)\n        )\n\n    @classmethod\n    def split(\n        cls: type[GWASCatalogStudySplitter],\n        studies: GWASCatalogStudyIndex,\n        associations: GWASCatalogAssociations,\n    ) -&gt; Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]:\n        \"\"\"Splitting multi-trait GWAS Catalog studies.\n\n        If assigned disease of the study and the association don't agree, we assume the study needs to be split.\n        Then disease EFOs, trait names and study ID are consolidated\n\n        Args:\n            studies (GWASCatalogStudyIndex): GWAS Catalog studies.\n            associations (GWASCatalogAssociations): GWAS Catalog associations.\n\n        Returns:\n            Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]: Split studies and associations.\n        \"\"\"\n        # Composite of studies and associations to resolve scattered information\n        st_ass = (\n            associations.df.join(f.broadcast(studies.df), on=\"studyId\", how=\"inner\")\n            .select(\n                \"studyId\",\n                \"subStudyDescription\",\n                cls._resolve_study_id(\n                    f.col(\"studyId\"), f.col(\"subStudyDescription\")\n                ).alias(\"updatedStudyId\"),\n                cls._resolve_trait(\n                    f.col(\"traitFromSource\"),\n                    f.split(\"subStudyDescription\", r\"\\|\").getItem(0),\n                    f.split(\"subStudyDescription\", r\"\\|\").getItem(1),\n                ).alias(\"traitFromSource\"),\n                cls._resolve_efo(\n                    f.split(\"subStudyDescription\", r\"\\|\").getItem(2),\n                    f.col(\"traitFromSourceMappedIds\"),\n                ).alias(\"traitFromSourceMappedIds\"),\n            )\n            .persist()\n        )\n\n        return (\n            studies.update_study_id(\n                st_ass.select(\n                    \"studyId\",\n                    \"updatedStudyId\",\n                    \"traitFromSource\",\n                    \"traitFromSourceMappedIds\",\n                ).distinct()\n            ),\n            associations.update_study_id(\n                st_ass.select(\n                    \"updatedStudyId\", \"studyId\", \"subStudyDescription\"\n                ).distinct()\n            )._qc_ambiguous_study(),\n        )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_splitter/#otg.datasource.gwas_catalog.study_splitter.GWASCatalogStudySplitter.split","title":"<code>split(studies: GWASCatalogStudyIndex, associations: GWASCatalogAssociations) -&gt; Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]</code>  <code>classmethod</code>","text":"<p>Splitting multi-trait GWAS Catalog studies.</p> <p>If assigned disease of the study and the association don't agree, we assume the study needs to be split. Then disease EFOs, trait names and study ID are consolidated</p> <p>Parameters:</p> Name Type Description Default <code>studies</code> <code>GWASCatalogStudyIndex</code> <p>GWAS Catalog studies.</p> required <code>associations</code> <code>GWASCatalogAssociations</code> <p>GWAS Catalog associations.</p> required <p>Returns:</p> Type Description <code>Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]</code> <p>Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]: Split studies and associations.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_splitter.py</code> <pre><code>@classmethod\ndef split(\n    cls: type[GWASCatalogStudySplitter],\n    studies: GWASCatalogStudyIndex,\n    associations: GWASCatalogAssociations,\n) -&gt; Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]:\n    \"\"\"Splitting multi-trait GWAS Catalog studies.\n\n    If assigned disease of the study and the association don't agree, we assume the study needs to be split.\n    Then disease EFOs, trait names and study ID are consolidated\n\n    Args:\n        studies (GWASCatalogStudyIndex): GWAS Catalog studies.\n        associations (GWASCatalogAssociations): GWAS Catalog associations.\n\n    Returns:\n        Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]: Split studies and associations.\n    \"\"\"\n    # Composite of studies and associations to resolve scattered information\n    st_ass = (\n        associations.df.join(f.broadcast(studies.df), on=\"studyId\", how=\"inner\")\n        .select(\n            \"studyId\",\n            \"subStudyDescription\",\n            cls._resolve_study_id(\n                f.col(\"studyId\"), f.col(\"subStudyDescription\")\n            ).alias(\"updatedStudyId\"),\n            cls._resolve_trait(\n                f.col(\"traitFromSource\"),\n                f.split(\"subStudyDescription\", r\"\\|\").getItem(0),\n                f.split(\"subStudyDescription\", r\"\\|\").getItem(1),\n            ).alias(\"traitFromSource\"),\n            cls._resolve_efo(\n                f.split(\"subStudyDescription\", r\"\\|\").getItem(2),\n                f.col(\"traitFromSourceMappedIds\"),\n            ).alias(\"traitFromSourceMappedIds\"),\n        )\n        .persist()\n    )\n\n    return (\n        studies.update_study_id(\n            st_ass.select(\n                \"studyId\",\n                \"updatedStudyId\",\n                \"traitFromSource\",\n                \"traitFromSourceMappedIds\",\n            ).distinct()\n        ),\n        associations.update_study_id(\n            st_ass.select(\n                \"updatedStudyId\", \"studyId\", \"subStudyDescription\"\n            ).distinct()\n        )._qc_ambiguous_study(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/summary_statistics/","title":"Summary statistics","text":""},{"location":"python_api/datasource/gwas_catalog/summary_statistics/#otg.datasource.gwas_catalog.summary_statistics.GWASCatalogSummaryStatistics","title":"<code>otg.datasource.gwas_catalog.summary_statistics.GWASCatalogSummaryStatistics</code>  <code>dataclass</code>","text":"<p>             Bases: <code>SummaryStatistics</code></p> <p>GWAS Catalog Summary Statistics reader.</p> Source code in <code>src/otg/datasource/gwas_catalog/summary_statistics.py</code> <pre><code>@dataclass\nclass GWASCatalogSummaryStatistics(SummaryStatistics):\n    \"\"\"GWAS Catalog Summary Statistics reader.\"\"\"\n\n    @classmethod\n    def from_gwas_harmonized_summary_stats(\n        cls: type[GWASCatalogSummaryStatistics],\n        spark: SparkSession,\n        sumstats_file: str,\n    ) -&gt; GWASCatalogSummaryStatistics:\n        \"\"\"Create summary statistics object from summary statistics flatfile, harmonized by the GWAS Catalog.\n\n        Things got slightly complicated given the GWAS Catalog harmonization pipelines changed recently so we had to accomodate to\n        both formats.\n\n        Args:\n            spark (SparkSession): spark session\n            sumstats_file (str): list of GWAS Catalog summary stat files, with study ids in them.\n\n        Returns:\n            GWASCatalogSummaryStatistics: Summary statistics object.\n        \"\"\"\n        sumstats_df = spark.read.csv(sumstats_file, sep=\"\\t\", header=True).withColumn(\n            # Parsing GWAS Catalog study identifier from filename:\n            \"studyId\",\n            f.lit(filename_to_study_identifier(sumstats_file)),\n        )\n\n        # Parsing variant id fields:\n        chromosome = (\n            f.col(\"hm_chrom\")\n            if \"hm_chrom\" in sumstats_df.columns\n            else f.col(\"chromosome\")\n        ).cast(t.StringType())\n        position = (\n            f.col(\"hm_pos\")\n            if \"hm_pos\" in sumstats_df.columns\n            else f.col(\"base_pair_location\")\n        ).cast(t.IntegerType())\n        ref_allele = (\n            f.col(\"hm_other_allele\")\n            if \"hm_other_allele\" in sumstats_df.columns\n            else f.col(\"other_allele\")\n        )\n        alt_allele = (\n            f.col(\"hm_effect_allele\")\n            if \"hm_effect_allele\" in sumstats_df.columns\n            else f.col(\"effect_allele\")\n        )\n\n        # Parsing p-value (get a tuple with mantissa and exponent):\n        p_value_expression = (\n            parse_pvalue(f.col(\"p_value\"))\n            if \"p_value\" in sumstats_df.columns\n            else neglog_pvalue_to_mantissa_and_exponent(f.col(\"neg_log_10_p_value\"))\n        )\n\n        # The effect allele frequency is an optional column, we have to test if it is there:\n        allele_frequency = (\n            f.col(\"effect_allele_frequency\")\n            if \"effect_allele_frequency\" in sumstats_df.columns\n            else f.lit(None)\n        ).cast(t.FloatType())\n\n        # Do we have sample size? This expression captures 99.7% of sample size columns.\n        sample_size = (f.col(\"n\") if \"n\" in sumstats_df.columns else f.lit(None)).cast(\n            t.IntegerType()\n        )\n\n        # Depending on the input, we might have beta, but the column might not be there at all also old format calls differently:\n        beta_expression = (\n            f.col(\"hm_beta\")\n            if \"hm_beta\" in sumstats_df.columns\n            else f.col(\"beta\")\n            if \"beta\" in sumstats_df.columns\n            # If no column, create one:\n            else f.lit(None)\n        ).cast(t.DoubleType())\n\n        # We might have odds ratio or hazard ratio, wich are basically the same:\n        odds_ratio_expression = (\n            f.col(\"hm_odds_ratio\")\n            if \"hm_odds_ratio\" in sumstats_df.columns\n            else f.col(\"odds_ratio\")\n            if \"odds_ratio\" in sumstats_df.columns\n            else f.col(\"hazard_ratio\")\n            if \"hazard_ratio\" in sumstats_df.columns\n            # If no column, create one:\n            else f.lit(None)\n        ).cast(t.DoubleType())\n\n        # Standard error is mandatory but called differently in the new format:\n        standard_error = f.col(\"standard_error\").cast(t.DoubleType())\n\n        # Processing columns of interest:\n        processed_sumstats_df = (\n            sumstats_df\n            # Dropping rows which doesn't have proper position:\n            .select(\n                \"studyId\",\n                # Adding variant identifier:\n                f.concat_ws(\n                    \"_\",\n                    chromosome,\n                    position,\n                    ref_allele,\n                    alt_allele,\n                ).alias(\"variantId\"),\n                chromosome.alias(\"chromosome\"),\n                position.alias(\"position\"),\n                # Parsing p-value mantissa and exponent:\n                *p_value_expression,\n                # Converting/calculating effect and confidence interval:\n                *convert_odds_ratio_to_beta(\n                    beta_expression,\n                    odds_ratio_expression,\n                    standard_error,\n                ),\n                allele_frequency.alias(\"effectAlleleFrequencyFromSource\"),\n                sample_size.alias(\"sampleSize\"),\n            )\n            .filter(\n                # Dropping associations where no harmonized position is available:\n                f.col(\"position\").isNotNull()\n                &amp;\n                # We are not interested in associations with zero effect:\n                (f.col(\"beta\") != 0)\n            )\n            .orderBy(f.col(\"chromosome\"), f.col(\"position\"))\n            # median study size is 200Mb, max is 2.6Gb\n            .repartition(20)\n        )\n\n        # Initializing summary statistics object:\n        return cls(\n            _df=processed_sumstats_df,\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/summary_statistics/#otg.datasource.gwas_catalog.summary_statistics.GWASCatalogSummaryStatistics.from_gwas_harmonized_summary_stats","title":"<code>from_gwas_harmonized_summary_stats(spark: SparkSession, sumstats_file: str) -&gt; GWASCatalogSummaryStatistics</code>  <code>classmethod</code>","text":"<p>Create summary statistics object from summary statistics flatfile, harmonized by the GWAS Catalog.</p> <p>Things got slightly complicated given the GWAS Catalog harmonization pipelines changed recently so we had to accomodate to both formats.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>spark session</p> required <code>sumstats_file</code> <code>str</code> <p>list of GWAS Catalog summary stat files, with study ids in them.</p> required <p>Returns:</p> Name Type Description <code>GWASCatalogSummaryStatistics</code> <code>GWASCatalogSummaryStatistics</code> <p>Summary statistics object.</p> Source code in <code>src/otg/datasource/gwas_catalog/summary_statistics.py</code> <pre><code>@classmethod\ndef from_gwas_harmonized_summary_stats(\n    cls: type[GWASCatalogSummaryStatistics],\n    spark: SparkSession,\n    sumstats_file: str,\n) -&gt; GWASCatalogSummaryStatistics:\n    \"\"\"Create summary statistics object from summary statistics flatfile, harmonized by the GWAS Catalog.\n\n    Things got slightly complicated given the GWAS Catalog harmonization pipelines changed recently so we had to accomodate to\n    both formats.\n\n    Args:\n        spark (SparkSession): spark session\n        sumstats_file (str): list of GWAS Catalog summary stat files, with study ids in them.\n\n    Returns:\n        GWASCatalogSummaryStatistics: Summary statistics object.\n    \"\"\"\n    sumstats_df = spark.read.csv(sumstats_file, sep=\"\\t\", header=True).withColumn(\n        # Parsing GWAS Catalog study identifier from filename:\n        \"studyId\",\n        f.lit(filename_to_study_identifier(sumstats_file)),\n    )\n\n    # Parsing variant id fields:\n    chromosome = (\n        f.col(\"hm_chrom\")\n        if \"hm_chrom\" in sumstats_df.columns\n        else f.col(\"chromosome\")\n    ).cast(t.StringType())\n    position = (\n        f.col(\"hm_pos\")\n        if \"hm_pos\" in sumstats_df.columns\n        else f.col(\"base_pair_location\")\n    ).cast(t.IntegerType())\n    ref_allele = (\n        f.col(\"hm_other_allele\")\n        if \"hm_other_allele\" in sumstats_df.columns\n        else f.col(\"other_allele\")\n    )\n    alt_allele = (\n        f.col(\"hm_effect_allele\")\n        if \"hm_effect_allele\" in sumstats_df.columns\n        else f.col(\"effect_allele\")\n    )\n\n    # Parsing p-value (get a tuple with mantissa and exponent):\n    p_value_expression = (\n        parse_pvalue(f.col(\"p_value\"))\n        if \"p_value\" in sumstats_df.columns\n        else neglog_pvalue_to_mantissa_and_exponent(f.col(\"neg_log_10_p_value\"))\n    )\n\n    # The effect allele frequency is an optional column, we have to test if it is there:\n    allele_frequency = (\n        f.col(\"effect_allele_frequency\")\n        if \"effect_allele_frequency\" in sumstats_df.columns\n        else f.lit(None)\n    ).cast(t.FloatType())\n\n    # Do we have sample size? This expression captures 99.7% of sample size columns.\n    sample_size = (f.col(\"n\") if \"n\" in sumstats_df.columns else f.lit(None)).cast(\n        t.IntegerType()\n    )\n\n    # Depending on the input, we might have beta, but the column might not be there at all also old format calls differently:\n    beta_expression = (\n        f.col(\"hm_beta\")\n        if \"hm_beta\" in sumstats_df.columns\n        else f.col(\"beta\")\n        if \"beta\" in sumstats_df.columns\n        # If no column, create one:\n        else f.lit(None)\n    ).cast(t.DoubleType())\n\n    # We might have odds ratio or hazard ratio, wich are basically the same:\n    odds_ratio_expression = (\n        f.col(\"hm_odds_ratio\")\n        if \"hm_odds_ratio\" in sumstats_df.columns\n        else f.col(\"odds_ratio\")\n        if \"odds_ratio\" in sumstats_df.columns\n        else f.col(\"hazard_ratio\")\n        if \"hazard_ratio\" in sumstats_df.columns\n        # If no column, create one:\n        else f.lit(None)\n    ).cast(t.DoubleType())\n\n    # Standard error is mandatory but called differently in the new format:\n    standard_error = f.col(\"standard_error\").cast(t.DoubleType())\n\n    # Processing columns of interest:\n    processed_sumstats_df = (\n        sumstats_df\n        # Dropping rows which doesn't have proper position:\n        .select(\n            \"studyId\",\n            # Adding variant identifier:\n            f.concat_ws(\n                \"_\",\n                chromosome,\n                position,\n                ref_allele,\n                alt_allele,\n            ).alias(\"variantId\"),\n            chromosome.alias(\"chromosome\"),\n            position.alias(\"position\"),\n            # Parsing p-value mantissa and exponent:\n            *p_value_expression,\n            # Converting/calculating effect and confidence interval:\n            *convert_odds_ratio_to_beta(\n                beta_expression,\n                odds_ratio_expression,\n                standard_error,\n            ),\n            allele_frequency.alias(\"effectAlleleFrequencyFromSource\"),\n            sample_size.alias(\"sampleSize\"),\n        )\n        .filter(\n            # Dropping associations where no harmonized position is available:\n            f.col(\"position\").isNotNull()\n            &amp;\n            # We are not interested in associations with zero effect:\n            (f.col(\"beta\") != 0)\n        )\n        .orderBy(f.col(\"chromosome\"), f.col(\"position\"))\n        # median study size is 200Mb, max is 2.6Gb\n        .repartition(20)\n    )\n\n    # Initializing summary statistics object:\n    return cls(\n        _df=processed_sumstats_df,\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/_intervals/","title":"Chromatin intervals","text":"<p>TBC</p>"},{"location":"python_api/datasource/intervals/andersson/","title":"Andersson et al.","text":""},{"location":"python_api/datasource/intervals/andersson/#otg.datasource.intervals.andersson.IntervalsAndersson","title":"<code>otg.datasource.intervals.andersson.IntervalsAndersson</code>","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Andersson et al. 2014.</p> Source code in <code>src/otg/datasource/intervals/andersson.py</code> <pre><code>class IntervalsAndersson(Intervals):\n    \"\"\"Interval dataset from Andersson et al. 2014.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str) -&gt; DataFrame:\n        \"\"\"Read andersson2014 dataset.\n\n        Args:\n            spark (SparkSession): Spark session\n            path (str): Path to the dataset\n\n        Returns:\n            DataFrame: Raw Andersson et al. dataframe\n        \"\"\"\n        input_schema = t.StructType.fromJson(\n            json.loads(\n                pkg_resources.read_text(schemas, \"andersson2014.json\", encoding=\"utf-8\")\n            )\n        )\n        return (\n            spark.read.option(\"delimiter\", \"\\t\")\n            .option(\"mode\", \"DROPMALFORMED\")\n            .option(\"header\", \"true\")\n            .schema(input_schema)\n            .csv(path)\n        )\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsAndersson],\n        raw_anderson_df: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; IntervalsAndersson:\n        \"\"\"Parse Andersson et al. 2014 dataset.\n\n        Args:\n            raw_anderson_df (DataFrame): Raw Andersson et al. dataset\n            gene_index (GeneIndex): Gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            IntervalsAndersson: Intervals dataset\n        \"\"\"\n        # Constant values:\n        dataset_name = \"andersson2014\"\n        experiment_type = \"fantom5\"\n        pmid = \"24670763\"\n        bio_feature = \"aggregate\"\n        twosided_threshold = 2.45e6  # &lt;-  this needs to phased out. Filter by percentile instead of absolute value.\n\n        # Read the anderson file:\n        parsed_anderson_df = (\n            raw_anderson_df\n            # Parsing score column and casting as float:\n            .withColumn(\"score\", f.col(\"score\").cast(\"float\") / f.lit(1000))\n            # Parsing the 'name' column:\n            .withColumn(\"parsedName\", f.split(f.col(\"name\"), \";\"))\n            .withColumn(\"gene_symbol\", f.col(\"parsedName\")[2])\n            .withColumn(\"location\", f.col(\"parsedName\")[0])\n            .withColumn(\n                \"chrom\",\n                f.regexp_replace(f.split(f.col(\"location\"), \":|-\")[0], \"chr\", \"\"),\n            )\n            .withColumn(\n                \"start\", f.split(f.col(\"location\"), \":|-\")[1].cast(t.IntegerType())\n            )\n            .withColumn(\n                \"end\", f.split(f.col(\"location\"), \":|-\")[2].cast(t.IntegerType())\n            )\n            # Select relevant columns:\n            .select(\"chrom\", \"start\", \"end\", \"gene_symbol\", \"score\")\n            # Drop rows with non-canonical chromosomes:\n            .filter(\n                f.col(\"chrom\").isin([str(x) for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"])\n            )\n            # For each region/gene, keep only one row with the highest score:\n            .groupBy(\"chrom\", \"start\", \"end\", \"gene_symbol\")\n            .agg(f.max(\"score\").alias(\"resourceScore\"))\n            .orderBy(\"chrom\", \"start\")\n        )\n\n        return cls(\n            _df=(\n                # Lift over the intervals:\n                lift.convert_intervals(parsed_anderson_df, \"chrom\", \"start\", \"end\")\n                .drop(\"start\", \"end\")\n                .withColumnRenamed(\"mapped_start\", \"start\")\n                .withColumnRenamed(\"mapped_end\", \"end\")\n                .distinct()\n                # Joining with the gene index\n                .alias(\"intervals\")\n                .join(\n                    gene_index.symbols_lut().alias(\"genes\"),\n                    on=[\n                        f.col(\"intervals.gene_symbol\") == f.col(\"genes.geneSymbol\"),\n                        # Drop rows where the TSS is far from the start of the region\n                        f.abs(\n                            (f.col(\"intervals.start\") + f.col(\"intervals.end\")) / 2\n                            - f.col(\"tss\")\n                        )\n                        &lt;= twosided_threshold,\n                    ],\n                    how=\"left\",\n                )\n                # Select relevant columns:\n                .select(\n                    f.col(\"chrom\").alias(\"chromosome\"),\n                    f.col(\"intervals.start\").alias(\"start\"),\n                    f.col(\"intervals.end\").alias(\"end\"),\n                    \"geneId\",\n                    \"resourceScore\",\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                    f.lit(bio_feature).alias(\"biofeature\"),\n                )\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/andersson/#otg.datasource.intervals.andersson.IntervalsAndersson.parse","title":"<code>parse(raw_anderson_df: DataFrame, gene_index: GeneIndex, lift: LiftOverSpark) -&gt; IntervalsAndersson</code>  <code>classmethod</code>","text":"<p>Parse Andersson et al. 2014 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>raw_anderson_df</code> <code>DataFrame</code> <p>Raw Andersson et al. dataset</p> required <code>gene_index</code> <code>GeneIndex</code> <p>Gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>IntervalsAndersson</code> <code>IntervalsAndersson</code> <p>Intervals dataset</p> Source code in <code>src/otg/datasource/intervals/andersson.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsAndersson],\n    raw_anderson_df: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; IntervalsAndersson:\n    \"\"\"Parse Andersson et al. 2014 dataset.\n\n    Args:\n        raw_anderson_df (DataFrame): Raw Andersson et al. dataset\n        gene_index (GeneIndex): Gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        IntervalsAndersson: Intervals dataset\n    \"\"\"\n    # Constant values:\n    dataset_name = \"andersson2014\"\n    experiment_type = \"fantom5\"\n    pmid = \"24670763\"\n    bio_feature = \"aggregate\"\n    twosided_threshold = 2.45e6  # &lt;-  this needs to phased out. Filter by percentile instead of absolute value.\n\n    # Read the anderson file:\n    parsed_anderson_df = (\n        raw_anderson_df\n        # Parsing score column and casting as float:\n        .withColumn(\"score\", f.col(\"score\").cast(\"float\") / f.lit(1000))\n        # Parsing the 'name' column:\n        .withColumn(\"parsedName\", f.split(f.col(\"name\"), \";\"))\n        .withColumn(\"gene_symbol\", f.col(\"parsedName\")[2])\n        .withColumn(\"location\", f.col(\"parsedName\")[0])\n        .withColumn(\n            \"chrom\",\n            f.regexp_replace(f.split(f.col(\"location\"), \":|-\")[0], \"chr\", \"\"),\n        )\n        .withColumn(\n            \"start\", f.split(f.col(\"location\"), \":|-\")[1].cast(t.IntegerType())\n        )\n        .withColumn(\n            \"end\", f.split(f.col(\"location\"), \":|-\")[2].cast(t.IntegerType())\n        )\n        # Select relevant columns:\n        .select(\"chrom\", \"start\", \"end\", \"gene_symbol\", \"score\")\n        # Drop rows with non-canonical chromosomes:\n        .filter(\n            f.col(\"chrom\").isin([str(x) for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"])\n        )\n        # For each region/gene, keep only one row with the highest score:\n        .groupBy(\"chrom\", \"start\", \"end\", \"gene_symbol\")\n        .agg(f.max(\"score\").alias(\"resourceScore\"))\n        .orderBy(\"chrom\", \"start\")\n    )\n\n    return cls(\n        _df=(\n            # Lift over the intervals:\n            lift.convert_intervals(parsed_anderson_df, \"chrom\", \"start\", \"end\")\n            .drop(\"start\", \"end\")\n            .withColumnRenamed(\"mapped_start\", \"start\")\n            .withColumnRenamed(\"mapped_end\", \"end\")\n            .distinct()\n            # Joining with the gene index\n            .alias(\"intervals\")\n            .join(\n                gene_index.symbols_lut().alias(\"genes\"),\n                on=[\n                    f.col(\"intervals.gene_symbol\") == f.col(\"genes.geneSymbol\"),\n                    # Drop rows where the TSS is far from the start of the region\n                    f.abs(\n                        (f.col(\"intervals.start\") + f.col(\"intervals.end\")) / 2\n                        - f.col(\"tss\")\n                    )\n                    &lt;= twosided_threshold,\n                ],\n                how=\"left\",\n            )\n            # Select relevant columns:\n            .select(\n                f.col(\"chrom\").alias(\"chromosome\"),\n                f.col(\"intervals.start\").alias(\"start\"),\n                f.col(\"intervals.end\").alias(\"end\"),\n                \"geneId\",\n                \"resourceScore\",\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n                f.lit(bio_feature).alias(\"biofeature\"),\n            )\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/andersson/#otg.datasource.intervals.andersson.IntervalsAndersson.read","title":"<code>read(spark: SparkSession, path: str) -&gt; DataFrame</code>  <code>staticmethod</code>","text":"<p>Read andersson2014 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to the dataset</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Raw Andersson et al. dataframe</p> Source code in <code>src/otg/datasource/intervals/andersson.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str) -&gt; DataFrame:\n    \"\"\"Read andersson2014 dataset.\n\n    Args:\n        spark (SparkSession): Spark session\n        path (str): Path to the dataset\n\n    Returns:\n        DataFrame: Raw Andersson et al. dataframe\n    \"\"\"\n    input_schema = t.StructType.fromJson(\n        json.loads(\n            pkg_resources.read_text(schemas, \"andersson2014.json\", encoding=\"utf-8\")\n        )\n    )\n    return (\n        spark.read.option(\"delimiter\", \"\\t\")\n        .option(\"mode\", \"DROPMALFORMED\")\n        .option(\"header\", \"true\")\n        .schema(input_schema)\n        .csv(path)\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/javierre/","title":"Javierre et al.","text":""},{"location":"python_api/datasource/intervals/javierre/#otg.datasource.intervals.javierre.IntervalsJavierre","title":"<code>otg.datasource.intervals.javierre.IntervalsJavierre</code>","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Javierre et al. 2016.</p> Source code in <code>src/otg/datasource/intervals/javierre.py</code> <pre><code>class IntervalsJavierre(Intervals):\n    \"\"\"Interval dataset from Javierre et al. 2016.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str) -&gt; DataFrame:\n        \"\"\"Read Javierre dataset.\n\n        Args:\n            spark (SparkSession): Spark session\n            path (str): Path to dataset\n\n        Returns:\n            DataFrame: Raw Javierre dataset\n        \"\"\"\n        return spark.read.parquet(path)\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsJavierre],\n        javierre_raw: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; IntervalsJavierre:\n        \"\"\"Parse Javierre et al. 2016 dataset.\n\n        Args:\n            javierre_raw (DataFrame): Raw Javierre data\n            gene_index (GeneIndex): Gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            IntervalsJavierre: Javierre et al. 2016 interval data\n        \"\"\"\n        # Constant values:\n        dataset_name = \"javierre2016\"\n        experiment_type = \"pchic\"\n        pmid = \"27863249\"\n        twosided_threshold = 2.45e6\n\n        # Read Javierre data:\n        javierre_parsed = (\n            javierre_raw\n            # Splitting name column into chromosome, start, end, and score:\n            .withColumn(\"name_split\", f.split(f.col(\"name\"), r\":|-|,\"))\n            .withColumn(\n                \"name_chr\",\n                f.regexp_replace(f.col(\"name_split\")[0], \"chr\", \"\").cast(\n                    t.StringType()\n                ),\n            )\n            .withColumn(\"name_start\", f.col(\"name_split\")[1].cast(t.IntegerType()))\n            .withColumn(\"name_end\", f.col(\"name_split\")[2].cast(t.IntegerType()))\n            .withColumn(\"name_score\", f.col(\"name_split\")[3].cast(t.FloatType()))\n            # Cleaning up chromosome:\n            .withColumn(\n                \"chrom\",\n                f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").cast(t.StringType()),\n            )\n            .drop(\"name_split\", \"name\", \"annotation\")\n            # Keep canonical chromosomes and consistent chromosomes with scores:\n            .filter(\n                (f.col(\"name_score\").isNotNull())\n                &amp; (f.col(\"chrom\") == f.col(\"name_chr\"))\n                &amp; f.col(\"name_chr\").isin(\n                    [f\"{x}\" for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"]\n                )\n            )\n        )\n\n        # Lifting over intervals:\n        javierre_remapped = (\n            javierre_parsed\n            # Lifting over to GRCh38 interval 1:\n            .transform(lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\"))\n            .drop(\"start\", \"end\")\n            .withColumnRenamed(\"mapped_chrom\", \"chrom\")\n            .withColumnRenamed(\"mapped_start\", \"start\")\n            .withColumnRenamed(\"mapped_end\", \"end\")\n            # Lifting over interval 2 to GRCh38:\n            .transform(\n                lambda df: lift.convert_intervals(\n                    df, \"name_chr\", \"name_start\", \"name_end\"\n                )\n            )\n            .drop(\"name_start\", \"name_end\")\n            .withColumnRenamed(\"mapped_name_chr\", \"name_chr\")\n            .withColumnRenamed(\"mapped_name_start\", \"name_start\")\n            .withColumnRenamed(\"mapped_name_end\", \"name_end\")\n        )\n\n        # Once the intervals are lifted, extracting the unique intervals:\n        unique_intervals_with_genes = (\n            javierre_remapped.select(\n                f.col(\"chrom\"),\n                f.col(\"start\").cast(t.IntegerType()),\n                f.col(\"end\").cast(t.IntegerType()),\n            )\n            .distinct()\n            .alias(\"intervals\")\n            .join(\n                gene_index.locations_lut().alias(\"genes\"),\n                on=[\n                    f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                    (\n                        (f.col(\"intervals.start\") &gt;= f.col(\"genes.start\"))\n                        &amp; (f.col(\"intervals.start\") &lt;= f.col(\"genes.end\"))\n                    )\n                    | (\n                        (f.col(\"intervals.end\") &gt;= f.col(\"genes.start\"))\n                        &amp; (f.col(\"intervals.end\") &lt;= f.col(\"genes.end\"))\n                    ),\n                ],\n                how=\"left\",\n            )\n            .select(\n                f.col(\"intervals.chrom\").alias(\"chrom\"),\n                f.col(\"intervals.start\").alias(\"start\"),\n                f.col(\"intervals.end\").alias(\"end\"),\n                f.col(\"genes.geneId\").alias(\"geneId\"),\n                f.col(\"genes.tss\").alias(\"tss\"),\n            )\n        )\n\n        # Joining back the data:\n        return cls(\n            _df=(\n                javierre_remapped.join(\n                    unique_intervals_with_genes,\n                    on=[\"chrom\", \"start\", \"end\"],\n                    how=\"left\",\n                )\n                .filter(\n                    # Drop rows where the TSS is far from the start of the region\n                    f.abs((f.col(\"start\") + f.col(\"end\")) / 2 - f.col(\"tss\"))\n                    &lt;= twosided_threshold\n                )\n                # For each gene, keep only the highest scoring interval:\n                .groupBy(\"name_chr\", \"name_start\", \"name_end\", \"geneId\", \"bio_feature\")\n                .agg(f.max(f.col(\"name_score\")).alias(\"resourceScore\"))\n                # Create the output:\n                .select(\n                    f.col(\"name_chr\").alias(\"chromosome\"),\n                    f.col(\"name_start\").alias(\"start\"),\n                    f.col(\"name_end\").alias(\"end\"),\n                    f.col(\"resourceScore\").cast(t.DoubleType()),\n                    f.col(\"geneId\"),\n                    f.col(\"bio_feature\").alias(\"biofeature\"),\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                )\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/javierre/#otg.datasource.intervals.javierre.IntervalsJavierre.parse","title":"<code>parse(javierre_raw: DataFrame, gene_index: GeneIndex, lift: LiftOverSpark) -&gt; IntervalsJavierre</code>  <code>classmethod</code>","text":"<p>Parse Javierre et al. 2016 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>javierre_raw</code> <code>DataFrame</code> <p>Raw Javierre data</p> required <code>gene_index</code> <code>GeneIndex</code> <p>Gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>IntervalsJavierre</code> <code>IntervalsJavierre</code> <p>Javierre et al. 2016 interval data</p> Source code in <code>src/otg/datasource/intervals/javierre.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsJavierre],\n    javierre_raw: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; IntervalsJavierre:\n    \"\"\"Parse Javierre et al. 2016 dataset.\n\n    Args:\n        javierre_raw (DataFrame): Raw Javierre data\n        gene_index (GeneIndex): Gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        IntervalsJavierre: Javierre et al. 2016 interval data\n    \"\"\"\n    # Constant values:\n    dataset_name = \"javierre2016\"\n    experiment_type = \"pchic\"\n    pmid = \"27863249\"\n    twosided_threshold = 2.45e6\n\n    # Read Javierre data:\n    javierre_parsed = (\n        javierre_raw\n        # Splitting name column into chromosome, start, end, and score:\n        .withColumn(\"name_split\", f.split(f.col(\"name\"), r\":|-|,\"))\n        .withColumn(\n            \"name_chr\",\n            f.regexp_replace(f.col(\"name_split\")[0], \"chr\", \"\").cast(\n                t.StringType()\n            ),\n        )\n        .withColumn(\"name_start\", f.col(\"name_split\")[1].cast(t.IntegerType()))\n        .withColumn(\"name_end\", f.col(\"name_split\")[2].cast(t.IntegerType()))\n        .withColumn(\"name_score\", f.col(\"name_split\")[3].cast(t.FloatType()))\n        # Cleaning up chromosome:\n        .withColumn(\n            \"chrom\",\n            f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").cast(t.StringType()),\n        )\n        .drop(\"name_split\", \"name\", \"annotation\")\n        # Keep canonical chromosomes and consistent chromosomes with scores:\n        .filter(\n            (f.col(\"name_score\").isNotNull())\n            &amp; (f.col(\"chrom\") == f.col(\"name_chr\"))\n            &amp; f.col(\"name_chr\").isin(\n                [f\"{x}\" for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"]\n            )\n        )\n    )\n\n    # Lifting over intervals:\n    javierre_remapped = (\n        javierre_parsed\n        # Lifting over to GRCh38 interval 1:\n        .transform(lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\"))\n        .drop(\"start\", \"end\")\n        .withColumnRenamed(\"mapped_chrom\", \"chrom\")\n        .withColumnRenamed(\"mapped_start\", \"start\")\n        .withColumnRenamed(\"mapped_end\", \"end\")\n        # Lifting over interval 2 to GRCh38:\n        .transform(\n            lambda df: lift.convert_intervals(\n                df, \"name_chr\", \"name_start\", \"name_end\"\n            )\n        )\n        .drop(\"name_start\", \"name_end\")\n        .withColumnRenamed(\"mapped_name_chr\", \"name_chr\")\n        .withColumnRenamed(\"mapped_name_start\", \"name_start\")\n        .withColumnRenamed(\"mapped_name_end\", \"name_end\")\n    )\n\n    # Once the intervals are lifted, extracting the unique intervals:\n    unique_intervals_with_genes = (\n        javierre_remapped.select(\n            f.col(\"chrom\"),\n            f.col(\"start\").cast(t.IntegerType()),\n            f.col(\"end\").cast(t.IntegerType()),\n        )\n        .distinct()\n        .alias(\"intervals\")\n        .join(\n            gene_index.locations_lut().alias(\"genes\"),\n            on=[\n                f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                (\n                    (f.col(\"intervals.start\") &gt;= f.col(\"genes.start\"))\n                    &amp; (f.col(\"intervals.start\") &lt;= f.col(\"genes.end\"))\n                )\n                | (\n                    (f.col(\"intervals.end\") &gt;= f.col(\"genes.start\"))\n                    &amp; (f.col(\"intervals.end\") &lt;= f.col(\"genes.end\"))\n                ),\n            ],\n            how=\"left\",\n        )\n        .select(\n            f.col(\"intervals.chrom\").alias(\"chrom\"),\n            f.col(\"intervals.start\").alias(\"start\"),\n            f.col(\"intervals.end\").alias(\"end\"),\n            f.col(\"genes.geneId\").alias(\"geneId\"),\n            f.col(\"genes.tss\").alias(\"tss\"),\n        )\n    )\n\n    # Joining back the data:\n    return cls(\n        _df=(\n            javierre_remapped.join(\n                unique_intervals_with_genes,\n                on=[\"chrom\", \"start\", \"end\"],\n                how=\"left\",\n            )\n            .filter(\n                # Drop rows where the TSS is far from the start of the region\n                f.abs((f.col(\"start\") + f.col(\"end\")) / 2 - f.col(\"tss\"))\n                &lt;= twosided_threshold\n            )\n            # For each gene, keep only the highest scoring interval:\n            .groupBy(\"name_chr\", \"name_start\", \"name_end\", \"geneId\", \"bio_feature\")\n            .agg(f.max(f.col(\"name_score\")).alias(\"resourceScore\"))\n            # Create the output:\n            .select(\n                f.col(\"name_chr\").alias(\"chromosome\"),\n                f.col(\"name_start\").alias(\"start\"),\n                f.col(\"name_end\").alias(\"end\"),\n                f.col(\"resourceScore\").cast(t.DoubleType()),\n                f.col(\"geneId\"),\n                f.col(\"bio_feature\").alias(\"biofeature\"),\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n            )\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/javierre/#otg.datasource.intervals.javierre.IntervalsJavierre.read","title":"<code>read(spark: SparkSession, path: str) -&gt; DataFrame</code>  <code>staticmethod</code>","text":"<p>Read Javierre dataset.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to dataset</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Raw Javierre dataset</p> Source code in <code>src/otg/datasource/intervals/javierre.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str) -&gt; DataFrame:\n    \"\"\"Read Javierre dataset.\n\n    Args:\n        spark (SparkSession): Spark session\n        path (str): Path to dataset\n\n    Returns:\n        DataFrame: Raw Javierre dataset\n    \"\"\"\n    return spark.read.parquet(path)\n</code></pre>"},{"location":"python_api/datasource/intervals/jung/","title":"Jung et al.","text":""},{"location":"python_api/datasource/intervals/jung/#otg.datasource.intervals.jung.IntervalsJung","title":"<code>otg.datasource.intervals.jung.IntervalsJung</code>","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Jung et al. 2019.</p> Source code in <code>src/otg/datasource/intervals/jung.py</code> <pre><code>class IntervalsJung(Intervals):\n    \"\"\"Interval dataset from Jung et al. 2019.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str) -&gt; DataFrame:\n        \"\"\"Read jung dataset.\n\n        Args:\n            spark (SparkSession): Spark session\n            path (str): Path to dataset\n\n        Returns:\n            DataFrame: DataFrame with raw jung data\n        \"\"\"\n        return spark.read.csv(path, sep=\",\", header=True)\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsJung],\n        jung_raw: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; IntervalsJung:\n        \"\"\"Parse the Jung et al. 2019 dataset.\n\n        Args:\n            jung_raw (DataFrame): raw Jung et al. 2019 dataset\n            gene_index (GeneIndex): gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            IntervalsJung: Interval dataset containing Jung et al. 2019 data\n        \"\"\"\n        dataset_name = \"jung2019\"\n        experiment_type = \"pchic\"\n        pmid = \"31501517\"\n\n        # Lifting over the coordinates:\n        return cls(\n            _df=(\n                jung_raw.withColumn(\n                    \"interval\", f.split(f.col(\"Interacting_fragment\"), r\"\\.\")\n                )\n                .select(\n                    # Parsing intervals:\n                    f.regexp_replace(f.col(\"interval\")[0], \"chr\", \"\").alias(\"chrom\"),\n                    f.col(\"interval\")[1].cast(t.IntegerType()).alias(\"start\"),\n                    f.col(\"interval\")[2].cast(t.IntegerType()).alias(\"end\"),\n                    # Extract other columns:\n                    f.col(\"Promoter\").alias(\"gene_name\"),\n                    f.col(\"Tissue_type\").alias(\"tissue\"),\n                )\n                # Lifting over to GRCh38 interval 1:\n                .transform(\n                    lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n                )\n                .select(\n                    \"chrom\",\n                    f.col(\"mapped_start\").alias(\"start\"),\n                    f.col(\"mapped_end\").alias(\"end\"),\n                    f.explode(f.split(f.col(\"gene_name\"), \";\")).alias(\"gene_name\"),\n                    \"tissue\",\n                )\n                .alias(\"intervals\")\n                # Joining with genes:\n                .join(\n                    gene_index.symbols_lut().alias(\"genes\"),\n                    on=[f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\")],\n                    how=\"inner\",\n                )\n                # Finalize dataset:\n                .select(\n                    \"chromosome\",\n                    f.col(\"intervals.start\").alias(\"start\"),\n                    f.col(\"intervals.end\").alias(\"end\"),\n                    \"geneId\",\n                    f.col(\"tissue\").alias(\"biofeature\"),\n                    f.lit(1.0).alias(\"score\"),\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                )\n                .drop_duplicates()\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/jung/#otg.datasource.intervals.jung.IntervalsJung.parse","title":"<code>parse(jung_raw: DataFrame, gene_index: GeneIndex, lift: LiftOverSpark) -&gt; IntervalsJung</code>  <code>classmethod</code>","text":"<p>Parse the Jung et al. 2019 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>jung_raw</code> <code>DataFrame</code> <p>raw Jung et al. 2019 dataset</p> required <code>gene_index</code> <code>GeneIndex</code> <p>gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>IntervalsJung</code> <code>IntervalsJung</code> <p>Interval dataset containing Jung et al. 2019 data</p> Source code in <code>src/otg/datasource/intervals/jung.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsJung],\n    jung_raw: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; IntervalsJung:\n    \"\"\"Parse the Jung et al. 2019 dataset.\n\n    Args:\n        jung_raw (DataFrame): raw Jung et al. 2019 dataset\n        gene_index (GeneIndex): gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        IntervalsJung: Interval dataset containing Jung et al. 2019 data\n    \"\"\"\n    dataset_name = \"jung2019\"\n    experiment_type = \"pchic\"\n    pmid = \"31501517\"\n\n    # Lifting over the coordinates:\n    return cls(\n        _df=(\n            jung_raw.withColumn(\n                \"interval\", f.split(f.col(\"Interacting_fragment\"), r\"\\.\")\n            )\n            .select(\n                # Parsing intervals:\n                f.regexp_replace(f.col(\"interval\")[0], \"chr\", \"\").alias(\"chrom\"),\n                f.col(\"interval\")[1].cast(t.IntegerType()).alias(\"start\"),\n                f.col(\"interval\")[2].cast(t.IntegerType()).alias(\"end\"),\n                # Extract other columns:\n                f.col(\"Promoter\").alias(\"gene_name\"),\n                f.col(\"Tissue_type\").alias(\"tissue\"),\n            )\n            # Lifting over to GRCh38 interval 1:\n            .transform(\n                lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n            )\n            .select(\n                \"chrom\",\n                f.col(\"mapped_start\").alias(\"start\"),\n                f.col(\"mapped_end\").alias(\"end\"),\n                f.explode(f.split(f.col(\"gene_name\"), \";\")).alias(\"gene_name\"),\n                \"tissue\",\n            )\n            .alias(\"intervals\")\n            # Joining with genes:\n            .join(\n                gene_index.symbols_lut().alias(\"genes\"),\n                on=[f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\")],\n                how=\"inner\",\n            )\n            # Finalize dataset:\n            .select(\n                \"chromosome\",\n                f.col(\"intervals.start\").alias(\"start\"),\n                f.col(\"intervals.end\").alias(\"end\"),\n                \"geneId\",\n                f.col(\"tissue\").alias(\"biofeature\"),\n                f.lit(1.0).alias(\"score\"),\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n            )\n            .drop_duplicates()\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/jung/#otg.datasource.intervals.jung.IntervalsJung.read","title":"<code>read(spark: SparkSession, path: str) -&gt; DataFrame</code>  <code>staticmethod</code>","text":"<p>Read jung dataset.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to dataset</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>DataFrame with raw jung data</p> Source code in <code>src/otg/datasource/intervals/jung.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str) -&gt; DataFrame:\n    \"\"\"Read jung dataset.\n\n    Args:\n        spark (SparkSession): Spark session\n        path (str): Path to dataset\n\n    Returns:\n        DataFrame: DataFrame with raw jung data\n    \"\"\"\n    return spark.read.csv(path, sep=\",\", header=True)\n</code></pre>"},{"location":"python_api/datasource/intervals/thurman/","title":"Thurman et al.","text":""},{"location":"python_api/datasource/intervals/thurman/#otg.datasource.intervals.thurman.IntervalsThurman","title":"<code>otg.datasource.intervals.thurman.IntervalsThurman</code>","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Thurman et al. 2012.</p> Source code in <code>src/otg/datasource/intervals/thurman.py</code> <pre><code>class IntervalsThurman(Intervals):\n    \"\"\"Interval dataset from Thurman et al. 2012.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str) -&gt; DataFrame:\n        \"\"\"Read thurman dataset.\n\n        Args:\n            spark (SparkSession): Spark session\n            path (str): Path to dataset\n\n        Returns:\n            DataFrame: DataFrame with raw thurman data\n        \"\"\"\n        thurman_schema = t.StructType(\n            [\n                t.StructField(\"gene_chr\", t.StringType(), False),\n                t.StructField(\"gene_start\", t.IntegerType(), False),\n                t.StructField(\"gene_end\", t.IntegerType(), False),\n                t.StructField(\"gene_name\", t.StringType(), False),\n                t.StructField(\"chrom\", t.StringType(), False),\n                t.StructField(\"start\", t.IntegerType(), False),\n                t.StructField(\"end\", t.IntegerType(), False),\n                t.StructField(\"score\", t.FloatType(), False),\n            ]\n        )\n        return spark.read.csv(path, sep=\"\\t\", header=True, schema=thurman_schema)\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsThurman],\n        thurman_raw: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; IntervalsThurman:\n        \"\"\"Parse the Thurman et al. 2012 dataset.\n\n        Args:\n            thurman_raw (DataFrame): raw Thurman et al. 2019 dataset\n            gene_index (GeneIndex): gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            IntervalsThurman: Interval dataset containing Thurman et al. 2012 data\n        \"\"\"\n        dataset_name = \"thurman2012\"\n        experiment_type = \"dhscor\"\n        pmid = \"22955617\"\n\n        return cls(\n            _df=(\n                thurman_raw.select(\n                    f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").alias(\"chrom\"),\n                    \"start\",\n                    \"end\",\n                    \"gene_name\",\n                    \"score\",\n                )\n                # Lift over to the GRCh38 build:\n                .transform(\n                    lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n                )\n                .alias(\"intervals\")\n                # Map gene names to gene IDs:\n                .join(\n                    gene_index.symbols_lut().alias(\"genes\"),\n                    on=[\n                        f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\"),\n                        f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                    ],\n                    how=\"inner\",\n                )\n                # Select relevant columns and add constant columns:\n                .select(\n                    f.col(\"chrom\").alias(\"chromosome\"),\n                    f.col(\"mapped_start\").alias(\"start\"),\n                    f.col(\"mapped_end\").alias(\"end\"),\n                    \"geneId\",\n                    f.col(\"score\").cast(t.DoubleType()).alias(\"resourceScore\"),\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                )\n                .distinct()\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/thurman/#otg.datasource.intervals.thurman.IntervalsThurman.parse","title":"<code>parse(thurman_raw: DataFrame, gene_index: GeneIndex, lift: LiftOverSpark) -&gt; IntervalsThurman</code>  <code>classmethod</code>","text":"<p>Parse the Thurman et al. 2012 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>thurman_raw</code> <code>DataFrame</code> <p>raw Thurman et al. 2019 dataset</p> required <code>gene_index</code> <code>GeneIndex</code> <p>gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>IntervalsThurman</code> <code>IntervalsThurman</code> <p>Interval dataset containing Thurman et al. 2012 data</p> Source code in <code>src/otg/datasource/intervals/thurman.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsThurman],\n    thurman_raw: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; IntervalsThurman:\n    \"\"\"Parse the Thurman et al. 2012 dataset.\n\n    Args:\n        thurman_raw (DataFrame): raw Thurman et al. 2019 dataset\n        gene_index (GeneIndex): gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        IntervalsThurman: Interval dataset containing Thurman et al. 2012 data\n    \"\"\"\n    dataset_name = \"thurman2012\"\n    experiment_type = \"dhscor\"\n    pmid = \"22955617\"\n\n    return cls(\n        _df=(\n            thurman_raw.select(\n                f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").alias(\"chrom\"),\n                \"start\",\n                \"end\",\n                \"gene_name\",\n                \"score\",\n            )\n            # Lift over to the GRCh38 build:\n            .transform(\n                lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n            )\n            .alias(\"intervals\")\n            # Map gene names to gene IDs:\n            .join(\n                gene_index.symbols_lut().alias(\"genes\"),\n                on=[\n                    f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\"),\n                    f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                ],\n                how=\"inner\",\n            )\n            # Select relevant columns and add constant columns:\n            .select(\n                f.col(\"chrom\").alias(\"chromosome\"),\n                f.col(\"mapped_start\").alias(\"start\"),\n                f.col(\"mapped_end\").alias(\"end\"),\n                \"geneId\",\n                f.col(\"score\").cast(t.DoubleType()).alias(\"resourceScore\"),\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n            )\n            .distinct()\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/thurman/#otg.datasource.intervals.thurman.IntervalsThurman.read","title":"<code>read(spark: SparkSession, path: str) -&gt; DataFrame</code>  <code>staticmethod</code>","text":"<p>Read thurman dataset.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to dataset</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>DataFrame with raw thurman data</p> Source code in <code>src/otg/datasource/intervals/thurman.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str) -&gt; DataFrame:\n    \"\"\"Read thurman dataset.\n\n    Args:\n        spark (SparkSession): Spark session\n        path (str): Path to dataset\n\n    Returns:\n        DataFrame: DataFrame with raw thurman data\n    \"\"\"\n    thurman_schema = t.StructType(\n        [\n            t.StructField(\"gene_chr\", t.StringType(), False),\n            t.StructField(\"gene_start\", t.IntegerType(), False),\n            t.StructField(\"gene_end\", t.IntegerType(), False),\n            t.StructField(\"gene_name\", t.StringType(), False),\n            t.StructField(\"chrom\", t.StringType(), False),\n            t.StructField(\"start\", t.IntegerType(), False),\n            t.StructField(\"end\", t.IntegerType(), False),\n            t.StructField(\"score\", t.FloatType(), False),\n        ]\n    )\n    return spark.read.csv(path, sep=\"\\t\", header=True, schema=thurman_schema)\n</code></pre>"},{"location":"python_api/datasource/open_targets/_open_targets/","title":"Open Targets","text":"<p>The Open Targets Platform is a comprehensive resource that aims to aggregate and harmonise various types of data to facilitate the identification, prioritisation, and validation of drug targets. By integrating publicly available datasets including data generated by the Open Targets consortium, the Platform builds and scores target-disease associations to assist in drug target identification and prioritisation. It also integrates relevant annotation information about targets, diseases, phenotypes, and drugs, as well as their most relevant relationships.</p> <p>Genomic data from Open Targets integrates human genome-wide association studies (GWAS) and functional genomics data including gene expression, protein abundance, chromatin interaction and conformation data from a wide range of cell types and tissues to make robust connections between GWAS-associated loci, variants and likely causal genes.</p>"},{"location":"python_api/datasource/open_targets/l2g_gold_standard/","title":"L2G Gold Standard","text":""},{"location":"python_api/datasource/open_targets/l2g_gold_standard/#otg.datasource.open_targets.l2g_gold_standard.OpenTargetsL2GGoldStandard","title":"<code>otg.datasource.open_targets.l2g_gold_standard.OpenTargetsL2GGoldStandard</code>","text":"<p>Parser for OTGenetics locus to gene gold standards curation.</p> The curation is processed to generate a dataset with 2 labels <ul> <li>Gold Standard Positive (GSP): When the lead variant is part of a curated list of GWAS loci with known gene-trait associations.</li> <li>Gold Standard Negative (GSN): When the lead variant is not part of a curated list of GWAS loci with known gene-trait associations but is in the vicinity of a gene's TSS.</li> </ul> Source code in <code>src/otg/datasource/open_targets/l2g_gold_standard.py</code> <pre><code>class OpenTargetsL2GGoldStandard:\n    \"\"\"Parser for OTGenetics locus to gene gold standards curation.\n\n    The curation is processed to generate a dataset with 2 labels:\n        - Gold Standard Positive (GSP): When the lead variant is part of a curated list of GWAS loci with known gene-trait associations.\n        - Gold Standard Negative (GSN): When the lead variant is not part of a curated list of GWAS loci with known gene-trait associations but is in the vicinity of a gene's TSS.\n    \"\"\"\n\n    LOCUS_TO_GENE_WINDOW = 500_000\n\n    @classmethod\n    def parse_positive_curation(\n        cls: Type[OpenTargetsL2GGoldStandard], gold_standard_curation: DataFrame\n    ) -&gt; DataFrame:\n        \"\"\"Parse positive set from gold standard curation.\n\n        Args:\n            gold_standard_curation (DataFrame): Gold standard curation dataframe\n\n        Returns:\n            DataFrame: Positive set\n        \"\"\"\n        return (\n            gold_standard_curation.filter(\n                f.col(\"gold_standard_info.highest_confidence\").isin([\"High\", \"Medium\"])\n            )\n            .select(\n                f.col(\"association_info.otg_id\").alias(\"studyId\"),\n                f.col(\"gold_standard_info.gene_id\").alias(\"geneId\"),\n                f.concat_ws(\n                    \"_\",\n                    f.col(\"sentinel_variant.locus_GRCh38.chromosome\"),\n                    f.col(\"sentinel_variant.locus_GRCh38.position\"),\n                    f.col(\"sentinel_variant.alleles.reference\"),\n                    f.col(\"sentinel_variant.alleles.alternative\"),\n                ).alias(\"variantId\"),\n                f.col(\"metadata.set_label\").alias(\"source\"),\n            )\n            .withColumn(\n                \"studyLocusId\",\n                StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\")),\n            )\n            .groupBy(\"studyLocusId\", \"studyId\", \"variantId\", \"geneId\")\n            .agg(f.collect_set(\"source\").alias(\"sources\"))\n        )\n\n    @classmethod\n    def expand_gold_standard_with_negatives(\n        cls: Type[OpenTargetsL2GGoldStandard], positive_set: DataFrame, v2g: V2G\n    ) -&gt; DataFrame:\n        \"\"\"Create full set of positive and negative evidence of locus to gene associations.\n\n        Negative evidence consists of all genes within a window of 500kb of the lead variant that are not in the positive set.\n\n        Args:\n            positive_set (DataFrame): Positive set from curation\n            v2g (V2G): Variant to gene dataset to bring distance between a variant and a gene's TSS\n\n        Returns:\n            DataFrame: Full set of positive and negative evidence of locus to gene associations\n        \"\"\"\n        return (\n            positive_set.withColumnRenamed(\"geneId\", \"curated_geneId\")\n            .join(\n                v2g.df.selectExpr(\n                    \"variantId\", \"geneId as non_curated_geneId\", \"distance\"\n                ).filter(f.col(\"distance\") &lt;= cls.LOCUS_TO_GENE_WINDOW),\n                on=\"variantId\",\n                how=\"left\",\n            )\n            .withColumn(\n                \"goldStandardSet\",\n                f.when(\n                    (f.col(\"curated_geneId\") == f.col(\"non_curated_geneId\"))\n                    # to keep the positives that are outside the v2g dataset\n                    | (f.col(\"non_curated_geneId\").isNull()),\n                    f.lit(L2GGoldStandard.GS_POSITIVE_LABEL),\n                ).otherwise(L2GGoldStandard.GS_NEGATIVE_LABEL),\n            )\n            .withColumn(\n                \"geneId\",\n                f.when(\n                    f.col(\"goldStandardSet\") == L2GGoldStandard.GS_POSITIVE_LABEL,\n                    f.col(\"curated_geneId\"),\n                ).otherwise(f.col(\"non_curated_geneId\")),\n            )\n            .drop(\"distance\", \"curated_geneId\", \"non_curated_geneId\")\n        )\n\n    @classmethod\n    def as_l2g_gold_standard(\n        cls: type[OpenTargetsL2GGoldStandard],\n        gold_standard_curation: DataFrame,\n        v2g: V2G,\n    ) -&gt; L2GGoldStandard:\n        \"\"\"Initialise L2GGoldStandard from source dataset.\n\n        Args:\n            gold_standard_curation (DataFrame): Gold standard curation dataframe, extracted from https://github.com/opentargets/genetics-gold-standards\n            v2g (V2G): Variant to gene dataset to bring distance between a variant and a gene's TSS\n\n        Returns:\n            L2GGoldStandard: L2G Gold Standard dataset. False negatives have not yet been removed.\n        \"\"\"\n        return L2GGoldStandard(\n            _df=cls.parse_positive_curation(gold_standard_curation)\n            .transform(cls.expand_gold_standard_with_negatives, v2g)\n            .drop(\n                \"studyId\",\n            ),\n            _schema=L2GGoldStandard.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/open_targets/l2g_gold_standard/#otg.datasource.open_targets.l2g_gold_standard.OpenTargetsL2GGoldStandard.as_l2g_gold_standard","title":"<code>as_l2g_gold_standard(gold_standard_curation: DataFrame, v2g: V2G) -&gt; L2GGoldStandard</code>  <code>classmethod</code>","text":"<p>Initialise L2GGoldStandard from source dataset.</p> <p>Parameters:</p> Name Type Description Default <code>gold_standard_curation</code> <code>DataFrame</code> <p>Gold standard curation dataframe, extracted from https://github.com/opentargets/genetics-gold-standards</p> required <code>v2g</code> <code>V2G</code> <p>Variant to gene dataset to bring distance between a variant and a gene's TSS</p> required <p>Returns:</p> Name Type Description <code>L2GGoldStandard</code> <code>L2GGoldStandard</code> <p>L2G Gold Standard dataset. False negatives have not yet been removed.</p> Source code in <code>src/otg/datasource/open_targets/l2g_gold_standard.py</code> <pre><code>@classmethod\ndef as_l2g_gold_standard(\n    cls: type[OpenTargetsL2GGoldStandard],\n    gold_standard_curation: DataFrame,\n    v2g: V2G,\n) -&gt; L2GGoldStandard:\n    \"\"\"Initialise L2GGoldStandard from source dataset.\n\n    Args:\n        gold_standard_curation (DataFrame): Gold standard curation dataframe, extracted from https://github.com/opentargets/genetics-gold-standards\n        v2g (V2G): Variant to gene dataset to bring distance between a variant and a gene's TSS\n\n    Returns:\n        L2GGoldStandard: L2G Gold Standard dataset. False negatives have not yet been removed.\n    \"\"\"\n    return L2GGoldStandard(\n        _df=cls.parse_positive_curation(gold_standard_curation)\n        .transform(cls.expand_gold_standard_with_negatives, v2g)\n        .drop(\n            \"studyId\",\n        ),\n        _schema=L2GGoldStandard.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/open_targets/l2g_gold_standard/#otg.datasource.open_targets.l2g_gold_standard.OpenTargetsL2GGoldStandard.expand_gold_standard_with_negatives","title":"<code>expand_gold_standard_with_negatives(positive_set: DataFrame, v2g: V2G) -&gt; DataFrame</code>  <code>classmethod</code>","text":"<p>Create full set of positive and negative evidence of locus to gene associations.</p> <p>Negative evidence consists of all genes within a window of 500kb of the lead variant that are not in the positive set.</p> <p>Parameters:</p> Name Type Description Default <code>positive_set</code> <code>DataFrame</code> <p>Positive set from curation</p> required <code>v2g</code> <code>V2G</code> <p>Variant to gene dataset to bring distance between a variant and a gene's TSS</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Full set of positive and negative evidence of locus to gene associations</p> Source code in <code>src/otg/datasource/open_targets/l2g_gold_standard.py</code> <pre><code>@classmethod\ndef expand_gold_standard_with_negatives(\n    cls: Type[OpenTargetsL2GGoldStandard], positive_set: DataFrame, v2g: V2G\n) -&gt; DataFrame:\n    \"\"\"Create full set of positive and negative evidence of locus to gene associations.\n\n    Negative evidence consists of all genes within a window of 500kb of the lead variant that are not in the positive set.\n\n    Args:\n        positive_set (DataFrame): Positive set from curation\n        v2g (V2G): Variant to gene dataset to bring distance between a variant and a gene's TSS\n\n    Returns:\n        DataFrame: Full set of positive and negative evidence of locus to gene associations\n    \"\"\"\n    return (\n        positive_set.withColumnRenamed(\"geneId\", \"curated_geneId\")\n        .join(\n            v2g.df.selectExpr(\n                \"variantId\", \"geneId as non_curated_geneId\", \"distance\"\n            ).filter(f.col(\"distance\") &lt;= cls.LOCUS_TO_GENE_WINDOW),\n            on=\"variantId\",\n            how=\"left\",\n        )\n        .withColumn(\n            \"goldStandardSet\",\n            f.when(\n                (f.col(\"curated_geneId\") == f.col(\"non_curated_geneId\"))\n                # to keep the positives that are outside the v2g dataset\n                | (f.col(\"non_curated_geneId\").isNull()),\n                f.lit(L2GGoldStandard.GS_POSITIVE_LABEL),\n            ).otherwise(L2GGoldStandard.GS_NEGATIVE_LABEL),\n        )\n        .withColumn(\n            \"geneId\",\n            f.when(\n                f.col(\"goldStandardSet\") == L2GGoldStandard.GS_POSITIVE_LABEL,\n                f.col(\"curated_geneId\"),\n            ).otherwise(f.col(\"non_curated_geneId\")),\n        )\n        .drop(\"distance\", \"curated_geneId\", \"non_curated_geneId\")\n    )\n</code></pre>"},{"location":"python_api/datasource/open_targets/l2g_gold_standard/#otg.datasource.open_targets.l2g_gold_standard.OpenTargetsL2GGoldStandard.parse_positive_curation","title":"<code>parse_positive_curation(gold_standard_curation: DataFrame) -&gt; DataFrame</code>  <code>classmethod</code>","text":"<p>Parse positive set from gold standard curation.</p> <p>Parameters:</p> Name Type Description Default <code>gold_standard_curation</code> <code>DataFrame</code> <p>Gold standard curation dataframe</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Positive set</p> Source code in <code>src/otg/datasource/open_targets/l2g_gold_standard.py</code> <pre><code>@classmethod\ndef parse_positive_curation(\n    cls: Type[OpenTargetsL2GGoldStandard], gold_standard_curation: DataFrame\n) -&gt; DataFrame:\n    \"\"\"Parse positive set from gold standard curation.\n\n    Args:\n        gold_standard_curation (DataFrame): Gold standard curation dataframe\n\n    Returns:\n        DataFrame: Positive set\n    \"\"\"\n    return (\n        gold_standard_curation.filter(\n            f.col(\"gold_standard_info.highest_confidence\").isin([\"High\", \"Medium\"])\n        )\n        .select(\n            f.col(\"association_info.otg_id\").alias(\"studyId\"),\n            f.col(\"gold_standard_info.gene_id\").alias(\"geneId\"),\n            f.concat_ws(\n                \"_\",\n                f.col(\"sentinel_variant.locus_GRCh38.chromosome\"),\n                f.col(\"sentinel_variant.locus_GRCh38.position\"),\n                f.col(\"sentinel_variant.alleles.reference\"),\n                f.col(\"sentinel_variant.alleles.alternative\"),\n            ).alias(\"variantId\"),\n            f.col(\"metadata.set_label\").alias(\"source\"),\n        )\n        .withColumn(\n            \"studyLocusId\",\n            StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\")),\n        )\n        .groupBy(\"studyLocusId\", \"studyId\", \"variantId\", \"geneId\")\n        .agg(f.collect_set(\"source\").alias(\"sources\"))\n    )\n</code></pre>"},{"location":"python_api/datasource/open_targets/target/","title":"Target","text":""},{"location":"python_api/datasource/open_targets/target/#otg.datasource.open_targets.target.OpenTargetsTarget","title":"<code>otg.datasource.open_targets.target.OpenTargetsTarget</code>","text":"<p>Parser for OTPlatform target dataset.</p> <p>Genomic data from Open Targets provides gene identification and genomic coordinates that are integrated into the gene index of our ETL pipeline.</p> <p>The EMBL-EBI Ensembl database is used as a source for human targets in the Platform, with the Ensembl gene ID as the primary identifier. The criteria for target inclusion is: - Genes from all biotypes encoded in canonical chromosomes - Genes in alternative assemblies encoding for a reviewed protein product.</p> Source code in <code>src/otg/datasource/open_targets/target.py</code> <pre><code>class OpenTargetsTarget:\n    \"\"\"Parser for OTPlatform target dataset.\n\n    Genomic data from Open Targets provides gene identification and genomic coordinates that are integrated into the gene index of our ETL pipeline.\n\n    The EMBL-EBI Ensembl database is used as a source for human targets in the Platform, with the Ensembl gene ID as the primary identifier. The criteria for target inclusion is:\n    - Genes from all biotypes encoded in canonical chromosomes\n    - Genes in alternative assemblies encoding for a reviewed protein product.\n    \"\"\"\n\n    @staticmethod\n    def _get_gene_tss(strand_col: Column, start_col: Column, end_col: Column) -&gt; Column:\n        \"\"\"Returns the TSS of a gene based on its orientation.\n\n        Args:\n            strand_col (Column): Column containing 1 if the coding strand of the gene is forward, and -1 if it is reverse.\n            start_col (Column): Column containing the start position of the gene.\n            end_col (Column): Column containing the end position of the gene.\n\n        Returns:\n            Column: Column containing the TSS of the gene.\n\n        Examples:\n            &gt;&gt;&gt; df = spark.createDataFrame([{\"strand\": 1, \"start\": 100, \"end\": 200}, {\"strand\": -1, \"start\": 100, \"end\": 200}])\n            &gt;&gt;&gt; df.withColumn(\"tss\", OpenTargetsTarget._get_gene_tss(f.col(\"strand\"), f.col(\"start\"), f.col(\"end\"))).show()\n            +---+-----+------+---+\n            |end|start|strand|tss|\n            +---+-----+------+---+\n            |200|  100|     1|100|\n            |200|  100|    -1|200|\n            +---+-----+------+---+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return f.when(strand_col == 1, start_col).when(strand_col == -1, end_col)\n\n    @classmethod\n    def as_gene_index(\n        cls: type[OpenTargetsTarget], target_index: DataFrame\n    ) -&gt; GeneIndex:\n        \"\"\"Initialise GeneIndex from source dataset.\n\n        Args:\n            target_index (DataFrame): Target index dataframe\n\n        Returns:\n            GeneIndex: Gene index dataset\n        \"\"\"\n        return GeneIndex(\n            _df=target_index.select(\n                f.coalesce(f.col(\"id\"), f.lit(\"unknown\")).alias(\"geneId\"),\n                \"approvedSymbol\",\n                \"approvedName\",\n                \"biotype\",\n                f.col(\"obsoleteSymbols.label\").alias(\"obsoleteSymbols\"),\n                f.coalesce(f.col(\"genomicLocation.chromosome\"), f.lit(\"unknown\")).alias(\n                    \"chromosome\"\n                ),\n                OpenTargetsTarget._get_gene_tss(\n                    f.col(\"genomicLocation.strand\"),\n                    f.col(\"genomicLocation.start\"),\n                    f.col(\"genomicLocation.end\"),\n                ).alias(\"tss\"),\n                f.col(\"genomicLocation.start\").alias(\"start\"),\n                f.col(\"genomicLocation.end\").alias(\"end\"),\n                f.col(\"genomicLocation.strand\").alias(\"strand\"),\n            ),\n            _schema=GeneIndex.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/open_targets/target/#otg.datasource.open_targets.target.OpenTargetsTarget.as_gene_index","title":"<code>as_gene_index(target_index: DataFrame) -&gt; GeneIndex</code>  <code>classmethod</code>","text":"<p>Initialise GeneIndex from source dataset.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>DataFrame</code> <p>Target index dataframe</p> required <p>Returns:</p> Name Type Description <code>GeneIndex</code> <code>GeneIndex</code> <p>Gene index dataset</p> Source code in <code>src/otg/datasource/open_targets/target.py</code> <pre><code>@classmethod\ndef as_gene_index(\n    cls: type[OpenTargetsTarget], target_index: DataFrame\n) -&gt; GeneIndex:\n    \"\"\"Initialise GeneIndex from source dataset.\n\n    Args:\n        target_index (DataFrame): Target index dataframe\n\n    Returns:\n        GeneIndex: Gene index dataset\n    \"\"\"\n    return GeneIndex(\n        _df=target_index.select(\n            f.coalesce(f.col(\"id\"), f.lit(\"unknown\")).alias(\"geneId\"),\n            \"approvedSymbol\",\n            \"approvedName\",\n            \"biotype\",\n            f.col(\"obsoleteSymbols.label\").alias(\"obsoleteSymbols\"),\n            f.coalesce(f.col(\"genomicLocation.chromosome\"), f.lit(\"unknown\")).alias(\n                \"chromosome\"\n            ),\n            OpenTargetsTarget._get_gene_tss(\n                f.col(\"genomicLocation.strand\"),\n                f.col(\"genomicLocation.start\"),\n                f.col(\"genomicLocation.end\"),\n            ).alias(\"tss\"),\n            f.col(\"genomicLocation.start\").alias(\"start\"),\n            f.col(\"genomicLocation.end\").alias(\"end\"),\n            f.col(\"genomicLocation.strand\").alias(\"strand\"),\n        ),\n        _schema=GeneIndex.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/ukbiobank/_ukbiobank/","title":"UK Biobank","text":"<p>The UK Biobank is a large-scale biomedical database and research resource that contains a diverse range of in-depth information from 500,000 volunteers in the United Kingdom. Its genomic data comprises whole-genome sequencing for a subset of participants, along with genotyping arrays for the entire cohort. The data has been a cornerstone for numerous genome-wide association studies (GWAS) and other genetic analyses, advancing our understanding of human health and disease.</p> <p>Recent efforts to rapidly and systematically apply established GWAS methods to all available data fields in UK Biobank have made available large repositories of summary statistics. To leverage these data disease locus discovery, we used full summary statistics from: The Neale lab Round 2 (N=2139). - These analyses applied GWAS (implemented in Hail) to all data fields using imputed genotypes from HRC as released by UK Biobank in May 2017, consisting of 337,199 individuals post-QC. Full details of the Neale lab GWAS implementation are available here. We have remove all ICD-10 related traits from the Neale data to reduce overlap with the SAIGE results. - http://www.nealelab.is/uk-biobank/ The University of Michigan SAIGE analysis (N=1281). - The SAIGE analysis uses PheCode derived phenotypes and applies a new method that \"provides accurate P values even when case-control ratios are extremely unbalanced\". See Zhou et al. (2018) for further details. - https://pubmed.ncbi.nlm.nih.gov/30104761/</p>"},{"location":"python_api/datasource/ukbiobank/study_index/","title":"Study Index","text":""},{"location":"python_api/datasource/ukbiobank/study_index/#otg.datasource.ukbiobank.study_index.UKBiobankStudyIndex","title":"<code>otg.datasource.ukbiobank.study_index.UKBiobankStudyIndex</code>","text":"<p>             Bases: <code>StudyIndex</code></p> <p>Study index dataset from UKBiobank.</p> <p>The following information is extracted:</p> <ul> <li>studyId</li> <li>pubmedId</li> <li>publicationDate</li> <li>publicationJournal</li> <li>publicationTitle</li> <li>publicationFirstAuthor</li> <li>traitFromSource</li> <li>ancestry_discoverySamples</li> <li>ancestry_replicationSamples</li> <li>initialSampleSize</li> <li>nCases</li> <li>replicationSamples</li> </ul> <p>Some fields are populated as constants, such as projectID, studyType, and initial sample size.</p> Source code in <code>src/otg/datasource/ukbiobank/study_index.py</code> <pre><code>class UKBiobankStudyIndex(StudyIndex):\n    \"\"\"Study index dataset from UKBiobank.\n\n    The following information is extracted:\n\n    - studyId\n    - pubmedId\n    - publicationDate\n    - publicationJournal\n    - publicationTitle\n    - publicationFirstAuthor\n    - traitFromSource\n    - ancestry_discoverySamples\n    - ancestry_replicationSamples\n    - initialSampleSize\n    - nCases\n    - replicationSamples\n\n    Some fields are populated as constants, such as projectID, studyType, and initial sample size.\n    \"\"\"\n\n    @classmethod\n    def from_source(\n        cls: type[UKBiobankStudyIndex],\n        ukbiobank_studies: DataFrame,\n    ) -&gt; UKBiobankStudyIndex:\n        \"\"\"This function ingests study level metadata from UKBiobank.\n\n        The University of Michigan SAIGE analysis (N=1281) utilized PheCode derived phenotypes and a novel method that ensures accurate P values, even with highly unbalanced case-control ratios (Zhou et al., 2018).\n\n        The Neale lab Round 2 study (N=2139) used GWAS with imputed genotypes from HRC to analyze all data fields in UK Biobank, excluding ICD-10 related traits to reduce overlap with the SAIGE results.\n\n        Args:\n            ukbiobank_studies (DataFrame): UKBiobank study manifest file loaded in spark session.\n\n        Returns:\n            UKBiobankStudyIndex: Annotated UKBiobank study table.\n        \"\"\"\n        return UKBiobankStudyIndex(\n            _df=(\n                ukbiobank_studies.select(\n                    f.col(\"code\").alias(\"studyId\"),\n                    f.lit(\"UKBiobank\").alias(\"projectId\"),\n                    f.lit(\"gwas\").alias(\"studyType\"),\n                    f.col(\"trait\").alias(\"traitFromSource\"),\n                    # Make publication and ancestry schema columns.\n                    f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"30104761\").alias(\n                        \"pubmedId\"\n                    ),\n                    f.when(\n                        f.col(\"code\").startswith(\"SAIGE_\"),\n                        \"Efficiently controlling for case-control imbalance and sample relatedness in large-scale genetic association studies\",\n                    )\n                    .otherwise(None)\n                    .alias(\"publicationTitle\"),\n                    f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Wei Zhou\").alias(\n                        \"publicationFirstAuthor\"\n                    ),\n                    f.when(f.col(\"code\").startswith(\"NEALE2_\"), \"2018-08-01\")\n                    .otherwise(\"2018-10-24\")\n                    .alias(\"publicationDate\"),\n                    f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Nature Genetics\").alias(\n                        \"publicationJournal\"\n                    ),\n                    f.col(\"n_total\").cast(\"string\").alias(\"initialSampleSize\"),\n                    f.col(\"n_cases\").cast(\"long\").alias(\"nCases\"),\n                    f.array(\n                        f.struct(\n                            f.col(\"n_total\").cast(\"long\").alias(\"sampleSize\"),\n                            f.concat(f.lit(\"European=\"), f.col(\"n_total\")).alias(\n                                \"ancestry\"\n                            ),\n                        )\n                    ).alias(\"discoverySamples\"),\n                    f.col(\"in_path\").alias(\"summarystatsLocation\"),\n                    f.lit(True).alias(\"hasSumstats\"),\n                )\n                .withColumn(\n                    \"traitFromSource\",\n                    f.when(\n                        f.col(\"traitFromSource\").contains(\":\"),\n                        f.concat(\n                            f.initcap(\n                                f.split(f.col(\"traitFromSource\"), \": \").getItem(1)\n                            ),\n                            f.lit(\" | \"),\n                            f.lower(f.split(f.col(\"traitFromSource\"), \": \").getItem(0)),\n                        ),\n                    ).otherwise(f.col(\"traitFromSource\")),\n                )\n                .withColumn(\n                    \"ldPopulationStructure\",\n                    cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n                )\n            ),\n            _schema=UKBiobankStudyIndex.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/ukbiobank/study_index/#otg.datasource.ukbiobank.study_index.UKBiobankStudyIndex.from_source","title":"<code>from_source(ukbiobank_studies: DataFrame) -&gt; UKBiobankStudyIndex</code>  <code>classmethod</code>","text":"<p>This function ingests study level metadata from UKBiobank.</p> <p>The University of Michigan SAIGE analysis (N=1281) utilized PheCode derived phenotypes and a novel method that ensures accurate P values, even with highly unbalanced case-control ratios (Zhou et al., 2018).</p> <p>The Neale lab Round 2 study (N=2139) used GWAS with imputed genotypes from HRC to analyze all data fields in UK Biobank, excluding ICD-10 related traits to reduce overlap with the SAIGE results.</p> <p>Parameters:</p> Name Type Description Default <code>ukbiobank_studies</code> <code>DataFrame</code> <p>UKBiobank study manifest file loaded in spark session.</p> required <p>Returns:</p> Name Type Description <code>UKBiobankStudyIndex</code> <code>UKBiobankStudyIndex</code> <p>Annotated UKBiobank study table.</p> Source code in <code>src/otg/datasource/ukbiobank/study_index.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[UKBiobankStudyIndex],\n    ukbiobank_studies: DataFrame,\n) -&gt; UKBiobankStudyIndex:\n    \"\"\"This function ingests study level metadata from UKBiobank.\n\n    The University of Michigan SAIGE analysis (N=1281) utilized PheCode derived phenotypes and a novel method that ensures accurate P values, even with highly unbalanced case-control ratios (Zhou et al., 2018).\n\n    The Neale lab Round 2 study (N=2139) used GWAS with imputed genotypes from HRC to analyze all data fields in UK Biobank, excluding ICD-10 related traits to reduce overlap with the SAIGE results.\n\n    Args:\n        ukbiobank_studies (DataFrame): UKBiobank study manifest file loaded in spark session.\n\n    Returns:\n        UKBiobankStudyIndex: Annotated UKBiobank study table.\n    \"\"\"\n    return UKBiobankStudyIndex(\n        _df=(\n            ukbiobank_studies.select(\n                f.col(\"code\").alias(\"studyId\"),\n                f.lit(\"UKBiobank\").alias(\"projectId\"),\n                f.lit(\"gwas\").alias(\"studyType\"),\n                f.col(\"trait\").alias(\"traitFromSource\"),\n                # Make publication and ancestry schema columns.\n                f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"30104761\").alias(\n                    \"pubmedId\"\n                ),\n                f.when(\n                    f.col(\"code\").startswith(\"SAIGE_\"),\n                    \"Efficiently controlling for case-control imbalance and sample relatedness in large-scale genetic association studies\",\n                )\n                .otherwise(None)\n                .alias(\"publicationTitle\"),\n                f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Wei Zhou\").alias(\n                    \"publicationFirstAuthor\"\n                ),\n                f.when(f.col(\"code\").startswith(\"NEALE2_\"), \"2018-08-01\")\n                .otherwise(\"2018-10-24\")\n                .alias(\"publicationDate\"),\n                f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Nature Genetics\").alias(\n                    \"publicationJournal\"\n                ),\n                f.col(\"n_total\").cast(\"string\").alias(\"initialSampleSize\"),\n                f.col(\"n_cases\").cast(\"long\").alias(\"nCases\"),\n                f.array(\n                    f.struct(\n                        f.col(\"n_total\").cast(\"long\").alias(\"sampleSize\"),\n                        f.concat(f.lit(\"European=\"), f.col(\"n_total\")).alias(\n                            \"ancestry\"\n                        ),\n                    )\n                ).alias(\"discoverySamples\"),\n                f.col(\"in_path\").alias(\"summarystatsLocation\"),\n                f.lit(True).alias(\"hasSumstats\"),\n            )\n            .withColumn(\n                \"traitFromSource\",\n                f.when(\n                    f.col(\"traitFromSource\").contains(\":\"),\n                    f.concat(\n                        f.initcap(\n                            f.split(f.col(\"traitFromSource\"), \": \").getItem(1)\n                        ),\n                        f.lit(\" | \"),\n                        f.lower(f.split(f.col(\"traitFromSource\"), \": \").getItem(0)),\n                    ),\n                ).otherwise(f.col(\"traitFromSource\")),\n            )\n            .withColumn(\n                \"ldPopulationStructure\",\n                cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n            )\n        ),\n        _schema=UKBiobankStudyIndex.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/_method/","title":"Method","text":"<p>TBC</p>"},{"location":"python_api/method/clumping/","title":"Clumping","text":"<p>Clumping is a commonly used post-processing method that allows for identification of independent association signals from GWAS summary statistics and curated associations. This process is critical because of the complex linkage disequilibrium (LD) structure in human populations, which can result in multiple statistically significant associations within the same genomic region. Clumping methods help reduce redundancy in GWAS results and ensure that each reported association represents an independent signal.</p> <p>We have implemented 2 clumping methods:</p>"},{"location":"python_api/method/clumping/#otg.method.clump.LDclumping","title":"<code>otg.method.clump.LDclumping</code>","text":"<p>LD clumping reports the most significant genetic associations in a region in terms of a smaller number of \u201cclumps\u201d of genetically linked SNPs.</p> Source code in <code>src/otg/method/clump.py</code> <pre><code>class LDclumping:\n    \"\"\"LD clumping reports the most significant genetic associations in a region in terms of a smaller number of \u201cclumps\u201d of genetically linked SNPs.\"\"\"\n\n    @staticmethod\n    def _is_lead_linked(\n        study_id: Column,\n        variant_id: Column,\n        p_value_exponent: Column,\n        p_value_mantissa: Column,\n        ld_set: Column,\n    ) -&gt; Column:\n        \"\"\"Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.\n\n        Args:\n            study_id (Column): studyId\n            variant_id (Column): Lead variant id\n            p_value_exponent (Column): p-value exponent\n            p_value_mantissa (Column): p-value mantissa\n            ld_set (Column): Array of variants in LD with the lead variant\n\n        Returns:\n            Column: Boolean in which True indicates that the lead is linked to another tag in the same dataset.\n        \"\"\"\n        leads_in_study = f.collect_set(variant_id).over(Window.partitionBy(study_id))\n        tags_in_studylocus = f.array_union(\n            # Get all tag variants from the credible set per studyLocusId\n            f.transform(ld_set, lambda x: x.tagVariantId),\n            # And append the lead variant so that the intersection is the same for all studyLocusIds in a study\n            f.array(variant_id),\n        )\n        intersect_lead_tags = f.array_sort(\n            f.array_intersect(leads_in_study, tags_in_studylocus)\n        )\n        return (\n            # If the lead is in the credible set, we rank the peaks by p-value\n            f.when(\n                f.size(intersect_lead_tags) &gt; 0,\n                f.row_number().over(\n                    Window.partitionBy(study_id, intersect_lead_tags).orderBy(\n                        p_value_exponent, p_value_mantissa\n                    )\n                )\n                &gt; 1,\n            )\n            # If the intersection is empty (lead is not in the credible set or cred set is empty), the association is not linked\n            .otherwise(f.lit(False))\n        )\n\n    @classmethod\n    def clump(cls: type[LDclumping], associations: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Perform clumping on studyLocus dataset.\n\n        Args:\n            associations (StudyLocus): StudyLocus dataset\n\n        Returns:\n            StudyLocus: including flag and removing locus information for LD clumped loci.\n        \"\"\"\n        return associations.clump()\n</code></pre>"},{"location":"python_api/method/clumping/#otg.method.clump.LDclumping.clump","title":"<code>clump(associations: StudyLocus) -&gt; StudyLocus</code>  <code>classmethod</code>","text":"<p>Perform clumping on studyLocus dataset.</p> <p>Parameters:</p> Name Type Description Default <code>associations</code> <code>StudyLocus</code> <p>StudyLocus dataset</p> required <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>including flag and removing locus information for LD clumped loci.</p> Source code in <code>src/otg/method/clump.py</code> <pre><code>@classmethod\ndef clump(cls: type[LDclumping], associations: StudyLocus) -&gt; StudyLocus:\n    \"\"\"Perform clumping on studyLocus dataset.\n\n    Args:\n        associations (StudyLocus): StudyLocus dataset\n\n    Returns:\n        StudyLocus: including flag and removing locus information for LD clumped loci.\n    \"\"\"\n    return associations.clump()\n</code></pre>"},{"location":"python_api/method/coloc/","title":"Coloc","text":""},{"location":"python_api/method/coloc/#otg.method.colocalisation.Coloc","title":"<code>otg.method.colocalisation.Coloc</code>","text":"<p>Calculate bayesian colocalisation based on overlapping signals from credible sets.</p> <p>Based on the R COLOC package, which uses the Bayes factors from the credible set to estimate the posterior probability of colocalisation. This method makes the simplifying assumption that only one single causal variant exists for any given trait in any genomic region.</p> Hypothesis Description H<sub>0</sub> no association with either trait in the region H<sub>1</sub> association with trait 1 only H<sub>2</sub> association with trait 2 only H<sub>3</sub> both traits are associated, but have different single causal variants H<sub>4</sub> both traits are associated and share the same single causal variant <p>Approximate Bayes factors required</p> <p>Coloc requires the availability of approximate Bayes factors (ABF) for each variant in the credible set (<code>logABF</code> column).</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>class Coloc:\n    \"\"\"Calculate bayesian colocalisation based on overlapping signals from credible sets.\n\n    Based on the [R COLOC package](https://github.com/chr1swallace/coloc/blob/main/R/claudia.R), which uses the Bayes factors from the credible set to estimate the posterior probability of colocalisation. This method makes the simplifying assumption that **only one single causal variant** exists for any given trait in any genomic region.\n\n    | Hypothesis    | Description                                                           |\n    | ------------- | --------------------------------------------------------------------- |\n    | H&lt;sub&gt;0&lt;/sub&gt; | no association with either trait in the region                        |\n    | H&lt;sub&gt;1&lt;/sub&gt; | association with trait 1 only                                         |\n    | H&lt;sub&gt;2&lt;/sub&gt; | association with trait 2 only                                         |\n    | H&lt;sub&gt;3&lt;/sub&gt; | both traits are associated, but have different single causal variants |\n    | H&lt;sub&gt;4&lt;/sub&gt; | both traits are associated and share the same single causal variant   |\n\n    !!! warning \"Approximate Bayes factors required\"\n        Coloc requires the availability of approximate Bayes factors (ABF) for each variant in the credible set (`logABF` column).\n\n    \"\"\"\n\n    @staticmethod\n    def _get_logsum(log_abf: NDArray[np.float64]) -&gt; float:\n        \"\"\"Calculates logsum of vector.\n\n        This function calculates the log of the sum of the exponentiated\n        logs taking out the max, i.e. insuring that the sum is not Inf\n\n        Args:\n            log_abf (NDArray[np.float64]): log approximate bayes factor\n\n        Returns:\n            float: logsum\n\n        Example:\n            &gt;&gt;&gt; l = [0.2, 0.1, 0.05, 0]\n            &gt;&gt;&gt; round(Coloc._get_logsum(l), 6)\n            1.476557\n        \"\"\"\n        themax = np.max(log_abf)\n        result = themax + np.log(np.sum(np.exp(log_abf - themax)))\n        return float(result)\n\n    @staticmethod\n    def _get_posteriors(all_abfs: NDArray[np.float64]) -&gt; DenseVector:\n        \"\"\"Calculate posterior probabilities for each hypothesis.\n\n        Args:\n            all_abfs (NDArray[np.float64]): h0-h4 bayes factors\n\n        Returns:\n            DenseVector: Posterior\n\n        Example:\n            &gt;&gt;&gt; l = np.array([0.2, 0.1, 0.05, 0])\n            &gt;&gt;&gt; Coloc._get_posteriors(l)\n            DenseVector([0.279, 0.2524, 0.2401, 0.2284])\n        \"\"\"\n        diff = all_abfs - Coloc._get_logsum(all_abfs)\n        abfs_posteriors = np.exp(diff)\n        return Vectors.dense(abfs_posteriors)\n\n    @classmethod\n    def colocalise(\n        cls: type[Coloc],\n        overlapping_signals: StudyLocusOverlap,\n        priorc1: float = 1e-4,\n        priorc2: float = 1e-4,\n        priorc12: float = 1e-5,\n    ) -&gt; Colocalisation:\n        \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n        Args:\n            overlapping_signals (StudyLocusOverlap): overlapping peaks\n            priorc1 (float): Prior on variant being causal for trait 1. Defaults to 1e-4.\n            priorc2 (float): Prior on variant being causal for trait 2. Defaults to 1e-4.\n            priorc12 (float): Prior on variant being causal for traits 1 and 2. Defaults to 1e-5.\n\n        Returns:\n            Colocalisation: Colocalisation results\n        \"\"\"\n        # register udfs\n        logsum = f.udf(Coloc._get_logsum, DoubleType())\n        posteriors = f.udf(Coloc._get_posteriors, VectorUDT())\n        return Colocalisation(\n            _df=(\n                overlapping_signals.df\n                # Before summing log_abf columns nulls need to be filled with 0:\n                .fillna(0, subset=[\"statistics.left_logABF\", \"statistics.right_logABF\"])\n                # Sum of log_abfs for each pair of signals\n                .withColumn(\n                    \"sum_log_abf\",\n                    f.col(\"statistics.left_logABF\") + f.col(\"statistics.right_logABF\"),\n                )\n                # Group by overlapping peak and generating dense vectors of log_abf:\n                .groupBy(\"chromosome\", \"leftStudyLocusId\", \"rightStudyLocusId\")\n                .agg(\n                    f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                    fml.array_to_vector(\n                        f.collect_list(f.col(\"statistics.left_logABF\"))\n                    ).alias(\"left_logABF\"),\n                    fml.array_to_vector(\n                        f.collect_list(f.col(\"statistics.right_logABF\"))\n                    ).alias(\"right_logABF\"),\n                    fml.array_to_vector(f.collect_list(f.col(\"sum_log_abf\"))).alias(\n                        \"sum_log_abf\"\n                    ),\n                )\n                .withColumn(\"logsum1\", logsum(f.col(\"left_logABF\")))\n                .withColumn(\"logsum2\", logsum(f.col(\"right_logABF\")))\n                .withColumn(\"logsum12\", logsum(f.col(\"sum_log_abf\")))\n                .drop(\"left_logABF\", \"right_logABF\", \"sum_log_abf\")\n                # Add priors\n                # priorc1 Prior on variant being causal for trait 1\n                .withColumn(\"priorc1\", f.lit(priorc1))\n                # priorc2 Prior on variant being causal for trait 2\n                .withColumn(\"priorc2\", f.lit(priorc2))\n                # priorc12 Prior on variant being causal for traits 1 and 2\n                .withColumn(\"priorc12\", f.lit(priorc12))\n                # h0-h2\n                .withColumn(\"lH0abf\", f.lit(0))\n                .withColumn(\"lH1abf\", f.log(f.col(\"priorc1\")) + f.col(\"logsum1\"))\n                .withColumn(\"lH2abf\", f.log(f.col(\"priorc2\")) + f.col(\"logsum2\"))\n                # h3\n                .withColumn(\"sumlogsum\", f.col(\"logsum1\") + f.col(\"logsum2\"))\n                # exclude null H3/H4s: due to sumlogsum == logsum12\n                .filter(f.col(\"sumlogsum\") != f.col(\"logsum12\"))\n                .withColumn(\"max\", f.greatest(\"sumlogsum\", \"logsum12\"))\n                .withColumn(\n                    \"logdiff\",\n                    (\n                        f.col(\"max\")\n                        + f.log(\n                            f.exp(f.col(\"sumlogsum\") - f.col(\"max\"))\n                            - f.exp(f.col(\"logsum12\") - f.col(\"max\"))\n                        )\n                    ),\n                )\n                .withColumn(\n                    \"lH3abf\",\n                    f.log(f.col(\"priorc1\"))\n                    + f.log(f.col(\"priorc2\"))\n                    + f.col(\"logdiff\"),\n                )\n                .drop(\"right_logsum\", \"left_logsum\", \"sumlogsum\", \"max\", \"logdiff\")\n                # h4\n                .withColumn(\"lH4abf\", f.log(f.col(\"priorc12\")) + f.col(\"logsum12\"))\n                # cleaning\n                .drop(\n                    \"priorc1\", \"priorc2\", \"priorc12\", \"logsum1\", \"logsum2\", \"logsum12\"\n                )\n                # posteriors\n                .withColumn(\n                    \"allABF\",\n                    fml.array_to_vector(\n                        f.array(\n                            f.col(\"lH0abf\"),\n                            f.col(\"lH1abf\"),\n                            f.col(\"lH2abf\"),\n                            f.col(\"lH3abf\"),\n                            f.col(\"lH4abf\"),\n                        )\n                    ),\n                )\n                .withColumn(\n                    \"posteriors\", fml.vector_to_array(posteriors(f.col(\"allABF\")))\n                )\n                .withColumn(\"h0\", f.col(\"posteriors\").getItem(0))\n                .withColumn(\"h1\", f.col(\"posteriors\").getItem(1))\n                .withColumn(\"h2\", f.col(\"posteriors\").getItem(2))\n                .withColumn(\"h3\", f.col(\"posteriors\").getItem(3))\n                .withColumn(\"h4\", f.col(\"posteriors\").getItem(4))\n                .withColumn(\"h4h3\", f.col(\"h4\") / f.col(\"h3\"))\n                .withColumn(\"log2h4h3\", f.log2(f.col(\"h4h3\")))\n                # clean up\n                .drop(\n                    \"posteriors\",\n                    \"allABF\",\n                    \"h4h3\",\n                    \"lH0abf\",\n                    \"lH1abf\",\n                    \"lH2abf\",\n                    \"lH3abf\",\n                    \"lH4abf\",\n                )\n                .withColumn(\"colocalisationMethod\", f.lit(\"COLOC\"))\n            ),\n            _schema=Colocalisation.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/coloc/#otg.method.colocalisation.Coloc.colocalise","title":"<code>colocalise(overlapping_signals: StudyLocusOverlap, priorc1: float = 0.0001, priorc2: float = 0.0001, priorc12: float = 1e-05) -&gt; Colocalisation</code>  <code>classmethod</code>","text":"<p>Calculate bayesian colocalisation based on overlapping signals.</p> <p>Parameters:</p> Name Type Description Default <code>overlapping_signals</code> <code>StudyLocusOverlap</code> <p>overlapping peaks</p> required <code>priorc1</code> <code>float</code> <p>Prior on variant being causal for trait 1. Defaults to 1e-4.</p> <code>0.0001</code> <code>priorc2</code> <code>float</code> <p>Prior on variant being causal for trait 2. Defaults to 1e-4.</p> <code>0.0001</code> <code>priorc12</code> <code>float</code> <p>Prior on variant being causal for traits 1 and 2. Defaults to 1e-5.</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>Colocalisation</code> <code>Colocalisation</code> <p>Colocalisation results</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>@classmethod\ndef colocalise(\n    cls: type[Coloc],\n    overlapping_signals: StudyLocusOverlap,\n    priorc1: float = 1e-4,\n    priorc2: float = 1e-4,\n    priorc12: float = 1e-5,\n) -&gt; Colocalisation:\n    \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n    Args:\n        overlapping_signals (StudyLocusOverlap): overlapping peaks\n        priorc1 (float): Prior on variant being causal for trait 1. Defaults to 1e-4.\n        priorc2 (float): Prior on variant being causal for trait 2. Defaults to 1e-4.\n        priorc12 (float): Prior on variant being causal for traits 1 and 2. Defaults to 1e-5.\n\n    Returns:\n        Colocalisation: Colocalisation results\n    \"\"\"\n    # register udfs\n    logsum = f.udf(Coloc._get_logsum, DoubleType())\n    posteriors = f.udf(Coloc._get_posteriors, VectorUDT())\n    return Colocalisation(\n        _df=(\n            overlapping_signals.df\n            # Before summing log_abf columns nulls need to be filled with 0:\n            .fillna(0, subset=[\"statistics.left_logABF\", \"statistics.right_logABF\"])\n            # Sum of log_abfs for each pair of signals\n            .withColumn(\n                \"sum_log_abf\",\n                f.col(\"statistics.left_logABF\") + f.col(\"statistics.right_logABF\"),\n            )\n            # Group by overlapping peak and generating dense vectors of log_abf:\n            .groupBy(\"chromosome\", \"leftStudyLocusId\", \"rightStudyLocusId\")\n            .agg(\n                f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                fml.array_to_vector(\n                    f.collect_list(f.col(\"statistics.left_logABF\"))\n                ).alias(\"left_logABF\"),\n                fml.array_to_vector(\n                    f.collect_list(f.col(\"statistics.right_logABF\"))\n                ).alias(\"right_logABF\"),\n                fml.array_to_vector(f.collect_list(f.col(\"sum_log_abf\"))).alias(\n                    \"sum_log_abf\"\n                ),\n            )\n            .withColumn(\"logsum1\", logsum(f.col(\"left_logABF\")))\n            .withColumn(\"logsum2\", logsum(f.col(\"right_logABF\")))\n            .withColumn(\"logsum12\", logsum(f.col(\"sum_log_abf\")))\n            .drop(\"left_logABF\", \"right_logABF\", \"sum_log_abf\")\n            # Add priors\n            # priorc1 Prior on variant being causal for trait 1\n            .withColumn(\"priorc1\", f.lit(priorc1))\n            # priorc2 Prior on variant being causal for trait 2\n            .withColumn(\"priorc2\", f.lit(priorc2))\n            # priorc12 Prior on variant being causal for traits 1 and 2\n            .withColumn(\"priorc12\", f.lit(priorc12))\n            # h0-h2\n            .withColumn(\"lH0abf\", f.lit(0))\n            .withColumn(\"lH1abf\", f.log(f.col(\"priorc1\")) + f.col(\"logsum1\"))\n            .withColumn(\"lH2abf\", f.log(f.col(\"priorc2\")) + f.col(\"logsum2\"))\n            # h3\n            .withColumn(\"sumlogsum\", f.col(\"logsum1\") + f.col(\"logsum2\"))\n            # exclude null H3/H4s: due to sumlogsum == logsum12\n            .filter(f.col(\"sumlogsum\") != f.col(\"logsum12\"))\n            .withColumn(\"max\", f.greatest(\"sumlogsum\", \"logsum12\"))\n            .withColumn(\n                \"logdiff\",\n                (\n                    f.col(\"max\")\n                    + f.log(\n                        f.exp(f.col(\"sumlogsum\") - f.col(\"max\"))\n                        - f.exp(f.col(\"logsum12\") - f.col(\"max\"))\n                    )\n                ),\n            )\n            .withColumn(\n                \"lH3abf\",\n                f.log(f.col(\"priorc1\"))\n                + f.log(f.col(\"priorc2\"))\n                + f.col(\"logdiff\"),\n            )\n            .drop(\"right_logsum\", \"left_logsum\", \"sumlogsum\", \"max\", \"logdiff\")\n            # h4\n            .withColumn(\"lH4abf\", f.log(f.col(\"priorc12\")) + f.col(\"logsum12\"))\n            # cleaning\n            .drop(\n                \"priorc1\", \"priorc2\", \"priorc12\", \"logsum1\", \"logsum2\", \"logsum12\"\n            )\n            # posteriors\n            .withColumn(\n                \"allABF\",\n                fml.array_to_vector(\n                    f.array(\n                        f.col(\"lH0abf\"),\n                        f.col(\"lH1abf\"),\n                        f.col(\"lH2abf\"),\n                        f.col(\"lH3abf\"),\n                        f.col(\"lH4abf\"),\n                    )\n                ),\n            )\n            .withColumn(\n                \"posteriors\", fml.vector_to_array(posteriors(f.col(\"allABF\")))\n            )\n            .withColumn(\"h0\", f.col(\"posteriors\").getItem(0))\n            .withColumn(\"h1\", f.col(\"posteriors\").getItem(1))\n            .withColumn(\"h2\", f.col(\"posteriors\").getItem(2))\n            .withColumn(\"h3\", f.col(\"posteriors\").getItem(3))\n            .withColumn(\"h4\", f.col(\"posteriors\").getItem(4))\n            .withColumn(\"h4h3\", f.col(\"h4\") / f.col(\"h3\"))\n            .withColumn(\"log2h4h3\", f.log2(f.col(\"h4h3\")))\n            # clean up\n            .drop(\n                \"posteriors\",\n                \"allABF\",\n                \"h4h3\",\n                \"lH0abf\",\n                \"lH1abf\",\n                \"lH2abf\",\n                \"lH3abf\",\n                \"lH4abf\",\n            )\n            .withColumn(\"colocalisationMethod\", f.lit(\"COLOC\"))\n        ),\n        _schema=Colocalisation.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/ecaviar/","title":"eCAVIAR","text":""},{"location":"python_api/method/ecaviar/#otg.method.colocalisation.ECaviar","title":"<code>otg.method.colocalisation.ECaviar</code>","text":"<p>ECaviar-based colocalisation analysis.</p> <p>It extends CAVIAR\u00a0framework to explicitly estimate the posterior probability that the same variant is causal in 2 studies while accounting for the uncertainty of LD. eCAVIAR computes the colocalization posterior probability (CLPP) by utilizing the marginal posterior probabilities. This framework allows for multiple variants to be causal in a single locus.</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>class ECaviar:\n    \"\"\"ECaviar-based colocalisation analysis.\n\n    It extends [CAVIAR](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5142122/#bib18)\u00a0framework to explicitly estimate the posterior probability that the same variant is causal in 2 studies while accounting for the uncertainty of LD. eCAVIAR computes the colocalization posterior probability (**CLPP**) by utilizing the marginal posterior probabilities. This framework allows for **multiple variants to be causal** in a single locus.\n    \"\"\"\n\n    @staticmethod\n    def _get_clpp(left_pp: Column, right_pp: Column) -&gt; Column:\n        \"\"\"Calculate the colocalisation posterior probability (CLPP).\n\n        If the fact that the same variant is found causal for two studies are independent events,\n        CLPP is defined as the product of posterior porbabilities that a variant is causal in both studies.\n\n        Args:\n            left_pp (Column): left posterior probability\n            right_pp (Column): right posterior probability\n\n        Returns:\n            Column: CLPP\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"left_pp\": 0.5, \"right_pp\": 0.5}, {\"left_pp\": 0.25, \"right_pp\": 0.75}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"clpp\", ECaviar._get_clpp(f.col(\"left_pp\"), f.col(\"right_pp\"))).show()\n            +-------+--------+------+\n            |left_pp|right_pp|  clpp|\n            +-------+--------+------+\n            |    0.5|     0.5|  0.25|\n            |   0.25|    0.75|0.1875|\n            +-------+--------+------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return left_pp * right_pp\n\n    @classmethod\n    def colocalise(\n        cls: type[ECaviar], overlapping_signals: StudyLocusOverlap\n    ) -&gt; Colocalisation:\n        \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n        Args:\n            overlapping_signals (StudyLocusOverlap): overlapping signals.\n\n        Returns:\n            Colocalisation: colocalisation results based on eCAVIAR.\n        \"\"\"\n        return Colocalisation(\n            _df=(\n                overlapping_signals.df.withColumn(\n                    \"clpp\",\n                    ECaviar._get_clpp(\n                        f.col(\"statistics.left_posteriorProbability\"),\n                        f.col(\"statistics.right_posteriorProbability\"),\n                    ),\n                )\n                .groupBy(\"leftStudyLocusId\", \"rightStudyLocusId\", \"chromosome\")\n                .agg(\n                    f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                    f.sum(f.col(\"clpp\")).alias(\"clpp\"),\n                )\n                .withColumn(\"colocalisationMethod\", f.lit(\"eCAVIAR\"))\n            ),\n            _schema=Colocalisation.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/ecaviar/#otg.method.colocalisation.ECaviar.colocalise","title":"<code>colocalise(overlapping_signals: StudyLocusOverlap) -&gt; Colocalisation</code>  <code>classmethod</code>","text":"<p>Calculate bayesian colocalisation based on overlapping signals.</p> <p>Parameters:</p> Name Type Description Default <code>overlapping_signals</code> <code>StudyLocusOverlap</code> <p>overlapping signals.</p> required <p>Returns:</p> Name Type Description <code>Colocalisation</code> <code>Colocalisation</code> <p>colocalisation results based on eCAVIAR.</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>@classmethod\ndef colocalise(\n    cls: type[ECaviar], overlapping_signals: StudyLocusOverlap\n) -&gt; Colocalisation:\n    \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n    Args:\n        overlapping_signals (StudyLocusOverlap): overlapping signals.\n\n    Returns:\n        Colocalisation: colocalisation results based on eCAVIAR.\n    \"\"\"\n    return Colocalisation(\n        _df=(\n            overlapping_signals.df.withColumn(\n                \"clpp\",\n                ECaviar._get_clpp(\n                    f.col(\"statistics.left_posteriorProbability\"),\n                    f.col(\"statistics.right_posteriorProbability\"),\n                ),\n            )\n            .groupBy(\"leftStudyLocusId\", \"rightStudyLocusId\", \"chromosome\")\n            .agg(\n                f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                f.sum(f.col(\"clpp\")).alias(\"clpp\"),\n            )\n            .withColumn(\"colocalisationMethod\", f.lit(\"eCAVIAR\"))\n        ),\n        _schema=Colocalisation.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/ld_annotator/","title":"LDAnnotator","text":""},{"location":"python_api/method/ld_annotator/#otg.method.ld.LDAnnotator","title":"<code>otg.method.ld.LDAnnotator</code>","text":"<p>Class to annotate linkage disequilibrium (LD) operations from GnomAD.</p> Source code in <code>src/otg/method/ld.py</code> <pre><code>class LDAnnotator:\n    \"\"\"Class to annotate linkage disequilibrium (LD) operations from GnomAD.\"\"\"\n\n    @staticmethod\n    def _calculate_weighted_r_overall(ld_set: Column) -&gt; Column:\n        \"\"\"Aggregation of weighted R information using ancestry proportions.\n\n        Args:\n            ld_set (Column): LD set\n\n        Returns:\n            Column: LD set with added 'r2Overall' field\n        \"\"\"\n        return f.transform(\n            ld_set,\n            lambda x: f.struct(\n                x[\"tagVariantId\"].alias(\"tagVariantId\"),\n                # r2Overall is the accumulated sum of each r2 relative to the population size\n                f.aggregate(\n                    x[\"rValues\"],\n                    f.lit(0.0),\n                    lambda acc, y: acc\n                    + f.coalesce(\n                        f.pow(y[\"r\"], 2) * y[\"relativeSampleSize\"], f.lit(0.0)\n                    ),  # we use coalesce to avoid problems when r/relativeSampleSize is null\n                ).alias(\"r2Overall\"),\n            ),\n        )\n\n    @staticmethod\n    def _add_population_size(ld_set: Column, study_populations: Column) -&gt; Column:\n        \"\"\"Add population size to each rValues entry in the ldSet.\n\n        Args:\n            ld_set (Column): LD set\n            study_populations (Column): Study populations\n\n        Returns:\n            Column: LD set with added 'relativeSampleSize' field\n        \"\"\"\n        # Create a population to relativeSampleSize map from the struct\n        populations_map = f.map_from_arrays(\n            study_populations[\"ldPopulation\"],\n            study_populations[\"relativeSampleSize\"],\n        )\n        return f.transform(\n            ld_set,\n            lambda x: f.struct(\n                x[\"tagVariantId\"].alias(\"tagVariantId\"),\n                f.transform(\n                    x[\"rValues\"],\n                    lambda y: f.struct(\n                        y[\"population\"].alias(\"population\"),\n                        y[\"r\"].alias(\"r\"),\n                        populations_map[y[\"population\"]].alias(\"relativeSampleSize\"),\n                    ),\n                ).alias(\"rValues\"),\n            ),\n        )\n\n    @classmethod\n    def ld_annotate(\n        cls: type[LDAnnotator],\n        associations: StudyLocus,\n        studies: StudyIndex,\n        ld_index: LDIndex,\n    ) -&gt; StudyLocus:\n        \"\"\"Annotate linkage disequilibrium (LD) information to a set of studyLocus.\n\n        This function:\n            1. Annotates study locus with population structure information from the study index\n            2. Joins the LD index to the StudyLocus\n            3. Adds the population size of the study to each rValues entry in the ldSet\n            4. Calculates the overall R weighted by the ancestry proportions in every given study.\n\n        Args:\n            associations (StudyLocus): Dataset to be LD annotated\n            studies (StudyIndex): Dataset with study information\n            ld_index (LDIndex): Dataset with LD information for every variant present in LD matrix\n\n        Returns:\n            StudyLocus: including additional column with LD information.\n        \"\"\"\n        return (\n            StudyLocus(\n                _df=(\n                    associations.df\n                    # Drop ldSet column if already available\n                    .select(*[col for col in associations.df.columns if col != \"ldSet\"])\n                    # Annotate study locus with population structure from study index\n                    .join(\n                        studies.df.select(\"studyId\", \"ldPopulationStructure\"),\n                        on=\"studyId\",\n                        how=\"left\",\n                    )\n                    # Bring LD information from LD Index\n                    .join(\n                        ld_index.df,\n                        on=[\"variantId\", \"chromosome\"],\n                        how=\"left\",\n                    )\n                    # Add population size to each rValues entry in the ldSet if population structure available:\n                    .withColumn(\n                        \"ldSet\",\n                        f.when(\n                            f.col(\"ldPopulationStructure\").isNotNull(),\n                            cls._add_population_size(\n                                f.col(\"ldSet\"), f.col(\"ldPopulationStructure\")\n                            ),\n                        ),\n                    )\n                    # Aggregate weighted R information using ancestry proportions\n                    .withColumn(\n                        \"ldSet\",\n                        f.when(\n                            f.col(\"ldPopulationStructure\").isNotNull(),\n                            cls._calculate_weighted_r_overall(f.col(\"ldSet\")),\n                        ),\n                    ).drop(\"ldPopulationStructure\")\n                ),\n                _schema=StudyLocus.get_schema(),\n            )\n            ._qc_no_population()\n            ._qc_unresolved_ld()\n        )\n</code></pre>"},{"location":"python_api/method/ld_annotator/#otg.method.ld.LDAnnotator.ld_annotate","title":"<code>ld_annotate(associations: StudyLocus, studies: StudyIndex, ld_index: LDIndex) -&gt; StudyLocus</code>  <code>classmethod</code>","text":"<p>Annotate linkage disequilibrium (LD) information to a set of studyLocus.</p> This function <ol> <li>Annotates study locus with population structure information from the study index</li> <li>Joins the LD index to the StudyLocus</li> <li>Adds the population size of the study to each rValues entry in the ldSet</li> <li>Calculates the overall R weighted by the ancestry proportions in every given study.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>associations</code> <code>StudyLocus</code> <p>Dataset to be LD annotated</p> required <code>studies</code> <code>StudyIndex</code> <p>Dataset with study information</p> required <code>ld_index</code> <code>LDIndex</code> <p>Dataset with LD information for every variant present in LD matrix</p> required <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>including additional column with LD information.</p> Source code in <code>src/otg/method/ld.py</code> <pre><code>@classmethod\ndef ld_annotate(\n    cls: type[LDAnnotator],\n    associations: StudyLocus,\n    studies: StudyIndex,\n    ld_index: LDIndex,\n) -&gt; StudyLocus:\n    \"\"\"Annotate linkage disequilibrium (LD) information to a set of studyLocus.\n\n    This function:\n        1. Annotates study locus with population structure information from the study index\n        2. Joins the LD index to the StudyLocus\n        3. Adds the population size of the study to each rValues entry in the ldSet\n        4. Calculates the overall R weighted by the ancestry proportions in every given study.\n\n    Args:\n        associations (StudyLocus): Dataset to be LD annotated\n        studies (StudyIndex): Dataset with study information\n        ld_index (LDIndex): Dataset with LD information for every variant present in LD matrix\n\n    Returns:\n        StudyLocus: including additional column with LD information.\n    \"\"\"\n    return (\n        StudyLocus(\n            _df=(\n                associations.df\n                # Drop ldSet column if already available\n                .select(*[col for col in associations.df.columns if col != \"ldSet\"])\n                # Annotate study locus with population structure from study index\n                .join(\n                    studies.df.select(\"studyId\", \"ldPopulationStructure\"),\n                    on=\"studyId\",\n                    how=\"left\",\n                )\n                # Bring LD information from LD Index\n                .join(\n                    ld_index.df,\n                    on=[\"variantId\", \"chromosome\"],\n                    how=\"left\",\n                )\n                # Add population size to each rValues entry in the ldSet if population structure available:\n                .withColumn(\n                    \"ldSet\",\n                    f.when(\n                        f.col(\"ldPopulationStructure\").isNotNull(),\n                        cls._add_population_size(\n                            f.col(\"ldSet\"), f.col(\"ldPopulationStructure\")\n                        ),\n                    ),\n                )\n                # Aggregate weighted R information using ancestry proportions\n                .withColumn(\n                    \"ldSet\",\n                    f.when(\n                        f.col(\"ldPopulationStructure\").isNotNull(),\n                        cls._calculate_weighted_r_overall(f.col(\"ldSet\")),\n                    ),\n                ).drop(\"ldPopulationStructure\")\n            ),\n            _schema=StudyLocus.get_schema(),\n        )\n        ._qc_no_population()\n        ._qc_unresolved_ld()\n    )\n</code></pre>"},{"location":"python_api/method/pics/","title":"PICS","text":""},{"location":"python_api/method/pics/#otg.method.pics.PICS","title":"<code>otg.method.pics.PICS</code>","text":"<p>Probabilistic Identification of Causal SNPs (PICS), an algorithm estimating the probability that an individual variant is causal considering the haplotype structure and observed pattern of association at the genetic locus.</p> Source code in <code>src/otg/method/pics.py</code> <pre><code>class PICS:\n    \"\"\"Probabilistic Identification of Causal SNPs (PICS), an algorithm estimating the probability that an individual variant is causal considering the haplotype structure and observed pattern of association at the genetic locus.\"\"\"\n\n    @staticmethod\n    def _pics_relative_posterior_probability(\n        neglog_p: float, pics_snp_mu: float, pics_snp_std: float\n    ) -&gt; float:\n        \"\"\"Compute the PICS posterior probability for a given SNP.\n\n        !!! info \"This probability needs to be scaled to take into account the probabilities of the other variants in the locus.\"\n\n        Args:\n            neglog_p (float): Negative log p-value of the lead variant\n            pics_snp_mu (float): Mean P value of the association between a SNP and a trait\n            pics_snp_std (float): Standard deviation for the P value of the association between a SNP and a trait\n\n        Returns:\n            float: Posterior probability of the association between a SNP and a trait\n\n        Examples:\n            &gt;&gt;&gt; rel_prob = PICS._pics_relative_posterior_probability(neglog_p=10.0, pics_snp_mu=1.0, pics_snp_std=10.0)\n            &gt;&gt;&gt; round(rel_prob, 3)\n            0.368\n        \"\"\"\n        return float(norm(pics_snp_mu, pics_snp_std).sf(neglog_p) * 2)\n\n    @staticmethod\n    def _pics_standard_deviation(neglog_p: float, r2: float, k: float) -&gt; float | None:\n        \"\"\"Compute the PICS standard deviation.\n\n        This distribution is obtained after a series of permutation tests described in the PICS method, and it is only\n        valid when the SNP is highly linked with the lead (r2 &gt; 0.5).\n\n        Args:\n            neglog_p (float): Negative log p-value of the lead variant\n            r2 (float): LD score between a given SNP and the lead variant\n            k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n        Returns:\n            float | None: Standard deviation for the P value of the association between a SNP and a trait\n\n        Examples:\n            &gt;&gt;&gt; PICS._pics_standard_deviation(neglog_p=1.0, r2=1.0, k=6.4)\n            0.0\n            &gt;&gt;&gt; round(PICS._pics_standard_deviation(neglog_p=10.0, r2=0.5, k=6.4), 3)\n            1.493\n            &gt;&gt;&gt; print(PICS._pics_standard_deviation(neglog_p=1.0, r2=0.0, k=6.4))\n            None\n        \"\"\"\n        return (\n            abs(((1 - (r2**0.5) ** k) ** 0.5) * (neglog_p**0.5) / 2)\n            if r2 &gt;= 0.5\n            else None\n        )\n\n    @staticmethod\n    def _pics_mu(neglog_p: float, r2: float) -&gt; float | None:\n        \"\"\"Compute the PICS mu that estimates the probability of association between a given SNP and the trait.\n\n        This distribution is obtained after a series of permutation tests described in the PICS method, and it is only\n        valid when the SNP is highly linked with the lead (r2 &gt; 0.5).\n\n        Args:\n            neglog_p (float): Negative log p-value of the lead variant\n            r2 (float): LD score between a given SNP and the lead variant\n\n        Returns:\n            float | None: Mean P value of the association between a SNP and a trait\n\n        Examples:\n            &gt;&gt;&gt; PICS._pics_mu(neglog_p=1.0, r2=1.0)\n            1.0\n            &gt;&gt;&gt; PICS._pics_mu(neglog_p=10.0, r2=0.5)\n            5.0\n            &gt;&gt;&gt; print(PICS._pics_mu(neglog_p=10.0, r2=0.3))\n            None\n        \"\"\"\n        return neglog_p * r2 if r2 &gt;= 0.5 else None\n\n    @staticmethod\n    def _finemap(\n        ld_set: list[Row], lead_neglog_p: float, k: float\n    ) -&gt; list[dict[str, Any]] | None:\n        \"\"\"Calculates the probability of a variant being causal in a study-locus context by applying the PICS method.\n\n        It is intended to be applied as an UDF in `PICS.finemap`, where each row is a StudyLocus association.\n        The function iterates over every SNP in the `ldSet` array, and it returns an updated locus with\n        its association signal and causality probability as of PICS.\n\n        Args:\n            ld_set (list[Row]): list of tagging variants after expanding the locus\n            lead_neglog_p (float): P value of the association signal between the lead variant and the study in the form of -log10.\n            k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n        Returns:\n            list[dict[str, Any]] | None: List of tagging variants with an estimation of the association signal and their posterior probability as of PICS.\n\n        Examples:\n            &gt;&gt;&gt; from pyspark.sql import Row\n            &gt;&gt;&gt; ld_set = [\n            ...     Row(variantId=\"var1\", r2Overall=0.8),\n            ...     Row(variantId=\"var2\", r2Overall=1),\n            ... ]\n            &gt;&gt;&gt; PICS._finemap(ld_set, lead_neglog_p=10.0, k=6.4)\n            [{'variantId': 'var1', 'r2Overall': 0.8, 'standardError': 0.07420896512708416, 'posteriorProbability': 0.07116959886882368}, {'variantId': 'var2', 'r2Overall': 1, 'standardError': 0.9977000638225533, 'posteriorProbability': 0.9288304011311763}]\n            &gt;&gt;&gt; empty_ld_set = []\n            &gt;&gt;&gt; PICS._finemap(empty_ld_set, lead_neglog_p=10.0, k=6.4)\n            []\n            &gt;&gt;&gt; ld_set_with_no_r2 = [\n            ...     Row(variantId=\"var1\", r2Overall=None),\n            ...     Row(variantId=\"var2\", r2Overall=None),\n            ... ]\n            &gt;&gt;&gt; PICS._finemap(ld_set_with_no_r2, lead_neglog_p=10.0, k=6.4)\n            [{'variantId': 'var1', 'r2Overall': None}, {'variantId': 'var2', 'r2Overall': None}]\n        \"\"\"\n        if ld_set is None:\n            return None\n        elif not ld_set:\n            return []\n        tmp_credible_set = []\n        new_credible_set = []\n        # First iteration: calculation of mu, standard deviation, and the relative posterior probability\n        for tag_struct in ld_set:\n            tag_dict = (\n                tag_struct.asDict()\n            )  # tag_struct is of type pyspark.Row, we'll represent it as a dict\n            if (\n                not tag_dict[\"r2Overall\"]\n                or tag_dict[\"r2Overall\"] &lt; 0.5\n                or not lead_neglog_p\n            ):\n                # If PICS cannot be calculated, we'll return the original credible set\n                new_credible_set.append(tag_dict)\n                continue\n\n            pics_snp_mu = PICS._pics_mu(lead_neglog_p, tag_dict[\"r2Overall\"])\n            pics_snp_std = PICS._pics_standard_deviation(\n                lead_neglog_p, tag_dict[\"r2Overall\"], k\n            )\n            pics_snp_std = 0.001 if pics_snp_std == 0 else pics_snp_std\n            if pics_snp_mu is not None and pics_snp_std is not None:\n                posterior_probability = PICS._pics_relative_posterior_probability(\n                    lead_neglog_p, pics_snp_mu, pics_snp_std\n                )\n                tag_dict[\"standardError\"] = 10**-pics_snp_std\n                tag_dict[\"relativePosteriorProbability\"] = posterior_probability\n\n                tmp_credible_set.append(tag_dict)\n\n        # Second iteration: calculation of the sum of all the posteriors in each study-locus, so that we scale them between 0-1\n        total_posteriors = sum(\n            tag_dict.get(\"relativePosteriorProbability\", 0)\n            for tag_dict in tmp_credible_set\n        )\n\n        # Third iteration: calculation of the final posteriorProbability\n        for tag_dict in tmp_credible_set:\n            if total_posteriors != 0:\n                tag_dict[\"posteriorProbability\"] = float(\n                    tag_dict.get(\"relativePosteriorProbability\", 0) / total_posteriors\n                )\n            tag_dict.pop(\"relativePosteriorProbability\")\n            new_credible_set.append(tag_dict)\n        return new_credible_set\n\n    @classmethod\n    def finemap(\n        cls: type[PICS], associations: StudyLocus, k: float = 6.4\n    ) -&gt; StudyLocus:\n        \"\"\"Run PICS on a study locus.\n\n        !!! info \"Study locus needs to be LD annotated\"\n            The study locus needs to be LD annotated before PICS can be calculated.\n\n        Args:\n            associations (StudyLocus): Study locus to finemap using PICS\n            k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n        Returns:\n            StudyLocus: Study locus with PICS results\n        \"\"\"\n        # Register UDF by defining the structure of the output locus array of structs\n        # it also renames tagVariantId to variantId\n\n        picsed_ldset_schema = t.ArrayType(\n            t.StructType(\n                [\n                    t.StructField(\"tagVariantId\", t.StringType(), True),\n                    t.StructField(\"r2Overall\", t.DoubleType(), True),\n                    t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                    t.StructField(\"standardError\", t.DoubleType(), True),\n                ]\n            )\n        )\n        picsed_study_locus_schema = t.ArrayType(\n            t.StructType(\n                [\n                    t.StructField(\"variantId\", t.StringType(), True),\n                    t.StructField(\"r2Overall\", t.DoubleType(), True),\n                    t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                    t.StructField(\"standardError\", t.DoubleType(), True),\n                ]\n            )\n        )\n        _finemap_udf = f.udf(\n            lambda locus, neglog_p: PICS._finemap(locus, neglog_p, k),\n            picsed_ldset_schema,\n        )\n        return StudyLocus(\n            _df=(\n                associations.df\n                # Old locus column will be dropped if available\n                .select(*[col for col in associations.df.columns if col != \"locus\"])\n                # Estimate neglog_pvalue for the lead variant\n                .withColumn(\"neglog_pvalue\", associations.neglog_pvalue())\n                # New locus containing the PICS results\n                .withColumn(\n                    \"locus\",\n                    f.when(\n                        f.col(\"ldSet\").isNotNull(),\n                        _finemap_udf(f.col(\"ldSet\"), f.col(\"neglog_pvalue\")).cast(\n                            picsed_study_locus_schema\n                        ),\n                    ),\n                )\n                # Rename tagVariantId to variantId\n                .drop(\"neglog_pvalue\")\n            ),\n            _schema=StudyLocus.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/pics/#otg.method.pics.PICS.finemap","title":"<code>finemap(associations: StudyLocus, k: float = 6.4) -&gt; StudyLocus</code>  <code>classmethod</code>","text":"<p>Run PICS on a study locus.</p> <p>Study locus needs to be LD annotated</p> <p>The study locus needs to be LD annotated before PICS can be calculated.</p> <p>Parameters:</p> Name Type Description Default <code>associations</code> <code>StudyLocus</code> <p>Study locus to finemap using PICS</p> required <code>k</code> <code>float</code> <p>Empiric constant that can be adjusted to fit the curve, 6.4 recommended.</p> <code>6.4</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>Study locus with PICS results</p> Source code in <code>src/otg/method/pics.py</code> <pre><code>@classmethod\ndef finemap(\n    cls: type[PICS], associations: StudyLocus, k: float = 6.4\n) -&gt; StudyLocus:\n    \"\"\"Run PICS on a study locus.\n\n    !!! info \"Study locus needs to be LD annotated\"\n        The study locus needs to be LD annotated before PICS can be calculated.\n\n    Args:\n        associations (StudyLocus): Study locus to finemap using PICS\n        k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n    Returns:\n        StudyLocus: Study locus with PICS results\n    \"\"\"\n    # Register UDF by defining the structure of the output locus array of structs\n    # it also renames tagVariantId to variantId\n\n    picsed_ldset_schema = t.ArrayType(\n        t.StructType(\n            [\n                t.StructField(\"tagVariantId\", t.StringType(), True),\n                t.StructField(\"r2Overall\", t.DoubleType(), True),\n                t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                t.StructField(\"standardError\", t.DoubleType(), True),\n            ]\n        )\n    )\n    picsed_study_locus_schema = t.ArrayType(\n        t.StructType(\n            [\n                t.StructField(\"variantId\", t.StringType(), True),\n                t.StructField(\"r2Overall\", t.DoubleType(), True),\n                t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                t.StructField(\"standardError\", t.DoubleType(), True),\n            ]\n        )\n    )\n    _finemap_udf = f.udf(\n        lambda locus, neglog_p: PICS._finemap(locus, neglog_p, k),\n        picsed_ldset_schema,\n    )\n    return StudyLocus(\n        _df=(\n            associations.df\n            # Old locus column will be dropped if available\n            .select(*[col for col in associations.df.columns if col != \"locus\"])\n            # Estimate neglog_pvalue for the lead variant\n            .withColumn(\"neglog_pvalue\", associations.neglog_pvalue())\n            # New locus containing the PICS results\n            .withColumn(\n                \"locus\",\n                f.when(\n                    f.col(\"ldSet\").isNotNull(),\n                    _finemap_udf(f.col(\"ldSet\"), f.col(\"neglog_pvalue\")).cast(\n                        picsed_study_locus_schema\n                    ),\n                ),\n            )\n            # Rename tagVariantId to variantId\n            .drop(\"neglog_pvalue\")\n        ),\n        _schema=StudyLocus.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/window_based_clumping/","title":"Window-based clumping","text":""},{"location":"python_api/method/window_based_clumping/#otg.method.window_based_clumping.WindowBasedClumping","title":"<code>otg.method.window_based_clumping.WindowBasedClumping</code>","text":"<p>Get semi-lead snps from summary statistics using a window based function.</p> Source code in <code>src/otg/method/window_based_clumping.py</code> <pre><code>class WindowBasedClumping:\n    \"\"\"Get semi-lead snps from summary statistics using a window based function.\"\"\"\n\n    @staticmethod\n    def _cluster_peaks(\n        study: Column, chromosome: Column, position: Column, window_length: int\n    ) -&gt; Column:\n        \"\"\"Cluster GWAS significant variants, were clusters are separated by a defined distance.\n\n        !! Important to note that the length of the clusters can be arbitrarily big.\n\n        Args:\n            study (Column): study identifier\n            chromosome (Column): chromosome identifier\n            position (Column): position of the variant\n            window_length (int): window length in basepair\n\n        Returns:\n            Column: containing cluster identifier\n\n        Examples:\n            &gt;&gt;&gt; data = [\n            ...     # Cluster 1:\n            ...     ('s1', 'chr1', 2),\n            ...     ('s1', 'chr1', 4),\n            ...     ('s1', 'chr1', 12),\n            ...     # Cluster 2 - Same chromosome:\n            ...     ('s1', 'chr1', 31),\n            ...     ('s1', 'chr1', 38),\n            ...     ('s1', 'chr1', 42),\n            ...     # Cluster 3 - New chromosome:\n            ...     ('s1', 'chr2', 41),\n            ...     ('s1', 'chr2', 44),\n            ...     ('s1', 'chr2', 50),\n            ...     # Cluster 4 - other study:\n            ...     ('s2', 'chr2', 55),\n            ...     ('s2', 'chr2', 62),\n            ...     ('s2', 'chr2', 70),\n            ... ]\n            &gt;&gt;&gt; window_length = 10\n            &gt;&gt;&gt; (\n            ...     spark.createDataFrame(data, ['studyId', 'chromosome', 'position'])\n            ...     .withColumn(\"cluster_id\",\n            ...         WindowBasedClumping._cluster_peaks(\n            ...             f.col('studyId'),\n            ...             f.col('chromosome'),\n            ...             f.col('position'),\n            ...             window_length\n            ...         )\n            ...     ).show()\n            ... )\n            +-------+----------+--------+----------+\n            |studyId|chromosome|position|cluster_id|\n            +-------+----------+--------+----------+\n            |     s1|      chr1|       2| s1_chr1_2|\n            |     s1|      chr1|       4| s1_chr1_2|\n            |     s1|      chr1|      12| s1_chr1_2|\n            |     s1|      chr1|      31|s1_chr1_31|\n            |     s1|      chr1|      38|s1_chr1_31|\n            |     s1|      chr1|      42|s1_chr1_31|\n            |     s1|      chr2|      41|s1_chr2_41|\n            |     s1|      chr2|      44|s1_chr2_41|\n            |     s1|      chr2|      50|s1_chr2_41|\n            |     s2|      chr2|      55|s2_chr2_55|\n            |     s2|      chr2|      62|s2_chr2_55|\n            |     s2|      chr2|      70|s2_chr2_55|\n            +-------+----------+--------+----------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # By adding previous position, the cluster boundary can be identified:\n        previous_position = f.lag(position).over(\n            Window.partitionBy(study, chromosome).orderBy(position)\n        )\n        # We consider a cluster boudary if subsequent snps are further than the defined window:\n        cluster_id = f.when(\n            (previous_position.isNull())\n            | (position - previous_position &gt; window_length),\n            f.concat_ws(\"_\", study, chromosome, position),\n        )\n        # The cluster identifier is propagated across every variant of the cluster:\n        return f.when(\n            cluster_id.isNull(),\n            f.last(cluster_id, ignorenulls=True).over(\n                Window.partitionBy(study, chromosome)\n                .orderBy(position)\n                .rowsBetween(Window.unboundedPreceding, Window.currentRow)\n            ),\n        ).otherwise(cluster_id)\n\n    @staticmethod\n    def _prune_peak(position: NDArray[np.float64], window_size: int) -&gt; DenseVector:\n        \"\"\"Establish lead snps based on their positions listed by p-value.\n\n        The function `find_peak` assigns lead SNPs based on their positions listed by p-value within a specified window size.\n\n        Args:\n            position (NDArray[np.float64]): positions of the SNPs sorted by p-value.\n            window_size (int): the distance in bp within which associations are clumped together around the lead snp.\n\n        Returns:\n            DenseVector: binary vector where 1 indicates a lead SNP and 0 indicates a non-lead SNP.\n\n        Examples:\n            &gt;&gt;&gt; from pyspark.ml import functions as fml\n            &gt;&gt;&gt; from pyspark.ml.linalg import DenseVector\n            &gt;&gt;&gt; WindowBasedClumping._prune_peak(np.array((3, 9, 8, 4, 6)), 2)\n            DenseVector([1.0, 1.0, 0.0, 0.0, 1.0])\n\n        \"\"\"\n        # Initializing the lead list with zeroes:\n        is_lead = np.zeros(len(position))\n\n        # List containing indices of leads:\n        lead_indices: list[int] = []\n\n        # Looping through all positions:\n        for index in range(len(position)):\n            # Looping through leads to find out if they are within a window:\n            for lead_index in lead_indices:\n                # If any of the leads within the window:\n                if abs(position[lead_index] - position[index]) &lt; window_size:\n                    # Skipping further checks:\n                    break\n            else:\n                # None of the leads were within the window:\n                lead_indices.append(index)\n                is_lead[index] = 1\n\n        return DenseVector(is_lead)\n\n    @classmethod\n    def clump(\n        cls: type[WindowBasedClumping],\n        summary_stats: SummaryStatistics,\n        window_length: int,\n        p_value_significance: float = 5e-8,\n    ) -&gt; StudyLocus:\n        \"\"\"Clump summary statistics by distance.\n\n        Args:\n            summary_stats (SummaryStatistics): summary statistics to clump\n            window_length (int): window length in basepair\n            p_value_significance (float): only more significant variants are considered\n\n        Returns:\n            StudyLocus: clumped summary statistics\n        \"\"\"\n        # Create window for locus clusters\n        # - variants where the distance between subsequent variants is below the defined threshold.\n        # - Variants are sorted by descending significance\n        cluster_window = Window.partitionBy(\n            \"studyId\", \"chromosome\", \"cluster_id\"\n        ).orderBy(f.col(\"pValueExponent\").asc(), f.col(\"pValueMantissa\").asc())\n\n        return StudyLocus(\n            _df=(\n                summary_stats\n                # Dropping snps below significance - all subsequent steps are done on significant variants:\n                .pvalue_filter(p_value_significance)\n                .df\n                # Clustering summary variants for efficient windowing (complexity reduction):\n                .withColumn(\n                    \"cluster_id\",\n                    WindowBasedClumping._cluster_peaks(\n                        f.col(\"studyId\"),\n                        f.col(\"chromosome\"),\n                        f.col(\"position\"),\n                        window_length,\n                    ),\n                )\n                # Within each cluster variants are ranked by significance:\n                .withColumn(\"pvRank\", f.row_number().over(cluster_window))\n                # Collect positions in cluster for the most significant variant (complexity reduction):\n                .withColumn(\n                    \"collectedPositions\",\n                    f.when(\n                        f.col(\"pvRank\") == 1,\n                        f.collect_list(f.col(\"position\")).over(\n                            cluster_window.rowsBetween(\n                                Window.currentRow, Window.unboundedFollowing\n                            )\n                        ),\n                    ).otherwise(f.array()),\n                )\n                # Get semi indices only ONCE per cluster:\n                .withColumn(\n                    \"semiIndices\",\n                    f.when(\n                        f.size(f.col(\"collectedPositions\")) &gt; 0,\n                        fml.vector_to_array(\n                            f.udf(WindowBasedClumping._prune_peak, VectorUDT())(\n                                fml.array_to_vector(f.col(\"collectedPositions\")),\n                                f.lit(window_length),\n                            )\n                        ),\n                    ),\n                )\n                # Propagating the result of the above calculation for all rows:\n                .withColumn(\n                    \"semiIndices\",\n                    f.when(\n                        f.col(\"semiIndices\").isNull(),\n                        f.first(f.col(\"semiIndices\"), ignorenulls=True).over(\n                            cluster_window\n                        ),\n                    ).otherwise(f.col(\"semiIndices\")),\n                )\n                # Keeping semi indices only:\n                .filter(f.col(\"semiIndices\")[f.col(\"pvRank\") - 1] &gt; 0)\n                .drop(\"pvRank\", \"collectedPositions\", \"semiIndices\", \"cluster_id\")\n                # Adding study-locus id:\n                .withColumn(\n                    \"studyLocusId\",\n                    StudyLocus.assign_study_locus_id(\n                        f.col(\"studyId\"), f.col(\"variantId\")\n                    ),\n                )\n                # Initialize QC column as array of strings:\n                .withColumn(\n                    \"qualityControls\", f.array().cast(t.ArrayType(t.StringType()))\n                )\n            ),\n            _schema=StudyLocus.get_schema(),\n        )\n\n    @classmethod\n    def clump_with_locus(\n        cls: type[WindowBasedClumping],\n        summary_stats: SummaryStatistics,\n        window_length: int,\n        p_value_significance: float = 5e-8,\n        p_value_baseline: float = 0.05,\n        locus_window_length: int | None = None,\n    ) -&gt; StudyLocus:\n        \"\"\"Clump significant associations while collecting locus around them.\n\n        Args:\n            summary_stats (SummaryStatistics): Input summary statistics dataset\n            window_length (int): Window size in  bp, used for distance based clumping.\n            p_value_significance (float): GWAS significance threshold used to filter peaks. Defaults to 5e-8.\n            p_value_baseline (float): Least significant threshold. Below this, all snps are dropped. Defaults to 0.05.\n            locus_window_length (int | None): The distance for collecting locus around the semi indices. Defaults to None.\n\n        Returns:\n            StudyLocus: StudyLocus after clumping with information about the `locus`\n        \"\"\"\n        # If no locus window provided, using the same value:\n        if locus_window_length is None:\n            locus_window_length = window_length\n\n        # Run distance based clumping on the summary stats:\n        clumped_dataframe = WindowBasedClumping.clump(\n            summary_stats,\n            window_length=window_length,\n            p_value_significance=p_value_significance,\n        ).df.alias(\"clumped\")\n\n        # Get list of columns from clumped dataset for further propagation:\n        clumped_columns = clumped_dataframe.columns\n\n        # Dropping variants not meeting the baseline criteria:\n        sumstats_baseline = summary_stats.pvalue_filter(p_value_baseline).df\n\n        # Renaming columns:\n        sumstats_baseline_renamed = sumstats_baseline.selectExpr(\n            *[f\"{col} as tag_{col}\" for col in sumstats_baseline.columns]\n        ).alias(\"sumstat\")\n\n        study_locus_df = (\n            sumstats_baseline_renamed\n            # Joining the two datasets together:\n            .join(\n                f.broadcast(clumped_dataframe),\n                on=[\n                    (f.col(\"sumstat.tag_studyId\") == f.col(\"clumped.studyId\"))\n                    &amp; (f.col(\"sumstat.tag_chromosome\") == f.col(\"clumped.chromosome\"))\n                    &amp; (\n                        f.col(\"sumstat.tag_position\")\n                        &gt;= (f.col(\"clumped.position\") - locus_window_length)\n                    )\n                    &amp; (\n                        f.col(\"sumstat.tag_position\")\n                        &lt;= (f.col(\"clumped.position\") + locus_window_length)\n                    )\n                ],\n                how=\"right\",\n            )\n            .withColumn(\n                \"locus\",\n                f.struct(\n                    f.col(\"tag_variantId\").alias(\"variantId\"),\n                    f.col(\"tag_beta\").alias(\"beta\"),\n                    f.col(\"tag_pValueMantissa\").alias(\"pValueMantissa\"),\n                    f.col(\"tag_pValueExponent\").alias(\"pValueExponent\"),\n                    f.col(\"tag_standardError\").alias(\"standardError\"),\n                ),\n            )\n            .groupby(\"studyLocusId\")\n            .agg(\n                *[\n                    f.first(col).alias(col)\n                    for col in clumped_columns\n                    if col != \"studyLocusId\"\n                ],\n                f.collect_list(f.col(\"locus\")).alias(\"locus\"),\n            )\n        )\n\n        return StudyLocus(\n            _df=study_locus_df,\n            _schema=StudyLocus.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/window_based_clumping/#otg.method.window_based_clumping.WindowBasedClumping.clump","title":"<code>clump(summary_stats: SummaryStatistics, window_length: int, p_value_significance: float = 5e-08) -&gt; StudyLocus</code>  <code>classmethod</code>","text":"<p>Clump summary statistics by distance.</p> <p>Parameters:</p> Name Type Description Default <code>summary_stats</code> <code>SummaryStatistics</code> <p>summary statistics to clump</p> required <code>window_length</code> <code>int</code> <p>window length in basepair</p> required <code>p_value_significance</code> <code>float</code> <p>only more significant variants are considered</p> <code>5e-08</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>clumped summary statistics</p> Source code in <code>src/otg/method/window_based_clumping.py</code> <pre><code>@classmethod\ndef clump(\n    cls: type[WindowBasedClumping],\n    summary_stats: SummaryStatistics,\n    window_length: int,\n    p_value_significance: float = 5e-8,\n) -&gt; StudyLocus:\n    \"\"\"Clump summary statistics by distance.\n\n    Args:\n        summary_stats (SummaryStatistics): summary statistics to clump\n        window_length (int): window length in basepair\n        p_value_significance (float): only more significant variants are considered\n\n    Returns:\n        StudyLocus: clumped summary statistics\n    \"\"\"\n    # Create window for locus clusters\n    # - variants where the distance between subsequent variants is below the defined threshold.\n    # - Variants are sorted by descending significance\n    cluster_window = Window.partitionBy(\n        \"studyId\", \"chromosome\", \"cluster_id\"\n    ).orderBy(f.col(\"pValueExponent\").asc(), f.col(\"pValueMantissa\").asc())\n\n    return StudyLocus(\n        _df=(\n            summary_stats\n            # Dropping snps below significance - all subsequent steps are done on significant variants:\n            .pvalue_filter(p_value_significance)\n            .df\n            # Clustering summary variants for efficient windowing (complexity reduction):\n            .withColumn(\n                \"cluster_id\",\n                WindowBasedClumping._cluster_peaks(\n                    f.col(\"studyId\"),\n                    f.col(\"chromosome\"),\n                    f.col(\"position\"),\n                    window_length,\n                ),\n            )\n            # Within each cluster variants are ranked by significance:\n            .withColumn(\"pvRank\", f.row_number().over(cluster_window))\n            # Collect positions in cluster for the most significant variant (complexity reduction):\n            .withColumn(\n                \"collectedPositions\",\n                f.when(\n                    f.col(\"pvRank\") == 1,\n                    f.collect_list(f.col(\"position\")).over(\n                        cluster_window.rowsBetween(\n                            Window.currentRow, Window.unboundedFollowing\n                        )\n                    ),\n                ).otherwise(f.array()),\n            )\n            # Get semi indices only ONCE per cluster:\n            .withColumn(\n                \"semiIndices\",\n                f.when(\n                    f.size(f.col(\"collectedPositions\")) &gt; 0,\n                    fml.vector_to_array(\n                        f.udf(WindowBasedClumping._prune_peak, VectorUDT())(\n                            fml.array_to_vector(f.col(\"collectedPositions\")),\n                            f.lit(window_length),\n                        )\n                    ),\n                ),\n            )\n            # Propagating the result of the above calculation for all rows:\n            .withColumn(\n                \"semiIndices\",\n                f.when(\n                    f.col(\"semiIndices\").isNull(),\n                    f.first(f.col(\"semiIndices\"), ignorenulls=True).over(\n                        cluster_window\n                    ),\n                ).otherwise(f.col(\"semiIndices\")),\n            )\n            # Keeping semi indices only:\n            .filter(f.col(\"semiIndices\")[f.col(\"pvRank\") - 1] &gt; 0)\n            .drop(\"pvRank\", \"collectedPositions\", \"semiIndices\", \"cluster_id\")\n            # Adding study-locus id:\n            .withColumn(\n                \"studyLocusId\",\n                StudyLocus.assign_study_locus_id(\n                    f.col(\"studyId\"), f.col(\"variantId\")\n                ),\n            )\n            # Initialize QC column as array of strings:\n            .withColumn(\n                \"qualityControls\", f.array().cast(t.ArrayType(t.StringType()))\n            )\n        ),\n        _schema=StudyLocus.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/window_based_clumping/#otg.method.window_based_clumping.WindowBasedClumping.clump_with_locus","title":"<code>clump_with_locus(summary_stats: SummaryStatistics, window_length: int, p_value_significance: float = 5e-08, p_value_baseline: float = 0.05, locus_window_length: int | None = None) -&gt; StudyLocus</code>  <code>classmethod</code>","text":"<p>Clump significant associations while collecting locus around them.</p> <p>Parameters:</p> Name Type Description Default <code>summary_stats</code> <code>SummaryStatistics</code> <p>Input summary statistics dataset</p> required <code>window_length</code> <code>int</code> <p>Window size in  bp, used for distance based clumping.</p> required <code>p_value_significance</code> <code>float</code> <p>GWAS significance threshold used to filter peaks. Defaults to 5e-8.</p> <code>5e-08</code> <code>p_value_baseline</code> <code>float</code> <p>Least significant threshold. Below this, all snps are dropped. Defaults to 0.05.</p> <code>0.05</code> <code>locus_window_length</code> <code>int | None</code> <p>The distance for collecting locus around the semi indices. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>StudyLocus after clumping with information about the <code>locus</code></p> Source code in <code>src/otg/method/window_based_clumping.py</code> <pre><code>@classmethod\ndef clump_with_locus(\n    cls: type[WindowBasedClumping],\n    summary_stats: SummaryStatistics,\n    window_length: int,\n    p_value_significance: float = 5e-8,\n    p_value_baseline: float = 0.05,\n    locus_window_length: int | None = None,\n) -&gt; StudyLocus:\n    \"\"\"Clump significant associations while collecting locus around them.\n\n    Args:\n        summary_stats (SummaryStatistics): Input summary statistics dataset\n        window_length (int): Window size in  bp, used for distance based clumping.\n        p_value_significance (float): GWAS significance threshold used to filter peaks. Defaults to 5e-8.\n        p_value_baseline (float): Least significant threshold. Below this, all snps are dropped. Defaults to 0.05.\n        locus_window_length (int | None): The distance for collecting locus around the semi indices. Defaults to None.\n\n    Returns:\n        StudyLocus: StudyLocus after clumping with information about the `locus`\n    \"\"\"\n    # If no locus window provided, using the same value:\n    if locus_window_length is None:\n        locus_window_length = window_length\n\n    # Run distance based clumping on the summary stats:\n    clumped_dataframe = WindowBasedClumping.clump(\n        summary_stats,\n        window_length=window_length,\n        p_value_significance=p_value_significance,\n    ).df.alias(\"clumped\")\n\n    # Get list of columns from clumped dataset for further propagation:\n    clumped_columns = clumped_dataframe.columns\n\n    # Dropping variants not meeting the baseline criteria:\n    sumstats_baseline = summary_stats.pvalue_filter(p_value_baseline).df\n\n    # Renaming columns:\n    sumstats_baseline_renamed = sumstats_baseline.selectExpr(\n        *[f\"{col} as tag_{col}\" for col in sumstats_baseline.columns]\n    ).alias(\"sumstat\")\n\n    study_locus_df = (\n        sumstats_baseline_renamed\n        # Joining the two datasets together:\n        .join(\n            f.broadcast(clumped_dataframe),\n            on=[\n                (f.col(\"sumstat.tag_studyId\") == f.col(\"clumped.studyId\"))\n                &amp; (f.col(\"sumstat.tag_chromosome\") == f.col(\"clumped.chromosome\"))\n                &amp; (\n                    f.col(\"sumstat.tag_position\")\n                    &gt;= (f.col(\"clumped.position\") - locus_window_length)\n                )\n                &amp; (\n                    f.col(\"sumstat.tag_position\")\n                    &lt;= (f.col(\"clumped.position\") + locus_window_length)\n                )\n            ],\n            how=\"right\",\n        )\n        .withColumn(\n            \"locus\",\n            f.struct(\n                f.col(\"tag_variantId\").alias(\"variantId\"),\n                f.col(\"tag_beta\").alias(\"beta\"),\n                f.col(\"tag_pValueMantissa\").alias(\"pValueMantissa\"),\n                f.col(\"tag_pValueExponent\").alias(\"pValueExponent\"),\n                f.col(\"tag_standardError\").alias(\"standardError\"),\n            ),\n        )\n        .groupby(\"studyLocusId\")\n        .agg(\n            *[\n                f.first(col).alias(col)\n                for col in clumped_columns\n                if col != \"studyLocusId\"\n            ],\n            f.collect_list(f.col(\"locus\")).alias(\"locus\"),\n        )\n    )\n\n    return StudyLocus(\n        _df=study_locus_df,\n        _schema=StudyLocus.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/l2g/_l2g/","title":"Locus to Gene (L2G) classifier","text":"<p>TBC</p>"},{"location":"python_api/method/l2g/evaluator/","title":"W&B evaluator","text":""},{"location":"python_api/method/l2g/evaluator/#otg.method.l2g.evaluator.WandbEvaluator","title":"<code>otg.method.l2g.evaluator.WandbEvaluator</code>","text":"<p>             Bases: <code>Evaluator</code></p> <p>Wrapper for pyspark Evaluators. It is expected that the user will provide an Evaluators, and this wrapper will log metrics from said evaluator to W&amp;B.</p> Source code in <code>src/otg/method/l2g/evaluator.py</code> <pre><code>class WandbEvaluator(Evaluator):\n    \"\"\"Wrapper for pyspark Evaluators. It is expected that the user will provide an Evaluators, and this wrapper will log metrics from said evaluator to W&amp;B.\"\"\"\n\n    spark_ml_evaluator: Param[Evaluator] = Param(\n        Params._dummy(), \"spark_ml_evaluator\", \"evaluator from pyspark.ml.evaluation\"\n    )\n\n    wandb_run: Param[Run] = Param(\n        Params._dummy(),\n        \"wandb_run\",\n        \"wandb run.  Expects an already initialized run.  You should set this, or wandb_run_kwargs, NOT BOTH\",\n    )\n\n    wandb_run_kwargs: Param[Any] = Param(\n        Params._dummy(),\n        \"wandb_run_kwargs\",\n        \"kwargs to be passed to wandb.init.  You should set this, or wandb_runId, NOT BOTH.  Setting this is useful when using with WandbCrossValdidator\",\n    )\n\n    wandb_runId: Param[str] = Param(  # noqa: N815\n        Params._dummy(),\n        \"wandb_runId\",\n        \"wandb run id.  if not providing an intialized run to wandb_run, a run with id wandb_runId will be resumed\",\n    )\n\n    wandb_project_name: Param[str] = Param(\n        Params._dummy(),\n        \"wandb_project_name\",\n        \"name of W&amp;B project\",\n        typeConverter=TypeConverters.toString,\n    )\n\n    label_values: Param[list[str]] = Param(\n        Params._dummy(),\n        \"label_values\",\n        \"for classification and multiclass classification, this is a list of values the label can assume\\nIf provided Multiclass or Multilabel evaluator without label_values, we'll figure it out from dataset passed through to evaluate.\",\n    )\n\n    _input_kwargs: Dict[str, Any]\n\n    @keyword_only\n    def __init__(\n        self: WandbEvaluator,\n        label_values: list[str] | None = None,\n        **kwargs: BinaryClassificationEvaluator\n        | MulticlassClassificationEvaluator\n        | Run,\n    ) -&gt; None:\n        \"\"\"Initialize a WandbEvaluator.\n\n        Args:\n            label_values (list[str] | None): List of label values.\n            **kwargs (BinaryClassificationEvaluator | MulticlassClassificationEvaluator | Run): Keyword arguments.\n        \"\"\"\n        if label_values is None:\n            label_values = []\n        super(Evaluator, self).__init__()\n\n        self.metrics = {\n            MulticlassClassificationEvaluator: [\n                \"f1\",\n                \"accuracy\",\n                \"weightedPrecision\",\n                \"weightedRecall\",\n                \"weightedTruePositiveRate\",\n                \"weightedFalsePositiveRate\",\n                \"weightedFMeasure\",\n                \"truePositiveRateByLabel\",\n                \"falsePositiveRateByLabel\",\n                \"precisionByLabel\",\n                \"recallByLabel\",\n                \"fMeasureByLabel\",\n                \"logLoss\",\n                \"hammingLoss\",\n            ],\n            BinaryClassificationEvaluator: [\"areaUnderROC\", \"areaUnderPR\"],\n        }\n\n        self._setDefault(label_values=[])\n        kwargs = self._input_kwargs\n        self._set(**kwargs)\n\n    def setspark_ml_evaluator(self: WandbEvaluator, value: Evaluator) -&gt; None:\n        \"\"\"Set the spark_ml_evaluator parameter.\n\n        Args:\n            value (Evaluator): Spark ML evaluator.\n        \"\"\"\n        self._set(spark_ml_evaluator=value)\n\n    def setlabel_values(self: WandbEvaluator, value: list[str]) -&gt; None:\n        \"\"\"Set the label_values parameter.\n\n        Args:\n            value (list[str]): List of label values.\n        \"\"\"\n        self._set(label_values=value)\n\n    def getspark_ml_evaluator(self: WandbEvaluator) -&gt; Evaluator:\n        \"\"\"Get the spark_ml_evaluator parameter.\n\n        Returns:\n            Evaluator: Spark ML evaluator.\n        \"\"\"\n        return self.getOrDefault(self.spark_ml_evaluator)\n\n    def getwandb_run(self: WandbEvaluator) -&gt; wandb.sdk.wandb_run.Run:\n        \"\"\"Get the wandb_run parameter.\n\n        Returns:\n            wandb.sdk.wandb_run.Run: Wandb run object.\n        \"\"\"\n        return self.getOrDefault(self.wandb_run)\n\n    def getwandb_project_name(self: WandbEvaluator) -&gt; Any:\n        \"\"\"Get the wandb_project_name parameter.\n\n        Returns:\n            Any: Name of the W&amp;B project.\n        \"\"\"\n        return self.getOrDefault(self.wandb_project_name)\n\n    def getlabel_values(self: WandbEvaluator) -&gt; list[str]:\n        \"\"\"Get the label_values parameter.\n\n        Returns:\n            list[str]: List of label values.\n        \"\"\"\n        return self.getOrDefault(self.label_values)\n\n    def _evaluate(self: WandbEvaluator, dataset: DataFrame) -&gt; float:\n        \"\"\"Evaluate the model on the given dataset.\n\n        Args:\n            dataset (DataFrame): Dataset to evaluate the model on.\n\n        Returns:\n            float: Metric value.\n        \"\"\"\n        dataset.persist()\n        metric_values: list[tuple[str, Any]] = []\n        label_values = self.getlabel_values()\n        spark_ml_evaluator: BinaryClassificationEvaluator | MulticlassClassificationEvaluator = (\n            self.getspark_ml_evaluator()  # type: ignore[assignment, unused-ignore]\n        )\n        run = self.getwandb_run()\n        evaluator_type = type(spark_ml_evaluator)\n        for metric in self.metrics[evaluator_type]:\n            if \"ByLabel\" in metric and label_values == []:\n                print(\n                    \"no label_values for the target have been provided and will be determined by the dataset.  This could take some time\"\n                )\n                label_values = [\n                    r[spark_ml_evaluator.getLabelCol()]\n                    for r in dataset.select(spark_ml_evaluator.getLabelCol())\n                    .distinct()\n                    .collect()\n                ]\n                if isinstance(label_values[0], list):\n                    merged = list(itertools.chain(*label_values))\n                    label_values = list(dict.fromkeys(merged).keys())\n                    self.setlabel_values(label_values)\n            for label in label_values:\n                out = spark_ml_evaluator.evaluate(\n                    dataset,\n                    {\n                        spark_ml_evaluator.metricLabel: label,  # type: ignore[assignment, unused-ignore]\n                        spark_ml_evaluator.metricName: metric,\n                    },\n                )\n                metric_values.append((f\"{metric}:{label}\", out))\n            out = spark_ml_evaluator.evaluate(\n                dataset, {spark_ml_evaluator.metricName: metric}\n            )\n            metric_values.append((f\"{metric}\", out))\n        run.log(dict(metric_values))\n        config = [\n            (f\"{k.parent.split('_')[0]}.{k.name}\", v)\n            for k, v in spark_ml_evaluator.extractParamMap().items()\n            if \"metric\" not in k.name\n        ]\n        run.config.update(dict(config))\n        return_metric = spark_ml_evaluator.evaluate(dataset)\n        dataset.unpersist()\n        return return_metric\n</code></pre>"},{"location":"python_api/method/l2g/evaluator/#otg.method.l2g.evaluator.WandbEvaluator.getlabel_values","title":"<code>getlabel_values() -&gt; list[str]</code>","text":"<p>Get the label_values parameter.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of label values.</p> Source code in <code>src/otg/method/l2g/evaluator.py</code> <pre><code>def getlabel_values(self: WandbEvaluator) -&gt; list[str]:\n    \"\"\"Get the label_values parameter.\n\n    Returns:\n        list[str]: List of label values.\n    \"\"\"\n    return self.getOrDefault(self.label_values)\n</code></pre>"},{"location":"python_api/method/l2g/evaluator/#otg.method.l2g.evaluator.WandbEvaluator.getspark_ml_evaluator","title":"<code>getspark_ml_evaluator() -&gt; Evaluator</code>","text":"<p>Get the spark_ml_evaluator parameter.</p> <p>Returns:</p> Name Type Description <code>Evaluator</code> <code>Evaluator</code> <p>Spark ML evaluator.</p> Source code in <code>src/otg/method/l2g/evaluator.py</code> <pre><code>def getspark_ml_evaluator(self: WandbEvaluator) -&gt; Evaluator:\n    \"\"\"Get the spark_ml_evaluator parameter.\n\n    Returns:\n        Evaluator: Spark ML evaluator.\n    \"\"\"\n    return self.getOrDefault(self.spark_ml_evaluator)\n</code></pre>"},{"location":"python_api/method/l2g/evaluator/#otg.method.l2g.evaluator.WandbEvaluator.getwandb_project_name","title":"<code>getwandb_project_name() -&gt; Any</code>","text":"<p>Get the wandb_project_name parameter.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Name of the W&amp;B project.</p> Source code in <code>src/otg/method/l2g/evaluator.py</code> <pre><code>def getwandb_project_name(self: WandbEvaluator) -&gt; Any:\n    \"\"\"Get the wandb_project_name parameter.\n\n    Returns:\n        Any: Name of the W&amp;B project.\n    \"\"\"\n    return self.getOrDefault(self.wandb_project_name)\n</code></pre>"},{"location":"python_api/method/l2g/evaluator/#otg.method.l2g.evaluator.WandbEvaluator.getwandb_run","title":"<code>getwandb_run() -&gt; wandb.sdk.wandb_run.Run</code>","text":"<p>Get the wandb_run parameter.</p> <p>Returns:</p> Type Description <code>Run</code> <p>wandb.sdk.wandb_run.Run: Wandb run object.</p> Source code in <code>src/otg/method/l2g/evaluator.py</code> <pre><code>def getwandb_run(self: WandbEvaluator) -&gt; wandb.sdk.wandb_run.Run:\n    \"\"\"Get the wandb_run parameter.\n\n    Returns:\n        wandb.sdk.wandb_run.Run: Wandb run object.\n    \"\"\"\n    return self.getOrDefault(self.wandb_run)\n</code></pre>"},{"location":"python_api/method/l2g/evaluator/#otg.method.l2g.evaluator.WandbEvaluator.setlabel_values","title":"<code>setlabel_values(value: list[str]) -&gt; None</code>","text":"<p>Set the label_values parameter.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>list[str]</code> <p>List of label values.</p> required Source code in <code>src/otg/method/l2g/evaluator.py</code> <pre><code>def setlabel_values(self: WandbEvaluator, value: list[str]) -&gt; None:\n    \"\"\"Set the label_values parameter.\n\n    Args:\n        value (list[str]): List of label values.\n    \"\"\"\n    self._set(label_values=value)\n</code></pre>"},{"location":"python_api/method/l2g/evaluator/#otg.method.l2g.evaluator.WandbEvaluator.setspark_ml_evaluator","title":"<code>setspark_ml_evaluator(value: Evaluator) -&gt; None</code>","text":"<p>Set the spark_ml_evaluator parameter.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Evaluator</code> <p>Spark ML evaluator.</p> required Source code in <code>src/otg/method/l2g/evaluator.py</code> <pre><code>def setspark_ml_evaluator(self: WandbEvaluator, value: Evaluator) -&gt; None:\n    \"\"\"Set the spark_ml_evaluator parameter.\n\n    Args:\n        value (Evaluator): Spark ML evaluator.\n    \"\"\"\n    self._set(spark_ml_evaluator=value)\n</code></pre>"},{"location":"python_api/method/l2g/feature_factory/","title":"L2G Feature Factory","text":""},{"location":"python_api/method/l2g/feature_factory/#otg.method.l2g.feature_factory.ColocalisationFactory","title":"<code>otg.method.l2g.feature_factory.ColocalisationFactory</code>","text":"<p>Feature extraction in colocalisation.</p> Source code in <code>src/otg/method/l2g/feature_factory.py</code> <pre><code>class ColocalisationFactory:\n    \"\"\"Feature extraction in colocalisation.\"\"\"\n\n    @staticmethod\n    def _get_max_coloc_per_study_locus(\n        study_locus: StudyLocus,\n        studies: StudyIndex,\n        colocalisation: Colocalisation,\n        colocalisation_method: str,\n    ) -&gt; L2GFeature:\n        \"\"\"Get the maximum colocalisation posterior probability for each pair of overlapping study-locus per type of colocalisation method and QTL type.\n\n        Args:\n            study_locus (StudyLocus): Study locus dataset\n            studies (StudyIndex): Study index dataset\n            colocalisation (Colocalisation): Colocalisation dataset\n            colocalisation_method (str): Colocalisation method to extract the max from\n\n        Returns:\n            L2GFeature: Stores the features with the max coloc probabilities for each pair of study-locus\n\n        Raises:\n            ValueError: If the colocalisation method is not supported\n        \"\"\"\n        if colocalisation_method not in [\"COLOC\", \"eCAVIAR\"]:\n            raise ValueError(\n                f\"Colocalisation method {colocalisation_method} not supported\"\n            )\n        if colocalisation_method == \"COLOC\":\n            coloc_score_col_name = \"log2h4h3\"\n            coloc_feature_col_template = \"max_coloc_llr\"\n\n        elif colocalisation_method == \"eCAVIAR\":\n            coloc_score_col_name = \"clpp\"\n            coloc_feature_col_template = \"max_coloc_clpp\"\n\n        colocalising_study_locus = (\n            study_locus.df.select(\"studyLocusId\", \"studyId\")\n            # annotate studyLoci with overlapping IDs on the left - to just keep GWAS associations\n            .join(\n                colocalisation._df.selectExpr(\n                    \"leftStudyLocusId as studyLocusId\",\n                    \"rightStudyLocusId\",\n                    \"colocalisationMethod\",\n                    f\"{coloc_score_col_name} as coloc_score\",\n                ),\n                on=\"studyLocusId\",\n                how=\"inner\",\n            )\n            # bring study metadata to just keep QTL studies on the right\n            .join(\n                study_locus.df.selectExpr(\n                    \"studyLocusId as rightStudyLocusId\", \"studyId as right_studyId\"\n                ),\n                on=\"rightStudyLocusId\",\n                how=\"inner\",\n            )\n            .join(\n                f.broadcast(\n                    studies._df.selectExpr(\n                        \"studyId as right_studyId\",\n                        \"studyType as right_studyType\",\n                        \"geneId\",\n                    )\n                ),\n                on=\"right_studyId\",\n                how=\"inner\",\n            )\n            .filter(\n                (f.col(\"colocalisationMethod\") == colocalisation_method)\n                &amp; (f.col(\"right_studyType\") != \"gwas\")\n            )\n            .select(\"studyLocusId\", \"right_studyType\", \"geneId\", \"coloc_score\")\n        )\n\n        # Max LLR calculation per studyLocus AND type of QTL\n        local_max = get_record_with_maximum_value(\n            colocalising_study_locus,\n            [\"studyLocusId\", \"right_studyType\", \"geneId\"],\n            \"coloc_score\",\n        )\n        neighbourhood_max = (\n            get_record_with_maximum_value(\n                colocalising_study_locus,\n                [\"studyLocusId\", \"right_studyType\"],\n                \"coloc_score\",\n            )\n            .join(\n                local_max.selectExpr(\"studyLocusId\", \"coloc_score as coloc_local_max\"),\n                on=\"studyLocusId\",\n                how=\"inner\",\n            )\n            .withColumn(\n                f\"{coloc_feature_col_template}_nbh\",\n                f.col(\"coloc_local_max\") - f.col(\"coloc_score\"),\n            )\n        )\n\n        # Split feature per molQTL\n        local_dfs = []\n        nbh_dfs = []\n        for qtl_type in [\"eqtl\", \"sqtl\", \"pqtl\"]:\n            local_max = local_max.filter(\n                f.col(\"right_studyType\") == qtl_type\n            ).withColumnRenamed(\n                \"coloc_score\", f\"{qtl_type}_{coloc_feature_col_template}_local\"\n            )\n            local_dfs.append(local_max)\n\n            neighbourhood_max = neighbourhood_max.filter(\n                f.col(\"right_studyType\") == qtl_type\n            ).withColumnRenamed(\n                f\"{coloc_feature_col_template}_nbh\",\n                f\"{qtl_type}_{coloc_feature_col_template}_nbh\",\n            )\n            nbh_dfs.append(neighbourhood_max)\n\n        wide_dfs = reduce(\n            lambda x, y: x.unionByName(y, allowMissingColumns=True),\n            local_dfs + nbh_dfs,\n            colocalising_study_locus.limit(0),\n        )\n\n        return L2GFeature(\n            _df=convert_from_wide_to_long(\n                wide_dfs,\n                id_vars=(\"studyLocusId\", \"geneId\"),\n                var_name=\"featureName\",\n                value_name=\"featureValue\",\n            ),\n            _schema=L2GFeature.get_schema(),\n        )\n\n    @staticmethod\n    def _get_coloc_features(\n        study_locus: StudyLocus, studies: StudyIndex, colocalisation: Colocalisation\n    ) -&gt; L2GFeature:\n        \"\"\"Calls _get_max_coloc_per_study_locus for both methods and concatenates the results.\n\n        Args:\n            study_locus (StudyLocus): Study locus dataset\n            studies (StudyIndex): Study index dataset\n            colocalisation (Colocalisation): Colocalisation dataset\n\n        Returns:\n            L2GFeature: Stores the features with the max coloc probabilities for each pair of study-locus\n        \"\"\"\n        coloc_llr = ColocalisationFactory._get_max_coloc_per_study_locus(\n            study_locus,\n            studies,\n            colocalisation,\n            \"COLOC\",\n        )\n        coloc_clpp = ColocalisationFactory._get_max_coloc_per_study_locus(\n            study_locus,\n            studies,\n            colocalisation,\n            \"eCAVIAR\",\n        )\n\n        return L2GFeature(\n            _df=coloc_llr.df.unionByName(coloc_clpp.df, allowMissingColumns=True),\n            _schema=L2GFeature.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/l2g/feature_factory/#otg.method.l2g.feature_factory.StudyLocusFactory","title":"<code>otg.method.l2g.feature_factory.StudyLocusFactory</code>","text":"<p>             Bases: <code>StudyLocus</code></p> <p>Feature extraction in study locus.</p> Source code in <code>src/otg/method/l2g/feature_factory.py</code> <pre><code>class StudyLocusFactory(StudyLocus):\n    \"\"\"Feature extraction in study locus.\"\"\"\n\n    @staticmethod\n    def _get_tss_distance_features(\n        study_locus: StudyLocus, distances: V2G\n    ) -&gt; L2GFeature:\n        \"\"\"Joins StudyLocus with the V2G to extract the minimum distance to a gene TSS of all variants in a StudyLocus credible set.\n\n        Args:\n            study_locus (StudyLocus): Study locus dataset\n            distances (V2G): Dataframe containing the distances of all variants to all genes TSS within a region\n\n        Returns:\n            L2GFeature: Stores the features with the minimum distance among all variants in the credible set and a gene TSS.\n\n        \"\"\"\n        wide_df = (\n            study_locus.filter_credible_set(CredibleInterval.IS95)\n            .df.select(\n                \"studyLocusId\",\n                \"variantId\",\n                f.explode(\"locus.variantId\").alias(\"tagVariantId\"),\n            )\n            .join(\n                distances.df.selectExpr(\n                    \"variantId as tagVariantId\", \"geneId\", \"distance\"\n                ),\n                on=\"tagVariantId\",\n                how=\"inner\",\n            )\n            .groupBy(\"studyLocusId\", \"geneId\")\n            .agg(\n                f.min(\"distance\").alias(\"distanceTssMinimum\"),\n                f.mean(\"distance\").alias(\"distanceTssMean\"),\n            )\n        )\n\n        return L2GFeature(\n            _df=convert_from_wide_to_long(\n                wide_df,\n                id_vars=(\"studyLocusId\", \"geneId\"),\n                var_name=\"featureName\",\n                value_name=\"featureValue\",\n            ),\n            _schema=L2GFeature.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/l2g/model/","title":"L2G Model","text":""},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel","title":"<code>otg.method.l2g.model.LocusToGeneModel</code>  <code>dataclass</code>","text":"<p>Wrapper for the Locus to Gene classifier.</p> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>@dataclass\nclass LocusToGeneModel:\n    \"\"\"Wrapper for the Locus to Gene classifier.\"\"\"\n\n    features_list: list[str]\n    estimator: Any = None\n    pipeline: Pipeline = Pipeline(stages=[])\n    model: PipelineModel | None = None\n\n    def __post_init__(self: LocusToGeneModel) -&gt; None:\n        \"\"\"Post init that adds the model to the ML pipeline.\"\"\"\n        label_indexer = StringIndexer(\n            inputCol=\"goldStandardSet\", outputCol=\"label\", handleInvalid=\"keep\"\n        )\n        vector_assembler = LocusToGeneModel.features_vector_assembler(\n            self.features_list\n        )\n\n        self.pipeline = Pipeline(\n            stages=[\n                label_indexer,\n                vector_assembler,\n            ]\n        )\n\n    def save(self: LocusToGeneModel, path: str) -&gt; None:\n        \"\"\"Saves fitted pipeline model to disk.\n\n        Args:\n            path (str): Path to save the model to\n\n        Raises:\n            ValueError: If the model has not been fitted yet\n        \"\"\"\n        if self.model is None:\n            raise ValueError(\"Model has not been fitted yet.\")\n        self.model.write().overwrite().save(path)\n\n    @property\n    def classifier(self: LocusToGeneModel) -&gt; Any:\n        \"\"\"Return the model.\n\n        Returns:\n            Any: An estimator object from Spark ML\n        \"\"\"\n        return self.estimator\n\n    @staticmethod\n    def features_vector_assembler(features_cols: list[str]) -&gt; VectorAssembler:\n        \"\"\"Spark transformer to assemble the feature columns into a vector.\n\n        Args:\n            features_cols (list[str]): List of feature columns to assemble\n\n        Returns:\n            VectorAssembler: Spark transformer to assemble the feature columns into a vector\n\n        Examples:\n            &gt;&gt;&gt; from pyspark.ml.feature import VectorAssembler\n            &gt;&gt;&gt; df = spark.createDataFrame([(5.2, 3.5)], schema=\"feature_1 FLOAT, feature_2 FLOAT\")\n            &gt;&gt;&gt; assembler = LocusToGeneModel.features_vector_assembler([\"feature_1\", \"feature_2\"])\n            &gt;&gt;&gt; assembler.transform(df).show()\n            +---------+---------+--------------------+\n            |feature_1|feature_2|            features|\n            +---------+---------+--------------------+\n            |      5.2|      3.5|[5.19999980926513...|\n            +---------+---------+--------------------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        return (\n            VectorAssembler(handleInvalid=\"error\")\n            .setInputCols(features_cols)\n            .setOutputCol(\"features\")\n        )\n\n    @staticmethod\n    def log_to_wandb(\n        results: DataFrame,\n        binary_evaluator: BinaryClassificationEvaluator,\n        multi_evaluator: MulticlassClassificationEvaluator,\n        wandb_run: Run,\n    ) -&gt; None:\n        \"\"\"Perform evaluation of the model by applying it to a test set and tracking the results with W&amp;B.\n\n        Args:\n            results (DataFrame): Dataframe containing the predictions\n            binary_evaluator (BinaryClassificationEvaluator): Binary evaluator\n            multi_evaluator (MulticlassClassificationEvaluator): Multiclass evaluator\n            wandb_run (Run): W&amp;B run to log the results to\n        \"\"\"\n        binary_wandb_evaluator = WandbEvaluator(\n            spark_ml_evaluator=binary_evaluator, wandb_run=wandb_run\n        )\n        binary_wandb_evaluator.evaluate(results)\n        multi_wandb_evaluator = WandbEvaluator(\n            spark_ml_evaluator=multi_evaluator, wandb_run=wandb_run\n        )\n        multi_wandb_evaluator.evaluate(results)\n\n    @classmethod\n    def load_from_disk(\n        cls: Type[LocusToGeneModel], path: str, features_list: list[str]\n    ) -&gt; LocusToGeneModel:\n        \"\"\"Load a fitted pipeline model from disk.\n\n        Args:\n            path (str): Path to the model\n            features_list (list[str]): List of features used for the model\n\n        Returns:\n            LocusToGeneModel: L2G model loaded from disk\n        \"\"\"\n        return cls(model=PipelineModel.load(path), features_list=features_list)\n\n    @classifier.setter  # type: ignore\n    def classifier(self: LocusToGeneModel, new_estimator: Any) -&gt; None:\n        \"\"\"Set the model.\n\n        Args:\n            new_estimator (Any): An estimator object from Spark ML\n        \"\"\"\n        self.estimator = new_estimator\n\n    def get_param_grid(self: LocusToGeneModel) -&gt; list[Any]:\n        \"\"\"Return the parameter grid for the model.\n\n        Returns:\n            list[Any]: List of parameter maps to use for cross validation\n        \"\"\"\n        return (\n            ParamGridBuilder()\n            .addGrid(self.estimator.max_depth, [3, 5, 7])\n            .addGrid(self.estimator.learning_rate, [0.01, 0.1, 1.0])\n            .build()\n        )\n\n    def add_pipeline_stage(\n        self: LocusToGeneModel, transformer: Transformer\n    ) -&gt; LocusToGeneModel:\n        \"\"\"Adds a stage to the L2G pipeline.\n\n        Args:\n            transformer (Transformer): Spark transformer to add to the pipeline\n\n        Returns:\n            LocusToGeneModel: L2G model with the new transformer\n\n        Examples:\n            &gt;&gt;&gt; from pyspark.ml.regression import LinearRegression\n            &gt;&gt;&gt; estimator = LinearRegression()\n            &gt;&gt;&gt; test_model = LocusToGeneModel(features_list=[\"a\", \"b\"])\n            &gt;&gt;&gt; print(len(test_model.pipeline.getStages()))\n            2\n            &gt;&gt;&gt; print(len(test_model.add_pipeline_stage(estimator).pipeline.getStages()))\n            3\n        \"\"\"\n        pipeline_stages = self.pipeline.getStages()\n        new_stages = pipeline_stages + [transformer]\n        self.pipeline = Pipeline(stages=new_stages)\n        return self\n\n    def evaluate(\n        self: LocusToGeneModel,\n        results: DataFrame,\n        hyperparameters: dict[str, Any],\n        wandb_run_name: str | None,\n    ) -&gt; None:\n        \"\"\"Perform evaluation of the model by applying it to a test set and tracking the results with W&amp;B.\n\n        Args:\n            results (DataFrame): Dataframe containing the predictions\n            hyperparameters (dict[str, Any]): Hyperparameters used for the model\n            wandb_run_name (str | None): Descriptive name for the run to be tracked with W&amp;B\n        \"\"\"\n        binary_evaluator = BinaryClassificationEvaluator(\n            rawPredictionCol=\"rawPrediction\", labelCol=\"label\"\n        )\n        multi_evaluator = MulticlassClassificationEvaluator(\n            labelCol=\"label\", predictionCol=\"prediction\"\n        )\n\n        print(\"Evaluating model...\")\n        print(\n            \"... Area under ROC curve:\",\n            binary_evaluator.evaluate(\n                results, {binary_evaluator.metricName: \"areaUnderROC\"}\n            ),\n        )\n        print(\n            \"... Area under Precision-Recall curve:\",\n            binary_evaluator.evaluate(\n                results, {binary_evaluator.metricName: \"areaUnderPR\"}\n            ),\n        )\n        print(\n            \"... Accuracy:\",\n            multi_evaluator.evaluate(results, {multi_evaluator.metricName: \"accuracy\"}),\n        )\n        print(\n            \"... F1 score:\",\n            multi_evaluator.evaluate(results, {multi_evaluator.metricName: \"f1\"}),\n        )\n\n        if wandb_run_name:\n            print(\"Logging to W&amp;B...\")\n            run = wandb.init(\n                project=\"otg_l2g\", config=hyperparameters, name=wandb_run_name\n            )\n            if isinstance(run, Run):\n                LocusToGeneModel.log_to_wandb(\n                    results, binary_evaluator, multi_evaluator, run\n                )\n                run.finish()\n\n    def plot_importance(self: LocusToGeneModel) -&gt; None:\n        \"\"\"Plot the feature importance of the model.\"\"\"\n        # xgb_plot_importance(self)  # FIXME: What is the attribute that stores the model?\n\n    def fit(\n        self: LocusToGeneModel,\n        feature_matrix: L2GFeatureMatrix,\n    ) -&gt; LocusToGeneModel:\n        \"\"\"Fit the pipeline to the feature matrix dataframe.\n\n        Args:\n            feature_matrix (L2GFeatureMatrix): Feature matrix dataframe to fit the model to\n\n        Returns:\n            LocusToGeneModel: Fitted model\n        \"\"\"\n        self.model = self.pipeline.fit(feature_matrix.df)\n        return self\n\n    def predict(\n        self: LocusToGeneModel,\n        feature_matrix: L2GFeatureMatrix,\n    ) -&gt; DataFrame:\n        \"\"\"Apply the model to a given feature matrix dataframe. The feature matrix needs to be preprocessed first.\n\n        Args:\n            feature_matrix (L2GFeatureMatrix): Feature matrix dataframe to apply the model to\n\n        Returns:\n            DataFrame: Dataframe with predictions\n\n        Raises:\n            ValueError: If the model has not been fitted yet\n        \"\"\"\n        if not self.model:\n            raise ValueError(\"Model not fitted yet. `fit()` has to be called first.\")\n        return self.model.transform(feature_matrix.df)\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.classifier","title":"<code>classifier: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Return the model.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>An estimator object from Spark ML</p>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.add_pipeline_stage","title":"<code>add_pipeline_stage(transformer: Transformer) -&gt; LocusToGeneModel</code>","text":"<p>Adds a stage to the L2G pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>Transformer</code> <p>Spark transformer to add to the pipeline</p> required <p>Returns:</p> Name Type Description <code>LocusToGeneModel</code> <code>LocusToGeneModel</code> <p>L2G model with the new transformer</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyspark.ml.regression import LinearRegression\n&gt;&gt;&gt; estimator = LinearRegression()\n&gt;&gt;&gt; test_model = LocusToGeneModel(features_list=[\"a\", \"b\"])\n&gt;&gt;&gt; print(len(test_model.pipeline.getStages()))\n2\n&gt;&gt;&gt; print(len(test_model.add_pipeline_stage(estimator).pipeline.getStages()))\n3\n</code></pre> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>def add_pipeline_stage(\n    self: LocusToGeneModel, transformer: Transformer\n) -&gt; LocusToGeneModel:\n    \"\"\"Adds a stage to the L2G pipeline.\n\n    Args:\n        transformer (Transformer): Spark transformer to add to the pipeline\n\n    Returns:\n        LocusToGeneModel: L2G model with the new transformer\n\n    Examples:\n        &gt;&gt;&gt; from pyspark.ml.regression import LinearRegression\n        &gt;&gt;&gt; estimator = LinearRegression()\n        &gt;&gt;&gt; test_model = LocusToGeneModel(features_list=[\"a\", \"b\"])\n        &gt;&gt;&gt; print(len(test_model.pipeline.getStages()))\n        2\n        &gt;&gt;&gt; print(len(test_model.add_pipeline_stage(estimator).pipeline.getStages()))\n        3\n    \"\"\"\n    pipeline_stages = self.pipeline.getStages()\n    new_stages = pipeline_stages + [transformer]\n    self.pipeline = Pipeline(stages=new_stages)\n    return self\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.evaluate","title":"<code>evaluate(results: DataFrame, hyperparameters: dict[str, Any], wandb_run_name: str | None) -&gt; None</code>","text":"<p>Perform evaluation of the model by applying it to a test set and tracking the results with W&amp;B.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>DataFrame</code> <p>Dataframe containing the predictions</p> required <code>hyperparameters</code> <code>dict[str, Any]</code> <p>Hyperparameters used for the model</p> required <code>wandb_run_name</code> <code>str | None</code> <p>Descriptive name for the run to be tracked with W&amp;B</p> required Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>def evaluate(\n    self: LocusToGeneModel,\n    results: DataFrame,\n    hyperparameters: dict[str, Any],\n    wandb_run_name: str | None,\n) -&gt; None:\n    \"\"\"Perform evaluation of the model by applying it to a test set and tracking the results with W&amp;B.\n\n    Args:\n        results (DataFrame): Dataframe containing the predictions\n        hyperparameters (dict[str, Any]): Hyperparameters used for the model\n        wandb_run_name (str | None): Descriptive name for the run to be tracked with W&amp;B\n    \"\"\"\n    binary_evaluator = BinaryClassificationEvaluator(\n        rawPredictionCol=\"rawPrediction\", labelCol=\"label\"\n    )\n    multi_evaluator = MulticlassClassificationEvaluator(\n        labelCol=\"label\", predictionCol=\"prediction\"\n    )\n\n    print(\"Evaluating model...\")\n    print(\n        \"... Area under ROC curve:\",\n        binary_evaluator.evaluate(\n            results, {binary_evaluator.metricName: \"areaUnderROC\"}\n        ),\n    )\n    print(\n        \"... Area under Precision-Recall curve:\",\n        binary_evaluator.evaluate(\n            results, {binary_evaluator.metricName: \"areaUnderPR\"}\n        ),\n    )\n    print(\n        \"... Accuracy:\",\n        multi_evaluator.evaluate(results, {multi_evaluator.metricName: \"accuracy\"}),\n    )\n    print(\n        \"... F1 score:\",\n        multi_evaluator.evaluate(results, {multi_evaluator.metricName: \"f1\"}),\n    )\n\n    if wandb_run_name:\n        print(\"Logging to W&amp;B...\")\n        run = wandb.init(\n            project=\"otg_l2g\", config=hyperparameters, name=wandb_run_name\n        )\n        if isinstance(run, Run):\n            LocusToGeneModel.log_to_wandb(\n                results, binary_evaluator, multi_evaluator, run\n            )\n            run.finish()\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.features_vector_assembler","title":"<code>features_vector_assembler(features_cols: list[str]) -&gt; VectorAssembler</code>  <code>staticmethod</code>","text":"<p>Spark transformer to assemble the feature columns into a vector.</p> <p>Parameters:</p> Name Type Description Default <code>features_cols</code> <code>list[str]</code> <p>List of feature columns to assemble</p> required <p>Returns:</p> Name Type Description <code>VectorAssembler</code> <code>VectorAssembler</code> <p>Spark transformer to assemble the feature columns into a vector</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyspark.ml.feature import VectorAssembler\n&gt;&gt;&gt; df = spark.createDataFrame([(5.2, 3.5)], schema=\"feature_1 FLOAT, feature_2 FLOAT\")\n&gt;&gt;&gt; assembler = LocusToGeneModel.features_vector_assembler([\"feature_1\", \"feature_2\"])\n&gt;&gt;&gt; assembler.transform(df).show()\n+---------+---------+--------------------+\n|feature_1|feature_2|            features|\n+---------+---------+--------------------+\n|      5.2|      3.5|[5.19999980926513...|\n+---------+---------+--------------------+\n</code></pre> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>@staticmethod\ndef features_vector_assembler(features_cols: list[str]) -&gt; VectorAssembler:\n    \"\"\"Spark transformer to assemble the feature columns into a vector.\n\n    Args:\n        features_cols (list[str]): List of feature columns to assemble\n\n    Returns:\n        VectorAssembler: Spark transformer to assemble the feature columns into a vector\n\n    Examples:\n        &gt;&gt;&gt; from pyspark.ml.feature import VectorAssembler\n        &gt;&gt;&gt; df = spark.createDataFrame([(5.2, 3.5)], schema=\"feature_1 FLOAT, feature_2 FLOAT\")\n        &gt;&gt;&gt; assembler = LocusToGeneModel.features_vector_assembler([\"feature_1\", \"feature_2\"])\n        &gt;&gt;&gt; assembler.transform(df).show()\n        +---------+---------+--------------------+\n        |feature_1|feature_2|            features|\n        +---------+---------+--------------------+\n        |      5.2|      3.5|[5.19999980926513...|\n        +---------+---------+--------------------+\n        &lt;BLANKLINE&gt;\n    \"\"\"\n    return (\n        VectorAssembler(handleInvalid=\"error\")\n        .setInputCols(features_cols)\n        .setOutputCol(\"features\")\n    )\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.fit","title":"<code>fit(feature_matrix: L2GFeatureMatrix) -&gt; LocusToGeneModel</code>","text":"<p>Fit the pipeline to the feature matrix dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>feature_matrix</code> <code>L2GFeatureMatrix</code> <p>Feature matrix dataframe to fit the model to</p> required <p>Returns:</p> Name Type Description <code>LocusToGeneModel</code> <code>LocusToGeneModel</code> <p>Fitted model</p> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>def fit(\n    self: LocusToGeneModel,\n    feature_matrix: L2GFeatureMatrix,\n) -&gt; LocusToGeneModel:\n    \"\"\"Fit the pipeline to the feature matrix dataframe.\n\n    Args:\n        feature_matrix (L2GFeatureMatrix): Feature matrix dataframe to fit the model to\n\n    Returns:\n        LocusToGeneModel: Fitted model\n    \"\"\"\n    self.model = self.pipeline.fit(feature_matrix.df)\n    return self\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.get_param_grid","title":"<code>get_param_grid() -&gt; list[Any]</code>","text":"<p>Return the parameter grid for the model.</p> <p>Returns:</p> Type Description <code>list[Any]</code> <p>list[Any]: List of parameter maps to use for cross validation</p> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>def get_param_grid(self: LocusToGeneModel) -&gt; list[Any]:\n    \"\"\"Return the parameter grid for the model.\n\n    Returns:\n        list[Any]: List of parameter maps to use for cross validation\n    \"\"\"\n    return (\n        ParamGridBuilder()\n        .addGrid(self.estimator.max_depth, [3, 5, 7])\n        .addGrid(self.estimator.learning_rate, [0.01, 0.1, 1.0])\n        .build()\n    )\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.load_from_disk","title":"<code>load_from_disk(path: str, features_list: list[str]) -&gt; LocusToGeneModel</code>  <code>classmethod</code>","text":"<p>Load a fitted pipeline model from disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the model</p> required <code>features_list</code> <code>list[str]</code> <p>List of features used for the model</p> required <p>Returns:</p> Name Type Description <code>LocusToGeneModel</code> <code>LocusToGeneModel</code> <p>L2G model loaded from disk</p> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>@classmethod\ndef load_from_disk(\n    cls: Type[LocusToGeneModel], path: str, features_list: list[str]\n) -&gt; LocusToGeneModel:\n    \"\"\"Load a fitted pipeline model from disk.\n\n    Args:\n        path (str): Path to the model\n        features_list (list[str]): List of features used for the model\n\n    Returns:\n        LocusToGeneModel: L2G model loaded from disk\n    \"\"\"\n    return cls(model=PipelineModel.load(path), features_list=features_list)\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.log_to_wandb","title":"<code>log_to_wandb(results: DataFrame, binary_evaluator: BinaryClassificationEvaluator, multi_evaluator: MulticlassClassificationEvaluator, wandb_run: Run) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Perform evaluation of the model by applying it to a test set and tracking the results with W&amp;B.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>DataFrame</code> <p>Dataframe containing the predictions</p> required <code>binary_evaluator</code> <code>BinaryClassificationEvaluator</code> <p>Binary evaluator</p> required <code>multi_evaluator</code> <code>MulticlassClassificationEvaluator</code> <p>Multiclass evaluator</p> required <code>wandb_run</code> <code>Run</code> <p>W&amp;B run to log the results to</p> required Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>@staticmethod\ndef log_to_wandb(\n    results: DataFrame,\n    binary_evaluator: BinaryClassificationEvaluator,\n    multi_evaluator: MulticlassClassificationEvaluator,\n    wandb_run: Run,\n) -&gt; None:\n    \"\"\"Perform evaluation of the model by applying it to a test set and tracking the results with W&amp;B.\n\n    Args:\n        results (DataFrame): Dataframe containing the predictions\n        binary_evaluator (BinaryClassificationEvaluator): Binary evaluator\n        multi_evaluator (MulticlassClassificationEvaluator): Multiclass evaluator\n        wandb_run (Run): W&amp;B run to log the results to\n    \"\"\"\n    binary_wandb_evaluator = WandbEvaluator(\n        spark_ml_evaluator=binary_evaluator, wandb_run=wandb_run\n    )\n    binary_wandb_evaluator.evaluate(results)\n    multi_wandb_evaluator = WandbEvaluator(\n        spark_ml_evaluator=multi_evaluator, wandb_run=wandb_run\n    )\n    multi_wandb_evaluator.evaluate(results)\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.plot_importance","title":"<code>plot_importance() -&gt; None</code>","text":"<p>Plot the feature importance of the model.</p> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>def plot_importance(self: LocusToGeneModel) -&gt; None:\n    \"\"\"Plot the feature importance of the model.\"\"\"\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.predict","title":"<code>predict(feature_matrix: L2GFeatureMatrix) -&gt; DataFrame</code>","text":"<p>Apply the model to a given feature matrix dataframe. The feature matrix needs to be preprocessed first.</p> <p>Parameters:</p> Name Type Description Default <code>feature_matrix</code> <code>L2GFeatureMatrix</code> <p>Feature matrix dataframe to apply the model to</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Dataframe with predictions</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the model has not been fitted yet</p> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>def predict(\n    self: LocusToGeneModel,\n    feature_matrix: L2GFeatureMatrix,\n) -&gt; DataFrame:\n    \"\"\"Apply the model to a given feature matrix dataframe. The feature matrix needs to be preprocessed first.\n\n    Args:\n        feature_matrix (L2GFeatureMatrix): Feature matrix dataframe to apply the model to\n\n    Returns:\n        DataFrame: Dataframe with predictions\n\n    Raises:\n        ValueError: If the model has not been fitted yet\n    \"\"\"\n    if not self.model:\n        raise ValueError(\"Model not fitted yet. `fit()` has to be called first.\")\n    return self.model.transform(feature_matrix.df)\n</code></pre>"},{"location":"python_api/method/l2g/model/#otg.method.l2g.model.LocusToGeneModel.save","title":"<code>save(path: str) -&gt; None</code>","text":"<p>Saves fitted pipeline model to disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to save the model to</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the model has not been fitted yet</p> Source code in <code>src/otg/method/l2g/model.py</code> <pre><code>def save(self: LocusToGeneModel, path: str) -&gt; None:\n    \"\"\"Saves fitted pipeline model to disk.\n\n    Args:\n        path (str): Path to save the model to\n\n    Raises:\n        ValueError: If the model has not been fitted yet\n    \"\"\"\n    if self.model is None:\n        raise ValueError(\"Model has not been fitted yet.\")\n    self.model.write().overwrite().save(path)\n</code></pre>"},{"location":"python_api/method/l2g/trainer/","title":"L2G Trainer","text":""},{"location":"python_api/method/l2g/trainer/#otg.method.l2g.trainer.LocusToGeneTrainer","title":"<code>otg.method.l2g.trainer.LocusToGeneTrainer</code>  <code>dataclass</code>","text":"<p>Modelling of what is the most likely causal gene associated with a given locus.</p> Source code in <code>src/otg/method/l2g/trainer.py</code> <pre><code>@dataclass\nclass LocusToGeneTrainer:\n    \"\"\"Modelling of what is the most likely causal gene associated with a given locus.\"\"\"\n\n    _model: LocusToGeneModel\n    train_set: L2GFeatureMatrix\n\n    @classmethod\n    def train(\n        cls: type[LocusToGeneTrainer],\n        data: L2GFeatureMatrix,\n        l2g_model: LocusToGeneModel,\n        features_list: list[str],\n        evaluate: bool,\n        wandb_run_name: str | None = None,\n        model_path: str | None = None,\n        **hyperparams: dict[str, Any],\n    ) -&gt; LocusToGeneModel:\n        \"\"\"Train the Locus to Gene model.\n\n        Args:\n            data (L2GFeatureMatrix): Feature matrix containing the data\n            l2g_model (LocusToGeneModel): Model to fit to the data on\n            features_list (list[str]): List of features to use for the model\n            evaluate (bool): Whether to evaluate the model on a test set\n            wandb_run_name (str | None): Descriptive name for the run to be tracked with W&amp;B\n            model_path (str | None): Path to save the model to\n            **hyperparams (dict[str, Any]): Hyperparameters to use for the model\n\n        Returns:\n            LocusToGeneModel: Trained model\n        \"\"\"\n        train, test = data.select_features(features_list).train_test_split(fraction=0.8)\n\n        model = l2g_model.add_pipeline_stage(l2g_model.estimator).fit(train)\n\n        if evaluate:\n            l2g_model.evaluate(\n                results=model.predict(test),\n                hyperparameters=hyperparams,\n                wandb_run_name=wandb_run_name,\n            )\n        if model_path:\n            l2g_model.save(model_path)\n        return l2g_model\n\n    @classmethod\n    def cross_validate(\n        cls: type[LocusToGeneTrainer],\n        l2g_model: LocusToGeneModel,\n        data: L2GFeatureMatrix,\n        num_folds: int,\n        param_grid: Optional[list] = None,  # type: ignore\n    ) -&gt; LocusToGeneModel:\n        \"\"\"Perform k-fold cross validation on the model.\n\n        By providing a model with a parameter grid, this method will perform k-fold cross validation on the model for each\n        combination of parameters and return the best model.\n\n        Args:\n            l2g_model (LocusToGeneModel): Model to fit to the data on\n            data (L2GFeatureMatrix): Data to perform cross validation on\n            num_folds (int): Number of folds to use for cross validation\n            param_grid (Optional[list]): List of parameter maps to use for cross validation\n\n        Returns:\n            LocusToGeneModel: Trained model fitted with the best hyperparameters\n\n        Raises:\n            ValueError: Parameter grid is empty. Cannot perform cross-validation.\n            ValueError: Unable to retrieve the best model.\n        \"\"\"\n        evaluator = MulticlassClassificationEvaluator()\n        params_grid = param_grid or l2g_model.get_param_grid()\n        if not param_grid:\n            raise ValueError(\n                \"Parameter grid is empty. Cannot perform cross-validation.\"\n            )\n        cv = CrossValidator(\n            numFolds=num_folds,\n            estimator=l2g_model.estimator,\n            estimatorParamMaps=params_grid,\n            evaluator=evaluator,\n            parallelism=2,\n            collectSubModels=False,\n            seed=42,\n        )\n\n        l2g_model.add_pipeline_stage(cv)  # type: ignore[assignment, unused-ignore]\n\n        # Integrate the best model from the last stage of the pipeline\n        if (full_pipeline_model := l2g_model.fit(data).model) is None or not hasattr(\n            full_pipeline_model, \"stages\"\n        ):\n            raise ValueError(\"Unable to retrieve the best model.\")\n        l2g_model.model = full_pipeline_model.stages[-1].bestModel  # type: ignore[assignment, unused-ignore]\n        return l2g_model\n</code></pre>"},{"location":"python_api/method/l2g/trainer/#otg.method.l2g.trainer.LocusToGeneTrainer.cross_validate","title":"<code>cross_validate(l2g_model: LocusToGeneModel, data: L2GFeatureMatrix, num_folds: int, param_grid: Optional[list] = None) -&gt; LocusToGeneModel</code>  <code>classmethod</code>","text":"<p>Perform k-fold cross validation on the model.</p> <p>By providing a model with a parameter grid, this method will perform k-fold cross validation on the model for each combination of parameters and return the best model.</p> <p>Parameters:</p> Name Type Description Default <code>l2g_model</code> <code>LocusToGeneModel</code> <p>Model to fit to the data on</p> required <code>data</code> <code>L2GFeatureMatrix</code> <p>Data to perform cross validation on</p> required <code>num_folds</code> <code>int</code> <p>Number of folds to use for cross validation</p> required <code>param_grid</code> <code>Optional[list]</code> <p>List of parameter maps to use for cross validation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>LocusToGeneModel</code> <code>LocusToGeneModel</code> <p>Trained model fitted with the best hyperparameters</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Parameter grid is empty. Cannot perform cross-validation.</p> <code>ValueError</code> <p>Unable to retrieve the best model.</p> Source code in <code>src/otg/method/l2g/trainer.py</code> <pre><code>@classmethod\ndef cross_validate(\n    cls: type[LocusToGeneTrainer],\n    l2g_model: LocusToGeneModel,\n    data: L2GFeatureMatrix,\n    num_folds: int,\n    param_grid: Optional[list] = None,  # type: ignore\n) -&gt; LocusToGeneModel:\n    \"\"\"Perform k-fold cross validation on the model.\n\n    By providing a model with a parameter grid, this method will perform k-fold cross validation on the model for each\n    combination of parameters and return the best model.\n\n    Args:\n        l2g_model (LocusToGeneModel): Model to fit to the data on\n        data (L2GFeatureMatrix): Data to perform cross validation on\n        num_folds (int): Number of folds to use for cross validation\n        param_grid (Optional[list]): List of parameter maps to use for cross validation\n\n    Returns:\n        LocusToGeneModel: Trained model fitted with the best hyperparameters\n\n    Raises:\n        ValueError: Parameter grid is empty. Cannot perform cross-validation.\n        ValueError: Unable to retrieve the best model.\n    \"\"\"\n    evaluator = MulticlassClassificationEvaluator()\n    params_grid = param_grid or l2g_model.get_param_grid()\n    if not param_grid:\n        raise ValueError(\n            \"Parameter grid is empty. Cannot perform cross-validation.\"\n        )\n    cv = CrossValidator(\n        numFolds=num_folds,\n        estimator=l2g_model.estimator,\n        estimatorParamMaps=params_grid,\n        evaluator=evaluator,\n        parallelism=2,\n        collectSubModels=False,\n        seed=42,\n    )\n\n    l2g_model.add_pipeline_stage(cv)  # type: ignore[assignment, unused-ignore]\n\n    # Integrate the best model from the last stage of the pipeline\n    if (full_pipeline_model := l2g_model.fit(data).model) is None or not hasattr(\n        full_pipeline_model, \"stages\"\n    ):\n        raise ValueError(\"Unable to retrieve the best model.\")\n    l2g_model.model = full_pipeline_model.stages[-1].bestModel  # type: ignore[assignment, unused-ignore]\n    return l2g_model\n</code></pre>"},{"location":"python_api/method/l2g/trainer/#otg.method.l2g.trainer.LocusToGeneTrainer.train","title":"<code>train(data: L2GFeatureMatrix, l2g_model: LocusToGeneModel, features_list: list[str], evaluate: bool, wandb_run_name: str | None = None, model_path: str | None = None, **hyperparams: dict[str, Any]) -&gt; LocusToGeneModel</code>  <code>classmethod</code>","text":"<p>Train the Locus to Gene model.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>L2GFeatureMatrix</code> <p>Feature matrix containing the data</p> required <code>l2g_model</code> <code>LocusToGeneModel</code> <p>Model to fit to the data on</p> required <code>features_list</code> <code>list[str]</code> <p>List of features to use for the model</p> required <code>evaluate</code> <code>bool</code> <p>Whether to evaluate the model on a test set</p> required <code>wandb_run_name</code> <code>str | None</code> <p>Descriptive name for the run to be tracked with W&amp;B</p> <code>None</code> <code>model_path</code> <code>str | None</code> <p>Path to save the model to</p> <code>None</code> <code>**hyperparams</code> <code>dict[str, Any]</code> <p>Hyperparameters to use for the model</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>LocusToGeneModel</code> <code>LocusToGeneModel</code> <p>Trained model</p> Source code in <code>src/otg/method/l2g/trainer.py</code> <pre><code>@classmethod\ndef train(\n    cls: type[LocusToGeneTrainer],\n    data: L2GFeatureMatrix,\n    l2g_model: LocusToGeneModel,\n    features_list: list[str],\n    evaluate: bool,\n    wandb_run_name: str | None = None,\n    model_path: str | None = None,\n    **hyperparams: dict[str, Any],\n) -&gt; LocusToGeneModel:\n    \"\"\"Train the Locus to Gene model.\n\n    Args:\n        data (L2GFeatureMatrix): Feature matrix containing the data\n        l2g_model (LocusToGeneModel): Model to fit to the data on\n        features_list (list[str]): List of features to use for the model\n        evaluate (bool): Whether to evaluate the model on a test set\n        wandb_run_name (str | None): Descriptive name for the run to be tracked with W&amp;B\n        model_path (str | None): Path to save the model to\n        **hyperparams (dict[str, Any]): Hyperparameters to use for the model\n\n    Returns:\n        LocusToGeneModel: Trained model\n    \"\"\"\n    train, test = data.select_features(features_list).train_test_split(fraction=0.8)\n\n    model = l2g_model.add_pipeline_stage(l2g_model.estimator).fit(train)\n\n    if evaluate:\n        l2g_model.evaluate(\n            results=model.predict(test),\n            hyperparameters=hyperparams,\n            wandb_run_name=wandb_run_name,\n        )\n    if model_path:\n        l2g_model.save(model_path)\n    return l2g_model\n</code></pre>"},{"location":"python_api/step/_step/","title":"Step","text":"<p>TBC</p>"},{"location":"python_api/step/colocalisation/","title":"Colocalisation","text":""},{"location":"python_api/step/colocalisation/#otg.colocalisation.ColocalisationStep","title":"<code>otg.colocalisation.ColocalisationStep</code>  <code>dataclass</code>","text":"<p>Colocalisation step.</p> <p>This workflow runs colocalization analyses that assess the degree to which independent signals of the association share the same causal variant in a region of the genome, typically limited by linkage disequilibrium (LD).</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>study_locus_path</code> <code>DictConfig</code> <p>Input Study-locus path.</p> <code>coloc_path</code> <code>DictConfig</code> <p>Output Colocalisation path.</p> <code>priorc1</code> <code>float</code> <p>Prior on variant being causal for trait 1.</p> <code>priorc2</code> <code>float</code> <p>Prior on variant being causal for trait 2.</p> <code>priorc12</code> <code>float</code> <p>Prior on variant being causal for traits 1 and 2.</p> Source code in <code>src/otg/colocalisation.py</code> <pre><code>@dataclass\nclass ColocalisationStep:\n    \"\"\"Colocalisation step.\n\n    This workflow runs colocalization analyses that assess the degree to which independent signals of the association share the same causal variant in a region of the genome, typically limited by linkage disequilibrium (LD).\n\n    Attributes:\n        session (Session): Session object.\n        study_locus_path (DictConfig): Input Study-locus path.\n        coloc_path (DictConfig): Output Colocalisation path.\n        priorc1 (float): Prior on variant being causal for trait 1.\n        priorc2 (float): Prior on variant being causal for trait 2.\n        priorc12 (float): Prior on variant being causal for traits 1 and 2.\n    \"\"\"\n\n    session: Session = MISSING\n    study_locus_path: str = MISSING\n    study_index_path: str = MISSING\n    coloc_path: str = MISSING\n    priorc1: float = 1e-4\n    priorc2: float = 1e-4\n    priorc12: float = 1e-5\n\n    def __post_init__(self: ColocalisationStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Study-locus information\n        sl = StudyLocus.from_parquet(self.session, self.study_locus_path)\n        si = StudyIndex.from_parquet(self.session, self.study_index_path)\n\n        # Study-locus overlaps for 95% credible sets\n        sl_overlaps = sl.filter_credible_set(CredibleInterval.IS95).find_overlaps(si)\n\n        coloc_results = Coloc.colocalise(\n            sl_overlaps, self.priorc1, self.priorc2, self.priorc12\n        )\n        ecaviar_results = ECaviar.colocalise(sl_overlaps)\n\n        coloc_results.df.unionByName(ecaviar_results.df, allowMissingColumns=True)\n\n        coloc_results.df.write.mode(self.session.write_mode).parquet(self.coloc_path)\n</code></pre>"},{"location":"python_api/step/eqtl_catalogue/","title":"eQTL Catalogue","text":""},{"location":"python_api/step/eqtl_catalogue/#otg.eqtl_catalogue.EqtlCatalogueStep","title":"<code>otg.eqtl_catalogue.EqtlCatalogueStep</code>  <code>dataclass</code>","text":"<p>eQTL Catalogue ingestion step.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>eqtl_catalogue_paths_imported</code> <code>str</code> <p>eQTL Catalogue input files for the harmonised and imported data.</p> <code>eqtl_catalogue_study_index_out</code> <code>str</code> <p>Output path for the eQTL Catalogue study index dataset.</p> <code>eqtl_catalogue_summary_stats_out</code> <code>str</code> <p>Output path for the eQTL Catalogue summary stats.</p> Source code in <code>src/otg/eqtl_catalogue.py</code> <pre><code>@dataclass\nclass EqtlCatalogueStep:\n    \"\"\"eQTL Catalogue ingestion step.\n\n    Attributes:\n        session (Session): Session object.\n        eqtl_catalogue_paths_imported (str): eQTL Catalogue input files for the harmonised and imported data.\n        eqtl_catalogue_study_index_out (str): Output path for the eQTL Catalogue study index dataset.\n        eqtl_catalogue_summary_stats_out (str): Output path for the eQTL Catalogue summary stats.\n    \"\"\"\n\n    session: Session = MISSING\n\n    eqtl_catalogue_paths_imported: str = MISSING\n    eqtl_catalogue_study_index_out: str = MISSING\n    eqtl_catalogue_summary_stats_out: str = MISSING\n\n    def __post_init__(self: EqtlCatalogueStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Fetch study index.\n        df = self.session.spark.read.option(\"delimiter\", \"\\t\").csv(\n            self.eqtl_catalogue_paths_imported, header=True\n        )\n        # Process partial study index.  At this point, it is not complete because we don't have the gene IDs, which we\n        # will only get once the summary stats are ingested.\n        study_index_df = EqtlCatalogueStudyIndex.from_source(df).df\n\n        # Fetch summary stats.\n        input_filenames = [row.summarystatsLocation for row in study_index_df.collect()]\n        summary_stats_df = (\n            self.session.spark.read.option(\"delimiter\", \"\\t\")\n            .csv(input_filenames, header=True)\n            .repartition(1280)\n        )\n        # Process summary stats.\n        summary_stats_df = EqtlCatalogueSummaryStats.from_source(summary_stats_df).df\n\n        # Add geneId column to the study index.\n        study_index_df = EqtlCatalogueStudyIndex.add_gene_id_column(\n            study_index_df,\n            summary_stats_df,\n        ).df\n\n        # Write study index.\n        study_index_df.write.mode(self.session.write_mode).parquet(\n            self.eqtl_catalogue_study_index_out\n        )\n        # Write summary stats.\n        (\n            summary_stats_df.sortWithinPartitions(\"position\")\n            .write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.eqtl_catalogue_summary_stats_out)\n        )\n</code></pre>"},{"location":"python_api/step/finngen/","title":"FinnGen","text":""},{"location":"python_api/step/finngen/#otg.finngen.FinnGenStep","title":"<code>otg.finngen.FinnGenStep</code>  <code>dataclass</code>","text":"<p>FinnGen ingestion step.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>finngen_phenotype_table_url</code> <code>str</code> <p>FinnGen API for fetching the list of studies.</p> <code>finngen_release_prefix</code> <code>str</code> <p>Release prefix pattern.</p> <code>finngen_sumstat_url_prefix</code> <code>str</code> <p>URL prefix for summary statistics location.</p> <code>finngen_sumstat_url_suffix</code> <code>str</code> <p>URL prefix suffix for summary statistics location.</p> <code>finngen_study_index_out</code> <code>str</code> <p>Output path for the FinnGen study index dataset.</p> <code>finngen_summary_stats_out</code> <code>str</code> <p>Output path for the FinnGen summary statistics.</p> Source code in <code>src/otg/finngen.py</code> <pre><code>@dataclass\nclass FinnGenStep:\n    \"\"\"FinnGen ingestion step.\n\n    Attributes:\n        session (Session): Session object.\n        finngen_phenotype_table_url (str): FinnGen API for fetching the list of studies.\n        finngen_release_prefix (str): Release prefix pattern.\n        finngen_sumstat_url_prefix (str): URL prefix for summary statistics location.\n        finngen_sumstat_url_suffix (str): URL prefix suffix for summary statistics location.\n        finngen_study_index_out (str): Output path for the FinnGen study index dataset.\n        finngen_summary_stats_out (str): Output path for the FinnGen summary statistics.\n    \"\"\"\n\n    session: Session = MISSING\n    finngen_phenotype_table_url: str = MISSING\n    finngen_release_prefix: str = MISSING\n    finngen_sumstat_url_prefix: str = MISSING\n    finngen_sumstat_url_suffix: str = MISSING\n    finngen_study_index_out: str = MISSING\n    finngen_summary_stats_out: str = MISSING\n\n    def __post_init__(self: FinnGenStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Fetch study index.\n        json_data = urlopen(self.finngen_phenotype_table_url).read().decode(\"utf-8\")\n        rdd = self.session.spark.sparkContext.parallelize([json_data])\n        df = self.session.spark.read.json(rdd)\n        # Process study index.\n        study_index = FinnGenStudyIndex.from_source(\n            df,\n            self.finngen_release_prefix,\n            self.finngen_sumstat_url_prefix,\n            self.finngen_sumstat_url_suffix,\n        )\n        # Write study index.\n        study_index.df.write.mode(self.session.write_mode).parquet(\n            self.finngen_study_index_out\n        )\n\n        # Fetch summary stats.\n        input_filenames = [row.summarystatsLocation for row in study_index.df.collect()]\n        summary_stats_df = self.session.spark.read.option(\"delimiter\", \"\\t\").csv(\n            input_filenames, header=True\n        )\n        # Process summary stats.\n        summary_stats_df = FinnGenSummaryStats.from_source(summary_stats_df).df\n        # Write summary stats.\n        (\n            summary_stats_df.sortWithinPartitions(\"position\")\n            .write.partitionBy(\"studyId\", \"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.finngen_summary_stats_out)\n        )\n</code></pre>"},{"location":"python_api/step/gene_index/","title":"Gene Index","text":""},{"location":"python_api/step/gene_index/#otg.gene_index.GeneIndexStep","title":"<code>otg.gene_index.GeneIndexStep</code>  <code>dataclass</code>","text":"<p>Gene index step.</p> <p>This step generates a gene index dataset from an Open Targets Platform target dataset.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>target_path</code> <code>str</code> <p>Open targets Platform target dataset path.</p> <code>gene_index_path</code> <code>str</code> <p>Output gene index path.</p> Source code in <code>src/otg/gene_index.py</code> <pre><code>@dataclass\nclass GeneIndexStep:\n    \"\"\"Gene index step.\n\n    This step generates a gene index dataset from an Open Targets Platform target dataset.\n\n    Attributes:\n        session (Session): Session object.\n        target_path (str): Open targets Platform target dataset path.\n        gene_index_path (str): Output gene index path.\n    \"\"\"\n\n    session: Session = MISSING\n    target_path: str = MISSING\n    gene_index_path: str = MISSING\n\n    def __post_init__(self: GeneIndexStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Extract\n        platform_target = self.session.spark.read.parquet(self.target_path)\n        # Transform\n        gene_index = OpenTargetsTarget.as_gene_index(platform_target)\n        # Load\n        gene_index.df.write.mode(self.session.write_mode).parquet(self.gene_index_path)\n</code></pre>"},{"location":"python_api/step/gwas_catalog/","title":"GWAS Catalog","text":""},{"location":"python_api/step/gwas_catalog/#otg.gwas_catalog.GWASCatalogStep","title":"<code>otg.gwas_catalog.GWASCatalogStep</code>  <code>dataclass</code>","text":"<p>GWAS Catalog ingestion step to extract GWASCatalog Study and StudyLocus tables.</p> <p>!!!note This step currently only processes the GWAS Catalog curated list of top hits.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>catalog_studies_file</code> <code>str</code> <p>Raw GWAS catalog studies file.</p> <code>catalog_ancestry_file</code> <code>str</code> <p>Ancestry annotations file from GWAS Catalog.</p> <code>catalog_sumstats_lut</code> <code>str</code> <p>GWAS Catalog summary statistics lookup table.</p> <code>catalog_associations_file</code> <code>str</code> <p>Raw GWAS catalog associations file.</p> <code>variant_annotation_path</code> <code>str</code> <p>Input variant annotation path.</p> <code>ld_populations</code> <code>list</code> <p>List of populations to include.</p> <code>min_r2</code> <code>float</code> <p>Minimum r2 to consider when considering variants within a window.</p> <code>catalog_studies_out</code> <code>str</code> <p>Output GWAS catalog studies path.</p> <code>catalog_associations_out</code> <code>str</code> <p>Output GWAS catalog associations path.</p> Source code in <code>src/otg/gwas_catalog.py</code> <pre><code>@dataclass\nclass GWASCatalogStep:\n    \"\"\"GWAS Catalog ingestion step to extract GWASCatalog Study and StudyLocus tables.\n\n    !!!note This step currently only processes the GWAS Catalog curated list of top hits.\n\n    Attributes:\n        session (Session): Session object.\n        catalog_studies_file (str): Raw GWAS catalog studies file.\n        catalog_ancestry_file (str): Ancestry annotations file from GWAS Catalog.\n        catalog_sumstats_lut (str): GWAS Catalog summary statistics lookup table.\n        catalog_associations_file (str): Raw GWAS catalog associations file.\n        variant_annotation_path (str): Input variant annotation path.\n        ld_populations (list): List of populations to include.\n        min_r2 (float): Minimum r2 to consider when considering variants within a window.\n        catalog_studies_out (str): Output GWAS catalog studies path.\n        catalog_associations_out (str): Output GWAS catalog associations path.\n    \"\"\"\n\n    session: Session = MISSING\n    catalog_studies_file: str = MISSING\n    catalog_ancestry_file: str = MISSING\n    catalog_sumstats_lut: str = MISSING\n    catalog_associations_file: str = MISSING\n    variant_annotation_path: str = MISSING\n    ld_index_path: str = MISSING\n    min_r2: float = 0.5\n    catalog_studies_out: str = MISSING\n    catalog_associations_out: str = MISSING\n\n    def __post_init__(self: GWASCatalogStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Extract\n        va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n        catalog_studies = self.session.spark.read.csv(\n            self.catalog_studies_file, sep=\"\\t\", header=True\n        )\n        ancestry_lut = self.session.spark.read.csv(\n            self.catalog_ancestry_file, sep=\"\\t\", header=True\n        )\n        sumstats_lut = self.session.spark.read.csv(\n            self.catalog_sumstats_lut, sep=\"\\t\", header=False\n        )\n        catalog_associations = self.session.spark.read.csv(\n            self.catalog_associations_file, sep=\"\\t\", header=True\n        ).persist()\n        ld_index = LDIndex.from_parquet(self.session, self.ld_index_path)\n\n        # Transform\n        study_index, study_locus = GWASCatalogStudySplitter.split(\n            GWASCatalogStudyIndex.from_source(\n                catalog_studies, ancestry_lut, sumstats_lut\n            ),\n            GWASCatalogAssociations.from_source(catalog_associations, va),\n        )\n        study_locus_ld = LDAnnotator.ld_annotate(\n            study_locus, study_index, ld_index\n        ).clump()\n        finemapped_study_locus = PICS.finemap(study_locus_ld).annotate_credible_sets()\n\n        # Load\n        study_index.df.write.mode(self.session.write_mode).parquet(\n            self.catalog_studies_out\n        )\n        finemapped_study_locus.df.write.mode(self.session.write_mode).parquet(\n            self.catalog_associations_out\n        )\n</code></pre>"},{"location":"python_api/step/gwas_catalog_sumstat_preprocess/","title":"GWAS Catalog sumstat preprocess","text":""},{"location":"python_api/step/gwas_catalog_sumstat_preprocess/#otg.gwas_catalog_sumstat_preprocess.GWASCatalogSumstatsPreprocessStep","title":"<code>otg.gwas_catalog_sumstat_preprocess.GWASCatalogSumstatsPreprocessStep</code>  <code>dataclass</code>","text":"<p>Step to preprocess GWAS Catalog harmonised summary stats.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>raw_sumstats_path</code> <code>str</code> <p>Input raw GWAS Catalog summary statistics path.</p> <code>out_sumstats_path</code> <code>str</code> <p>Output GWAS Catalog summary statistics path.</p> Source code in <code>src/otg/gwas_catalog_sumstat_preprocess.py</code> <pre><code>@dataclass\nclass GWASCatalogSumstatsPreprocessStep:\n    \"\"\"Step to preprocess GWAS Catalog harmonised summary stats.\n\n    Attributes:\n        session (Session): Session object.\n        raw_sumstats_path (str): Input raw GWAS Catalog summary statistics path.\n        out_sumstats_path (str): Output GWAS Catalog summary statistics path.\n    \"\"\"\n\n    session: Session = MISSING\n    raw_sumstats_path: str = MISSING\n    out_sumstats_path: str = MISSING\n\n    def __post_init__(self: GWASCatalogSumstatsPreprocessStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Extract\n        self.session.logger.info(self.raw_sumstats_path)\n        self.session.logger.info(self.out_sumstats_path)\n\n        self.session.logger.info(\n            f\"Ingesting summary stats from: {self.raw_sumstats_path}\"\n        )\n\n        # Processing dataset:\n        GWASCatalogSummaryStatistics.from_gwas_harmonized_summary_stats(\n            self.session.spark, self.raw_sumstats_path\n        ).df.write.mode(self.session.write_mode).parquet(self.out_sumstats_path)\n        self.session.logger.info(\"Processing dataset successfully completed.\")\n</code></pre>"},{"location":"python_api/step/l2g/","title":"Locus-to-gene (L2G)","text":""},{"location":"python_api/step/l2g/#otg.l2g.LocusToGeneStep","title":"<code>otg.l2g.LocusToGeneStep</code>  <code>dataclass</code>","text":"<p>Locus to gene step.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>extended_spark_conf</code> <code>dict[str, str] | None</code> <p>Extended Spark configuration.</p> <code>run_mode</code> <code>str</code> <p>One of \"train\" or \"predict\".</p> <code>wandb_run_name</code> <code>str | None</code> <p>Name of the run to be tracked on W&amp;B.</p> <code>perform_cross_validation</code> <code>bool</code> <p>Whether to perform cross validation.</p> <code>model_path</code> <code>str | None</code> <p>Path to save the model.</p> <code>predictions_path</code> <code>str | None</code> <p>Path to save the predictions.</p> <code>credible_set_path</code> <code>str</code> <p>Path to credible set Parquet files.</p> <code>variant_gene_path</code> <code>str</code> <p>Path to variant to gene Parquet files.</p> <code>colocalisation_path</code> <code>str</code> <p>Path to colocalisation Parquet files.</p> <code>study_index_path</code> <code>str</code> <p>Path to study index Parquet files.</p> <code>study_locus_overlap_path</code> <code>str</code> <p>Path to study locus overlap Parquet files.</p> <code>gold_standard_curation_path</code> <code>str | None</code> <p>Path to gold standard curation JSON files.</p> <code>gene_interactions_path</code> <code>str | None</code> <p>Path to gene interactions Parquet files.</p> <code>features_list</code> <code>list[str]</code> <p>List of features to use.</p> <code>hyperparameters</code> <code>dict</code> <p>Hyperparameters for the model.</p> Source code in <code>src/otg/l2g.py</code> <pre><code>@dataclass\nclass LocusToGeneStep:\n    \"\"\"Locus to gene step.\n\n    Attributes:\n        session (Session): Session object.\n        extended_spark_conf (dict[str, str] | None): Extended Spark configuration.\n        run_mode (str): One of \"train\" or \"predict\".\n        wandb_run_name (str | None): Name of the run to be tracked on W&amp;B.\n        perform_cross_validation (bool): Whether to perform cross validation.\n        model_path (str | None): Path to save the model.\n        predictions_path (str | None): Path to save the predictions.\n        credible_set_path (str): Path to credible set Parquet files.\n        variant_gene_path (str): Path to variant to gene Parquet files.\n        colocalisation_path (str): Path to colocalisation Parquet files.\n        study_index_path (str): Path to study index Parquet files.\n        study_locus_overlap_path (str): Path to study locus overlap Parquet files.\n        gold_standard_curation_path (str | None): Path to gold standard curation JSON files.\n        gene_interactions_path (str | None): Path to gene interactions Parquet files.\n        features_list (list[str]): List of features to use.\n        hyperparameters (dict): Hyperparameters for the model.\n    \"\"\"\n\n    extended_spark_conf: dict[str, str] | None = None\n\n    session: Session = MISSING\n    run_mode: str = MISSING\n    wandb_run_name: str | None = None\n    perform_cross_validation: bool = False\n    model_path: str = MISSING\n    predictions_path: str = MISSING\n    credible_set_path: str = MISSING\n    variant_gene_path: str = MISSING\n    colocalisation_path: str = MISSING\n    study_index_path: str = MISSING\n    study_locus_overlap_path: str = MISSING\n    gold_standard_curation_path: str = MISSING\n    gene_interactions_path: str = MISSING\n    features_list: list[str] = field(\n        default_factory=lambda: [\n            # average distance of all tagging variants to gene TSS\n            \"distanceTssMean\",\n            # # minimum distance of all tagging variants to gene TSS\n            # \"distanceTssMinimum\",\n            # # max clpp for each (study, locus, gene) aggregating over all eQTLs\n            # \"eqtlColocClppLocalMaximum\",\n            # # max clpp for each (study, locus) aggregating over all eQTLs\n            # \"eqtlColocClppNeighborhoodMaximum\",\n            # # max log-likelihood ratio value for each (study, locus, gene) aggregating over all eQTLs\n            # \"eqtlColocLlrLocalMaximum\",\n            # # max log-likelihood ratio value for each (study, locus) aggregating over all eQTLs\n            # \"eqtlColocLlrNeighborhoodMaximum\",\n            # # max clpp for each (study, locus, gene) aggregating over all pQTLs\n            # \"pqtlColocClppLocalMaximum\",\n            # # max clpp for each (study, locus) aggregating over all pQTLs\n            # \"pqtlColocClppNeighborhoodMaximum\",\n            # # max log-likelihood ratio value for each (study, locus, gene) aggregating over all pQTLs\n            # \"pqtlColocLlrLocalMaximum\",\n            # # max log-likelihood ratio value for each (study, locus) aggregating over all pQTLs\n            # \"pqtlColocLlrNeighborhoodMaximum\",\n            # # max clpp for each (study, locus, gene) aggregating over all sQTLs\n            # \"sqtlColocClppLocalMaximum\",\n            # # max clpp for each (study, locus) aggregating over all sQTLs\n            # \"sqtlColocClppNeighborhoodMaximum\",\n            # # max log-likelihood ratio value for each (study, locus, gene) aggregating over all sQTLs\n            # \"sqtlColocLlrLocalMaximum\",\n            # # max log-likelihood ratio value for each (study, locus) aggregating over all sQTLs\n            # \"sqtlColocLlrNeighborhoodMaximum\",\n        ]\n    )\n    hyperparameters: dict[str, Any] = field(\n        default_factory=lambda: {\n            \"max_depth\": 5,\n            \"loss_function\": \"binary:logistic\",\n        }\n    )\n\n    def __post_init__(self: LocusToGeneStep) -&gt; None:\n        \"\"\"Run step.\n\n        Raises:\n            ValueError: if run_mode is not one of \"train\" or \"predict\".\n        \"\"\"\n        if self.run_mode not in [\"train\", \"predict\"]:\n            raise ValueError(\n                f\"run_mode must be one of 'train' or 'predict', got {self.run_mode}\"\n            )\n        # Load common inputs\n        credible_set = StudyLocus.from_parquet(\n            self.session, self.credible_set_path, recursiveFileLookup=True\n        )\n        studies = StudyIndex.from_parquet(self.session, self.study_index_path)\n        v2g = V2G.from_parquet(self.session, self.variant_gene_path)\n        # coloc = Colocalisation.from_parquet(self.session, self.colocalisation_path) # TODO: run step\n\n        if self.run_mode == \"train\":\n            # Process gold standard and L2G features\n            study_locus_overlap = StudyLocusOverlap.from_parquet(\n                self.session, self.study_locus_overlap_path\n            )\n            gs_curation = self.session.spark.read.json(self.gold_standard_curation_path)\n            interactions = self.session.spark.read.parquet(self.gene_interactions_path)\n\n            gold_standards = L2GGoldStandard.from_otg_curation(\n                gold_standard_curation=gs_curation,\n                v2g=v2g,\n                study_locus_overlap=study_locus_overlap,\n                interactions=interactions,\n            )\n\n            fm = L2GFeatureMatrix.generate_features(\n                study_locus=credible_set,\n                study_index=studies,\n                variant_gene=v2g,\n                # colocalisation=coloc,\n            )\n\n            # Join and fill null values with 0\n            data = L2GFeatureMatrix(\n                _df=gold_standards.df.drop(\"sources\").join(\n                    fm.df, on=[\"studyLocusId\", \"geneId\"], how=\"inner\"\n                ),\n                _schema=L2GFeatureMatrix.get_schema(),\n            ).fill_na()\n\n            # Instantiate classifier\n            estimator = SparkXGBClassifier(\n                eval_metric=\"logloss\",\n                features_col=\"features\",\n                label_col=\"label\",\n                max_depth=5,\n            )\n            l2g_model = LocusToGeneModel(\n                features_list=list(self.features_list), estimator=estimator\n            )\n            if self.perform_cross_validation:\n                # Perform cross validation to extract what are the best hyperparameters\n                cv_folds = self.hyperparameters.get(\"cross_validation_folds\", 5)\n                LocusToGeneTrainer.cross_validate(\n                    l2g_model=l2g_model,\n                    data=data,\n                    num_folds=cv_folds,\n                )\n            else:\n                # Train model\n                model = LocusToGeneTrainer.train(\n                    data=data,\n                    l2g_model=l2g_model,\n                    features_list=list(self.features_list),\n                    model_path=self.model_path,\n                    evaluate=True,\n                    wandb_run_name=self.wandb_run_name,\n                    **self.hyperparameters,\n                )\n                model.save(self.model_path)\n                self.session.logger.info(\n                    f\"Finished L2G step. L2G model saved to {self.model_path}\"\n                )\n\n        if self.run_mode == \"predict\":\n            if not self.model_path or not self.predictions_path:\n                raise ValueError(\n                    \"model_path and predictions_path must be set for predict mode.\"\n                )\n            predictions = L2GPrediction.from_credible_set(\n                self.model_path,\n                credible_set,\n                studies,\n                v2g,\n                # coloc\n            )\n            predictions.df.write.mode(self.session.write_mode).parquet(\n                self.predictions_path\n            )\n            self.session.logger.info(\n                f\"Finished L2G step. L2G predictions saved to {self.predictions_path}\"\n            )\n</code></pre>"},{"location":"python_api/step/ld_index/","title":"LD Index","text":""},{"location":"python_api/step/ld_index/#otg.ld_index.LDIndexStep","title":"<code>otg.ld_index.LDIndexStep</code>  <code>dataclass</code>","text":"<p>LD index step.</p> <p>This step is resource intensive</p> <p>Suggested params: high memory machine, 5TB of boot disk, no SSDs.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>min_r2</code> <code>float</code> <p>Minimum r2 to consider when considering variants within a window.</p> <code>ld_index_out</code> <code>str</code> <p>Output LD index path.</p> Source code in <code>src/otg/ld_index.py</code> <pre><code>@dataclass\nclass LDIndexStep:\n    \"\"\"LD index step.\n\n    !!! warning \"This step is resource intensive\"\n        Suggested params: high memory machine, 5TB of boot disk, no SSDs.\n\n    Attributes:\n        session (Session): Session object.\n        min_r2 (float): Minimum r2 to consider when considering variants within a window.\n        ld_index_out (str): Output LD index path.\n    \"\"\"\n\n    session: Session = MISSING\n\n    min_r2: float = 0.5\n    ld_index_out: str = MISSING\n\n    def __post_init__(self: LDIndexStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n        (\n            GnomADLDMatrix()\n            .as_ld_index(self.min_r2)\n            .df.write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.ld_index_out)\n        )\n        self.session.logger.info(f\"LD index written to: {self.ld_index_out}\")\n</code></pre>"},{"location":"python_api/step/pics/","title":"PICS","text":""},{"location":"python_api/step/pics/#otg.pics.PICSStep","title":"<code>otg.pics.PICSStep</code>  <code>dataclass</code>","text":"<p>PICS finemapping of LD-annotated StudyLocus.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>study_locus_ld_annotated_in</code> <code>str</code> <p>Path to Study Locus with the LD information annotated</p> <code>picsed_study_locus_out</code> <code>str</code> <p>Path to Study Locus after running PICS</p> Source code in <code>src/otg/pics.py</code> <pre><code>@dataclass\nclass PICSStep:\n    \"\"\"PICS finemapping of LD-annotated StudyLocus.\n\n    Attributes:\n        session (Session): Session object.\n\n        study_locus_ld_annotated_in (str): Path to Study Locus with the LD information annotated\n        picsed_study_locus_out (str): Path to Study Locus after running PICS\n    \"\"\"\n\n    session: Session = MISSING\n    study_locus_ld_annotated_in: str = MISSING\n    picsed_study_locus_out: str = MISSING\n\n    def __post_init__(self: PICSStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Extract\n        study_locus_ld_annotated = StudyLocus.from_parquet(\n            self.session, self.study_locus_ld_annotated_in\n        )\n        # PICS\n        picsed_sl = PICS.finemap(study_locus_ld_annotated).annotate_credible_sets()\n        # Write\n        picsed_sl.df.write.mode(self.session.write_mode).parquet(\n            self.picsed_study_locus_out\n        )\n</code></pre>"},{"location":"python_api/step/ukbiobank/","title":"UK Biobank","text":""},{"location":"python_api/step/ukbiobank/#otg.ukbiobank.UKBiobankStep","title":"<code>otg.ukbiobank.UKBiobankStep</code>  <code>dataclass</code>","text":"<p>UKBiobank study table ingestion step.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>ukbiobank_manifest</code> <code>str</code> <p>UKBiobank manifest of studies.</p> <code>ukbiobank_study_index_out</code> <code>str</code> <p>Output path for the UKBiobank study index dataset.</p> Source code in <code>src/otg/ukbiobank.py</code> <pre><code>@dataclass\nclass UKBiobankStep:\n    \"\"\"UKBiobank study table ingestion step.\n\n    Attributes:\n        session (Session): Session object.\n        ukbiobank_manifest (str): UKBiobank manifest of studies.\n        ukbiobank_study_index_out (str): Output path for the UKBiobank study index dataset.\n    \"\"\"\n\n    session: Session = MISSING\n    ukbiobank_manifest: str = MISSING\n    ukbiobank_study_index_out: str = MISSING\n\n    def __post_init__(self: UKBiobankStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Read in the UKBiobank manifest tsv file.\n        df = self.session.spark.read.csv(\n            self.ukbiobank_manifest, sep=\"\\t\", header=True, inferSchema=True\n        )\n\n        # Parse the study index data.\n        ukbiobank_study_index = UKBiobankStudyIndex.from_source(df)\n\n        # Write the output.\n        ukbiobank_study_index.df.write.mode(self.session.write_mode).parquet(\n            self.ukbiobank_study_index_out\n        )\n</code></pre>"},{"location":"python_api/step/variant_annotation_step/","title":"Variant Annotation","text":""},{"location":"python_api/step/variant_annotation_step/#otg.variant_annotation.VariantAnnotationStep","title":"<code>otg.variant_annotation.VariantAnnotationStep</code>  <code>dataclass</code>","text":"<p>Variant annotation step.</p> <p>Variant annotation step produces a dataset of the type <code>VariantAnnotation</code> derived from gnomADs <code>gnomad.genomes.vX.X.X.sites.ht</code> Hail's table. This dataset is used to validate variants and as a source of annotation.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>variant_annotation_path</code> <code>str</code> <p>Output variant annotation path.</p> Source code in <code>src/otg/variant_annotation.py</code> <pre><code>@dataclass\nclass VariantAnnotationStep:\n    \"\"\"Variant annotation step.\n\n    Variant annotation step produces a dataset of the type `VariantAnnotation` derived from gnomADs `gnomad.genomes.vX.X.X.sites.ht` Hail's table. This dataset is used to validate variants and as a source of annotation.\n\n    Attributes:\n        session (Session): Session object.\n        variant_annotation_path (str): Output variant annotation path.\n    \"\"\"\n\n    session: Session = MISSING\n    variant_annotation_path: str = MISSING\n\n    def __post_init__(self: VariantAnnotationStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Initialise hail session.\n        hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n        # Run variant annotation.\n        variant_annotation = GnomADVariants().as_variant_annotation()\n        # Write data partitioned by chromosome and position.\n        (\n            variant_annotation.df.repartition(400, \"chromosome\")\n            .sortWithinPartitions(\"chromosome\", \"position\")\n            .write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.variant_annotation_path)\n        )\n</code></pre>"},{"location":"python_api/step/variant_index_step/","title":"Variant Index","text":""},{"location":"python_api/step/variant_index_step/#otg.variant_index.VariantIndexStep","title":"<code>otg.variant_index.VariantIndexStep</code>  <code>dataclass</code>","text":"<p>Run variant index step to only variants in study-locus sets.</p> <p>Using a <code>VariantAnnotation</code> dataset as a reference, this step creates and writes a dataset of the type <code>VariantIndex</code> that includes only variants that have disease-association data with a reduced set of annotations.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>variant_annotation_path</code> <code>str</code> <p>Input variant annotation path.</p> <code>study_locus_path</code> <code>str</code> <p>Input study-locus path.</p> <code>variant_index_path</code> <code>str</code> <p>Output variant index path.</p> Source code in <code>src/otg/variant_index.py</code> <pre><code>@dataclass\nclass VariantIndexStep:\n    \"\"\"Run variant index step to only variants in study-locus sets.\n\n    Using a `VariantAnnotation` dataset as a reference, this step creates and writes a dataset of the type `VariantIndex` that includes only variants that have disease-association data with a reduced set of annotations.\n\n    Attributes:\n        session (Session): Session object.\n        variant_annotation_path (str): Input variant annotation path.\n        study_locus_path (str): Input study-locus path.\n        variant_index_path (str): Output variant index path.\n    \"\"\"\n\n    session: Session = MISSING\n    variant_annotation_path: str = MISSING\n    study_locus_path: str = MISSING\n    variant_index_path: str = MISSING\n\n    def __post_init__(self: VariantIndexStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Extract\n        va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n        study_locus = StudyLocus.from_parquet(\n            self.session, self.study_locus_path, recursiveFileLookup=True\n        )\n\n        # Transform\n        vi = VariantIndex.from_variant_annotation(va, study_locus)\n\n        # Load\n        self.session.logger.info(f\"Writing variant index to: {self.variant_index_path}\")\n        (\n            vi.df.write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.variant_index_path)\n        )\n</code></pre>"},{"location":"python_api/step/variant_to_gene_step/","title":"Variant-to-gene","text":""},{"location":"python_api/step/variant_to_gene_step/#otg.v2g.V2GStep","title":"<code>otg.v2g.V2GStep</code>  <code>dataclass</code>","text":"<p>Variant-to-gene (V2G) step.</p> <p>This step aims to generate a dataset that contains multiple pieces of evidence supporting the functional association of specific variants with genes. Some of the evidence types include:</p> <ol> <li>Chromatin interaction experiments, e.g. Promoter Capture Hi-C (PCHi-C).</li> <li>In silico functional predictions, e.g. Variant Effect Predictor (VEP) from Ensembl.</li> <li>Distance between the variant and each gene's canonical transcription start site (TSS).</li> </ol> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>Session object.</p> <code>variant_index_path</code> <code>str</code> <p>Input variant index path.</p> <code>variant_annotation_path</code> <code>str</code> <p>Input variant annotation path.</p> <code>gene_index_path</code> <code>str</code> <p>Input gene index path.</p> <code>vep_consequences_path</code> <code>str</code> <p>Input VEP consequences path.</p> <code>liftover_chain_file_path</code> <code>str</code> <p>Path to GRCh37 to GRCh38 chain file.</p> <code>liftover_max_length_difference</code> <code>int</code> <p>Maximum length difference for liftover.</p> <code>max_distance</code> <code>int</code> <p>Maximum distance to consider.</p> <code>approved_biotypes</code> <code>list[str]</code> <p>List of approved biotypes.</p> <code>intervals</code> <code>dict</code> <p>Dictionary of interval sources.</p> <code>v2g_path</code> <code>str</code> <p>Output V2G path.</p> Source code in <code>src/otg/v2g.py</code> <pre><code>@dataclass\nclass V2GStep:\n    \"\"\"Variant-to-gene (V2G) step.\n\n    This step aims to generate a dataset that contains multiple pieces of evidence supporting the functional association of specific variants with genes. Some of the evidence types include:\n\n    1. Chromatin interaction experiments, e.g. Promoter Capture Hi-C (PCHi-C).\n    2. In silico functional predictions, e.g. Variant Effect Predictor (VEP) from Ensembl.\n    3. Distance between the variant and each gene's canonical transcription start site (TSS).\n\n    Attributes:\n        session (Session): Session object.\n        variant_index_path (str): Input variant index path.\n        variant_annotation_path (str): Input variant annotation path.\n        gene_index_path (str): Input gene index path.\n        vep_consequences_path (str): Input VEP consequences path.\n        liftover_chain_file_path (str): Path to GRCh37 to GRCh38 chain file.\n        liftover_max_length_difference: Maximum length difference for liftover.\n        max_distance (int): Maximum distance to consider.\n        approved_biotypes (list[str]): List of approved biotypes.\n        intervals (dict): Dictionary of interval sources.\n        v2g_path (str): Output V2G path.\n    \"\"\"\n\n    session: Session = MISSING\n    variant_index_path: str = MISSING\n    variant_annotation_path: str = MISSING\n    gene_index_path: str = MISSING\n    vep_consequences_path: str = MISSING\n    liftover_chain_file_path: str = MISSING\n    liftover_max_length_difference: int = 100\n    max_distance: int = 500_000\n    approved_biotypes: List[str] = field(\n        default_factory=lambda: [\n            \"protein_coding\",\n            \"3prime_overlapping_ncRNA\",\n            \"antisense\",\n            \"bidirectional_promoter_lncRNA\",\n            \"IG_C_gene\",\n            \"IG_D_gene\",\n            \"IG_J_gene\",\n            \"IG_V_gene\",\n            \"lincRNA\",\n            \"macro_lncRNA\",\n            \"non_coding\",\n            \"sense_intronic\",\n            \"sense_overlapping\",\n        ]\n    )\n    intervals: Dict[str, str] = field(default_factory=dict)\n    v2g_path: str = MISSING\n\n    def __post_init__(self: V2GStep) -&gt; None:\n        \"\"\"Run step.\"\"\"\n        # Read\n        gene_index = GeneIndex.from_parquet(self.session, self.gene_index_path)\n        vi = VariantIndex.from_parquet(self.session, self.variant_index_path).persist()\n        va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n        vep_consequences = self.session.spark.read.csv(\n            self.vep_consequences_path, sep=\"\\t\", header=True\n        ).select(\n            f.element_at(f.split(\"Accession\", r\"/\"), -1).alias(\n                \"variantFunctionalConsequenceId\"\n            ),\n            f.col(\"Term\").alias(\"label\"),\n            f.col(\"v2g_score\").cast(\"double\").alias(\"score\"),\n        )\n\n        # Transform\n        lift = LiftOverSpark(\n            # lift over variants to hg38\n            self.liftover_chain_file_path,\n            self.liftover_max_length_difference,\n        )\n        gene_index_filtered = gene_index.filter_by_biotypes(\n            # Filter gene index by approved biotypes to define V2G gene universe\n            list(self.approved_biotypes)\n        )\n        va_slimmed = va.filter_by_variant_df(\n            # Variant annotation reduced to the variant index to define V2G variant universe\n            vi.df\n        ).persist()\n        intervals = Intervals(\n            _df=reduce(\n                lambda x, y: x.unionByName(y, allowMissingColumns=True),\n                # create interval instances by parsing each source\n                [\n                    Intervals.from_source(\n                        self.session.spark, source_name, source_path, gene_index, lift\n                    ).df\n                    for source_name, source_path in self.intervals.items()\n                ],\n            ),\n            _schema=Intervals.get_schema(),\n        )\n        v2g_datasets = [\n            va_slimmed.get_distance_to_tss(gene_index_filtered, self.max_distance),\n            va_slimmed.get_most_severe_vep_v2g(vep_consequences, gene_index_filtered),\n            va_slimmed.get_polyphen_v2g(gene_index_filtered),\n            va_slimmed.get_sift_v2g(gene_index_filtered),\n            va_slimmed.get_plof_v2g(gene_index_filtered),\n            intervals.v2g(vi),\n        ]\n        v2g = V2G(\n            _df=reduce(\n                lambda x, y: x.unionByName(y, allowMissingColumns=True),\n                [dataset.df for dataset in v2g_datasets],\n            ).repartition(\"chromosome\"),\n            _schema=V2G.get_schema(),\n        )\n\n        # Load\n        (\n            v2g.df.write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.v2g_path)\n        )\n</code></pre>"}]}