{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open Targets Genetics","text":"<p>Ingestion and analysis of genetic and functional genomic data for the identification and prioritisation of drug targets.</p> <p>This project is still in experimental phase. Please refer to the roadmap section for more information.</p> <p>For all development information, including running the code, troubleshooting, or contributing, see the development section.</p>"},{"location":"installation/","title":"Installation","text":"<p>TBC</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>The Open Targets core team is working on refactoring Open Targets Genetics, aiming to:</p> <ul> <li>Re-focus the product around Target ID</li> <li>Create a gold standard toolkit for post-GWAS analysis</li> <li>Faster/robust addition of new datasets and datatypes</li> <li>Reduce computational and financial cost</li> </ul> <p>See here for a list of open issues for this project.</p> <p>Schematic diagram representing the drafted process:</p> <p></p>"},{"location":"usage/","title":"How-to","text":"<p>TBC</p>"},{"location":"development/_development/","title":"Development","text":"<p>This section contains various technical information on how to develop and run the code.</p>"},{"location":"development/airflow/","title":"Running Airflow workflows","text":"<p>Airflow code is located in <code>src/airflow</code>. Make sure to execute all of the instructions from that directory, unless stated otherwise.</p>"},{"location":"development/airflow/#set-up-docker","title":"Set up Docker","text":"<p>We will be running a local Airflow setup using Docker Compose. First, make sure it is installed (this and subsequent commands are tested on Ubuntu):</p> <pre><code>sudo apt install docker-compose\n</code></pre> <p>Next, verify that you can run Docker. This should say \"Hello from Docker\":</p> <pre><code>docker run hello-world\n</code></pre> <p>If the command above raises a permission error, fix it and reboot:</p> <pre><code>sudo usermod -a -G docker $USER\nnewgrp docker\n</code></pre>"},{"location":"development/airflow/#set-up-airflow","title":"Set up Airflow","text":"<p>This section is adapted from instructions from https://airflow.apache.org/docs/apache-airflow/stable/tutorial/pipeline.html. When you run the commands, make sure your current working directory is <code>src/airflow</code>.</p> <pre><code># Download the latest docker-compose.yaml file.\ncurl -sLfO https://airflow.apache.org/docs/apache-airflow/stable/docker-compose.yaml\n\n# Make expected directories.\nmkdir -p ./config ./dags ./logs ./plugins\n\n# Construct the modified Docker image with additional PIP dependencies.\ndocker build . --tag opentargets-airflow:2.7.1\n\n# Set environment variables.\ncat &lt;&lt; EOF &gt; .env\nAIRFLOW_UID=$(id -u)\nAIRFLOW_IMAGE_NAME=opentargets-airflow:2.7.1\nEOF\n</code></pre> <p>Now modify <code>docker-compose.yaml</code> and add the following to the x-airflow-common \u2192 environment section: <pre><code>GOOGLE_APPLICATION_CREDENTIALS: '/opt/airflow/config/application_default_credentials.json'\nAIRFLOW__CELERY__WORKER_CONCURRENCY: 32\nAIRFLOW__CORE__PARALLELISM: 32\nAIRFLOW__CORE__MAX_ACTIVE_TASKS_PER_DAG: 32\nAIRFLOW__SCHEDULER__MAX_TIS_PER_QUERY: 16\nAIRFLOW__CORE__MAX_ACTIVE_RUNS_PER_DAG: 1\n</code></pre></p>"},{"location":"development/airflow/#start-airflow","title":"Start Airflow","text":"<pre><code>docker-compose up\n</code></pre> <p>Airflow UI will now be available at http://localhost:8080/home. Default username and password are both <code>airflow</code>.</p>"},{"location":"development/airflow/#configure-google-cloud-access","title":"Configure Google Cloud access","text":"<p>In order to be able to access Google Cloud and do work with Dataproc, Airflow will need to be configured. First, obtain Google default application credentials by running this command and following the instructions:</p> <pre><code>gcloud auth application-default login\n</code></pre> <p>Next, copy the file into the <code>config/</code> subdirectory which we created above:</p> <pre><code>cp ~/.config/gcloud/application_default_credentials.json config/\n</code></pre> <p>Now open the Airflow UI and:</p> <ul> <li>Navigate to Admin \u2192 Connections.</li> <li>Click on \"Add new record\".</li> <li>Set \"Connection type\" to `Google Cloud``.</li> <li>Set \"Connection ID\" to <code>google_cloud_default</code>.</li> <li>Set \"Credential Configuration File\" to <code>/opt/airflow/config/application_default_credentials.json</code>.</li> <li>Click on \"Save\".</li> </ul>"},{"location":"development/airflow/#run-a-workflow","title":"Run a workflow","text":"<p>Workflows, which must be placed under the <code>dags/</code> directory, will appear in the \"DAGs\" section of the UI, which is also the main page. They can be triggered manually by opening a workflow and clicking on the \"Play\" button in the upper right corner.</p> <p>In order to restart a failed task, click on it and then click on \"Clear task\".</p>"},{"location":"development/airflow/#troubleshooting","title":"Troubleshooting","text":"<p>Note that when you a a new workflow under <code>dags/</code>, Airflow will not pick that up immediately. By default the filesystem is only scanned for new DAGs every 300s. However, once the DAG is added, updates are applied nearly instantaneously.</p> <p>Also, if you edit the DAG while an instance of it is running, it might cause problems with the run, as Airflow will try to update the tasks and their properties in DAG according to the file changes.</p>"},{"location":"development/contributing/","title":"Contributing guidelines","text":""},{"location":"development/contributing/#one-time-configuration","title":"One-time configuration","text":"<p>The steps in this section only ever need to be done once on any particular system.</p> <p>Google Cloud configuration: 1. Install Google Cloud SDK: https://cloud.google.com/sdk/docs/install. 1. Log in to your work Google Account: run <code>gcloud auth login</code> and follow instructions. 1. Obtain Google application credentials: run <code>gcloud auth application-default login</code> and follow instructions.</p> <p>Check that you have the <code>make</code> utility installed, and if not (which is unlikely), install it using your system package manager.</p> <p>Check that you have <code>java</code> installed.</p>"},{"location":"development/contributing/#environment-configuration","title":"Environment configuration","text":"<p>Run <code>make setup-dev</code> to install/update the necessary packages and activate the development environment. You need to do this every time you open a new shell.</p> <p>It is recommended to use VS Code as an IDE for development.</p>"},{"location":"development/contributing/#how-to-run-the-code","title":"How to run the code","text":"<p>All pipelines in this repository are intended to be run in Google Dataproc. Running them locally is not currently supported.</p> <p>In order to run the code:</p> <ol> <li> <p>Manually edit your local <code>workflow/dag.yaml</code> file and comment out the steps you do not want to run.</p> </li> <li> <p>Manually edit your local <code>pyproject.toml</code> file and modify the version of the code.</p> <ul> <li>This must be different from the version used by any other people working on the repository to avoid any deployment conflicts, so it's a good idea to use your name, for example: <code>1.2.3+jdoe</code>.</li> <li>You can also add a brief branch description, for example: <code>1.2.3+jdoe.myfeature</code>.</li> <li>Note that the version must comply with PEP440 conventions, otherwise Poetry will not allow it to be deployed.</li> <li>Do not use underscores or hyphens in your version name. When building the WHL file, they will be automatically converted to dots, which means the file name will no longer match the version and the build will fail. Use dots instead.</li> </ul> </li> <li> <p>Run <code>make build</code>.</p> <ul> <li>This will create a bundle containing the neccessary code, configuration and dependencies to run the ETL pipeline, and then upload this bundle to Google Cloud.</li> <li>A version specific subpath is used, so uploading the code will not affect any branches but your own.</li> <li>If there was already a code bundle uploaded with the same version number, it will be replaced.</li> </ul> </li> <li> <p>Submit the Dataproc job with <code>poetry run python workflow/workflow_template.py</code></p> <ul> <li>You will need to specify additional parameters, some are mandatory and some are optional. Run with <code>--help</code> to see usage.</li> <li>The script will provision the cluster and submit the job.</li> <li>The cluster will take a few minutes to get provisioned and running, during which the script will not output anything, this is normal.</li> <li>Once submitted, you can monitor the progress of your job on this page: https://console.cloud.google.com/dataproc/jobs?project=open-targets-genetics-dev.</li> <li>On completion (whether successful or a failure), the cluster will be automatically removed, so you don't have to worry about shutting it down to avoid incurring charges.</li> </ul> </li> </ol>"},{"location":"development/contributing/#contributing-checklist","title":"Contributing checklist","text":"<p>When making changes, and especially when implementing a new module or feature, it's essential to ensure that all relevant sections of the code base are modified. - [ ] Run <code>make check</code>. This will run the linter and formatter to ensure that the code is compliant with the project conventions. - [ ] Develop unit tests for your code and run <code>make test</code>. This will run all unit tests in the repository, including the examples appended in the docstrings of some methods. - [ ] Update the configuration if necessary. - [ ] Update the documentation and check it with <code>make build-documentation</code>. This will start a local server to browse it (URL will be printed, usually <code>http://127.0.0.1:8000/</code>)</p> <p>For more details on each of these steps, see the sections below.</p>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>If during development you had a question which wasn't covered in the documentation, and someone explained it to you, add it to the documentation. The same applies if you encountered any instructions in the documentation which were obsolete or incorrect.</li> <li>Documentation autogeneration expressions start with <code>:::</code>. They will automatically generate sections of the documentation based on class and method docstrings. Be sure to update them for:</li> <li>Dataset definitions in <code>docs/reference/dataset</code> (example: <code>docs/reference/dataset/study_index/study_index_finngen.md</code>)</li> <li>Step definitions in <code>docs/reference/step</code> (example: <code>docs/reference/step/finngen.md</code>)</li> </ul>"},{"location":"development/contributing/#configuration","title":"Configuration","text":"<ul> <li>Input and output paths in <code>config/datasets/gcp.yaml</code></li> <li>Step configuration in <code>config/step/my_STEP.yaml</code> (example: <code>config/step/my_finngen.yaml</code>)</li> </ul>"},{"location":"development/contributing/#classes","title":"Classes","text":"<ul> <li>Step configuration class in <code>src/org/config.py</code> (example: <code>FinnGenStepConfig</code> class in that module)</li> <li>Dataset class in <code>src/org/dataset/</code> (example: <code>src/otg/dataset/study_index.py</code> \u2192 <code>StudyIndexFinnGen</code>)</li> <li>Step main running class in <code>src/org/STEP.py</code> (example: <code>src/org/finngen.py</code>)</li> </ul>"},{"location":"development/contributing/#tests","title":"Tests","text":"<ul> <li>Test study fixture in <code>tests/conftest.py</code> (example: <code>mock_study_index_finngen</code> in that module)</li> <li>Test sample data in <code>tests/data_samples</code> (example: <code>tests/data_samples/finngen_studies_sample.json</code>)</li> <li>Test definition in <code>tests/</code> (example: <code>tests/dataset/test_study_index.py</code> \u2192 <code>test_study_index_finngen_creation</code>)</li> </ul>"},{"location":"development/troubleshooting/","title":"Troubleshooting","text":""},{"location":"development/troubleshooting/#blaslapack","title":"BLAS/LAPACK","text":"<p>If you see errors related to BLAS/LAPACK libraries, see this StackOverflow post for guidance.</p>"},{"location":"development/troubleshooting/#pyenv-and-poetry","title":"Pyenv and Poetry","text":"<p>If you see various errors thrown by Pyenv or Poetry, they can be hard to specifically diagnose and resolve. In this case, it often helps to remove those tools from the system completely. Follow these steps:</p> <ol> <li>Close your currently activated environment, if any: <code>exit</code></li> <li>Uninstall Poetry: <code>curl -sSL https://install.python-poetry.org | python3 - --uninstall</code></li> <li>Clear Poetry cache: <code>rm -rf ~/.cache/pypoetry</code></li> <li>Clear pre-commit cache: <code>rm -rf ~/.cache/pre-commit</code></li> <li>Switch to system Python shell: <code>pyenv shell system</code></li> <li>Edit <code>~/.bashrc</code> to remove the lines related to Pyenv configuration</li> <li>Remove Pyenv configuration and cache: <code>rm -rf ~/.pyenv</code></li> </ol> <p>After that, open a fresh shell session and run <code>make setup-dev</code> again.</p>"},{"location":"development/troubleshooting/#java","title":"Java","text":"<p>Officially, PySpark requires Java version 8 (a.k.a. 1.8) or above to work. However, if you have a very recent version of Java, you may experience issues, as it may introduce breaking changes that PySpark hasn't had time to integrate. For example, as of May 2023, PySpark did not work with Java 20.</p> <p>If you are encountering problems with initialising a Spark session, try using Java 11.</p>"},{"location":"development/troubleshooting/#pre-commit","title":"Pre-commit","text":"<p>If you see an error message thrown by pre-commit, which looks like this (<code>SyntaxError: Unexpected token '?'</code>), followed by a JavaScript traceback, the issue is likely with your system NodeJS version.</p> <p>One solution which can help in this case is to upgrade your system NodeJS version. However, this may not always be possible. For example, Ubuntu repository is several major versions behind the latest version as of July 2023.</p> <p>Another solution which helps is to remove Node, NodeJS, and npm from your system entirely. In this case, pre-commit will not try to rely on a system version of NodeJS and will install its own, suitable one.</p> <p>On Ubuntu, this can be done using <code>sudo apt remove node nodejs npm</code>, followed by <code>sudo apt autoremove</code>. But in some cases, depending on your existing installation, you may need to also manually remove some files. See this StackOverflow answer for guidance.</p> <p>After running these commands, you are advised to open a fresh shell, and then also reinstall Pyenv and Poetry to make sure they pick up the changes (see relevant section above).</p>"},{"location":"python_api/dataset/_dataset/","title":"Dataset","text":"<p>             Bases: <code>ABC</code></p> <p>Open Targets Genetics Dataset.</p> <p><code>Dataset</code> is a wrapper around a Spark DataFrame with a predefined schema. Schemas for each child dataset are described in the <code>json.schemas</code> module.</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>@dataclass\nclass Dataset(ABC):\n    \"\"\"Open Targets Genetics Dataset.\n\n    `Dataset` is a wrapper around a Spark DataFrame with a predefined schema. Schemas for each child dataset are described in the `json.schemas` module.\n    \"\"\"\n\n    _df: DataFrame\n    _schema: StructType\n\n    def __post_init__(self: Dataset) -&gt; None:\n        \"\"\"Post init.\"\"\"\n        self.validate_schema()\n\n    @property\n    def df(self: Dataset) -&gt; DataFrame:\n        \"\"\"Dataframe included in the Dataset.\"\"\"\n        return self._df\n\n    @df.setter\n    def df(self: Dataset, new_df: DataFrame) -&gt; None:  # noqa: CCE001\n        \"\"\"Dataframe setter.\"\"\"\n        self._df: DataFrame = new_df\n        self.validate_schema()\n\n    @property\n    def schema(self: Dataset) -&gt; StructType:\n        \"\"\"Dataframe expected schema.\"\"\"\n        return self._schema\n\n    @classmethod\n    @abstractmethod\n    def get_schema(cls: type[Dataset]) -&gt; StructType:\n        \"\"\"Abstract method to get the schema. Must be implemented by child classes.\"\"\"\n        pass\n\n    @classmethod\n    def from_parquet(\n        cls: type[Dataset], session: Session, path: str, **kwargs: Dict[str, Any]\n    ) -&gt; Dataset:\n        \"\"\"Reads a parquet file into a Dataset with a given schema.\"\"\"\n        schema = cls.get_schema()\n        df = session.read_parquet(path=path, schema=schema, **kwargs)\n        return cls(_df=df, _schema=schema)\n\n    def validate_schema(self: Dataset) -&gt; None:  # sourcery skip: invert-any-all\n        \"\"\"Validate DataFrame schema against expected class schema.\n\n        Raises:\n            ValueError: DataFrame schema is not valid\n        \"\"\"\n        expected_schema = self._schema\n        expected_fields = flatten_schema(expected_schema)\n        observed_schema = self._df.schema\n        observed_fields = flatten_schema(observed_schema)\n\n        # Unexpected fields in dataset\n        if unexpected_field_names := [\n            x.name\n            for x in observed_fields\n            if x.name not in [y.name for y in expected_fields]\n        ]:\n            raise ValueError(\n                f\"The {unexpected_field_names} fields are not included in DataFrame schema: {expected_fields}\"\n            )\n\n        # Required fields not in dataset\n        required_fields = [x.name for x in expected_schema if not x.nullable]\n        if missing_required_fields := [\n            req\n            for req in required_fields\n            if not any(field.name == req for field in observed_fields)\n        ]:\n            raise ValueError(\n                f\"The {missing_required_fields} fields are required but missing: {required_fields}\"\n            )\n\n        # Fields with duplicated names\n        if duplicated_fields := [\n            x for x in set(observed_fields) if observed_fields.count(x) &gt; 1\n        ]:\n            raise ValueError(\n                f\"The following fields are duplicated in DataFrame schema: {duplicated_fields}\"\n            )\n\n        # Fields with different datatype\n        observed_field_types = {\n            field.name: type(field.dataType) for field in observed_fields\n        }\n        expected_field_types = {\n            field.name: type(field.dataType) for field in expected_fields\n        }\n        if fields_with_different_observed_datatype := [\n            name\n            for name, observed_type in observed_field_types.items()\n            if name in expected_field_types\n            and observed_type != expected_field_types[name]\n        ]:\n            raise ValueError(\n                f\"The following fields present differences in their datatypes: {fields_with_different_observed_datatype}.\"\n            )\n\n    def persist(self: Dataset) -&gt; Dataset:\n        \"\"\"Persist in memory the DataFrame included in the Dataset.\"\"\"\n        self.df = self._df.persist()\n        return self\n\n    def unpersist(self: Dataset) -&gt; Dataset:\n        \"\"\"Remove the persisted DataFrame from memory.\"\"\"\n        self.df = self._df.unpersist()\n        return self\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.df","title":"<code>df: DataFrame</code>  <code>property</code> <code>writable</code>","text":"<p>Dataframe included in the Dataset.</p>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.schema","title":"<code>schema: StructType</code>  <code>property</code>","text":"<p>Dataframe expected schema.</p>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post init.</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>def __post_init__(self: Dataset) -&gt; None:\n    \"\"\"Post init.\"\"\"\n    self.validate_schema()\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.from_parquet","title":"<code>from_parquet(session, path, **kwargs)</code>  <code>classmethod</code>","text":"<p>Reads a parquet file into a Dataset with a given schema.</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>@classmethod\ndef from_parquet(\n    cls: type[Dataset], session: Session, path: str, **kwargs: Dict[str, Any]\n) -&gt; Dataset:\n    \"\"\"Reads a parquet file into a Dataset with a given schema.\"\"\"\n    schema = cls.get_schema()\n    df = session.read_parquet(path=path, schema=schema, **kwargs)\n    return cls(_df=df, _schema=schema)\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.get_schema","title":"<code>get_schema()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Abstract method to get the schema. Must be implemented by child classes.</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_schema(cls: type[Dataset]) -&gt; StructType:\n    \"\"\"Abstract method to get the schema. Must be implemented by child classes.\"\"\"\n    pass\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.persist","title":"<code>persist()</code>","text":"<p>Persist in memory the DataFrame included in the Dataset.</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>def persist(self: Dataset) -&gt; Dataset:\n    \"\"\"Persist in memory the DataFrame included in the Dataset.\"\"\"\n    self.df = self._df.persist()\n    return self\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.unpersist","title":"<code>unpersist()</code>","text":"<p>Remove the persisted DataFrame from memory.</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>def unpersist(self: Dataset) -&gt; Dataset:\n    \"\"\"Remove the persisted DataFrame from memory.\"\"\"\n    self.df = self._df.unpersist()\n    return self\n</code></pre>"},{"location":"python_api/dataset/_dataset/#otg.dataset.dataset.Dataset.validate_schema","title":"<code>validate_schema()</code>","text":"<p>Validate DataFrame schema against expected class schema.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>DataFrame schema is not valid</p> Source code in <code>src/otg/dataset/dataset.py</code> <pre><code>def validate_schema(self: Dataset) -&gt; None:  # sourcery skip: invert-any-all\n    \"\"\"Validate DataFrame schema against expected class schema.\n\n    Raises:\n        ValueError: DataFrame schema is not valid\n    \"\"\"\n    expected_schema = self._schema\n    expected_fields = flatten_schema(expected_schema)\n    observed_schema = self._df.schema\n    observed_fields = flatten_schema(observed_schema)\n\n    # Unexpected fields in dataset\n    if unexpected_field_names := [\n        x.name\n        for x in observed_fields\n        if x.name not in [y.name for y in expected_fields]\n    ]:\n        raise ValueError(\n            f\"The {unexpected_field_names} fields are not included in DataFrame schema: {expected_fields}\"\n        )\n\n    # Required fields not in dataset\n    required_fields = [x.name for x in expected_schema if not x.nullable]\n    if missing_required_fields := [\n        req\n        for req in required_fields\n        if not any(field.name == req for field in observed_fields)\n    ]:\n        raise ValueError(\n            f\"The {missing_required_fields} fields are required but missing: {required_fields}\"\n        )\n\n    # Fields with duplicated names\n    if duplicated_fields := [\n        x for x in set(observed_fields) if observed_fields.count(x) &gt; 1\n    ]:\n        raise ValueError(\n            f\"The following fields are duplicated in DataFrame schema: {duplicated_fields}\"\n        )\n\n    # Fields with different datatype\n    observed_field_types = {\n        field.name: type(field.dataType) for field in observed_fields\n    }\n    expected_field_types = {\n        field.name: type(field.dataType) for field in expected_fields\n    }\n    if fields_with_different_observed_datatype := [\n        name\n        for name, observed_type in observed_field_types.items()\n        if name in expected_field_types\n        and observed_type != expected_field_types[name]\n    ]:\n        raise ValueError(\n            f\"The following fields present differences in their datatypes: {fields_with_different_observed_datatype}.\"\n        )\n</code></pre>"},{"location":"python_api/dataset/colocalisation/","title":"Colocalisation","text":""},{"location":"python_api/dataset/colocalisation/#schema","title":"Schema","text":"<pre><code>root\n |-- leftStudyLocusId: long (nullable = false)\n |-- rightStudyLocusId: long (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- colocalisationMethod: string (nullable = false)\n |-- numberColocalisingVariants: long (nullable = false)\n |-- h0: double (nullable = true)\n |-- h1: double (nullable = true)\n |-- h2: double (nullable = true)\n |-- h3: double (nullable = true)\n |-- h4: double (nullable = true)\n |-- log2h4h3: double (nullable = true)\n |-- clpp: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/colocalisation/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Colocalisation results for pairs of overlapping study-locus.</p> Source code in <code>src/otg/dataset/colocalisation.py</code> <pre><code>@dataclass\nclass Colocalisation(Dataset):\n    \"\"\"Colocalisation results for pairs of overlapping study-locus.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[Colocalisation]) -&gt; StructType:\n        \"\"\"Provides the schema for the Colocalisation dataset.\"\"\"\n        return parse_spark_schema(\"colocalisation.json\")\n</code></pre>"},{"location":"python_api/dataset/colocalisation/#otg.dataset.colocalisation.Colocalisation.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the Colocalisation dataset.</p> Source code in <code>src/otg/dataset/colocalisation.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[Colocalisation]) -&gt; StructType:\n    \"\"\"Provides the schema for the Colocalisation dataset.\"\"\"\n    return parse_spark_schema(\"colocalisation.json\")\n</code></pre>"},{"location":"python_api/dataset/gene_index/","title":"GeneIndex","text":""},{"location":"python_api/dataset/gene_index/#schema","title":"Schema","text":"<pre><code>root\n |-- geneId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- approvedSymbol: string (nullable = true)\n |-- biotype: string (nullable = true)\n |-- approvedName: string (nullable = true)\n |-- obsoleteSymbols: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- tss: long (nullable = true)\n |-- start: long (nullable = true)\n |-- end: long (nullable = true)\n |-- strand: integer (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/gene_index/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Gene index dataset.</p> <p>Gene-based annotation.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>@dataclass\nclass GeneIndex(Dataset):\n    \"\"\"Gene index dataset.\n\n    Gene-based annotation.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[GeneIndex]) -&gt; StructType:\n        \"\"\"Provides the schema for the GeneIndex dataset.\"\"\"\n        return parse_spark_schema(\"gene_index.json\")\n\n    def filter_by_biotypes(self: GeneIndex, biotypes: list) -&gt; GeneIndex:\n        \"\"\"Filter by approved biotypes.\n\n        Args:\n            biotypes (list): List of Ensembl biotypes to keep.\n\n        Returns:\n            GeneIndex: Gene index dataset filtered by biotypes.\n        \"\"\"\n        self.df = self._df.filter(f.col(\"biotype\").isin(biotypes))\n        return self\n\n    def locations_lut(self: GeneIndex) -&gt; DataFrame:\n        \"\"\"Gene location information.\n\n        Returns:\n            DataFrame: Gene LUT including genomic location information.\n        \"\"\"\n        return self.df.select(\n            \"geneId\",\n            \"chromosome\",\n            \"start\",\n            \"end\",\n            \"strand\",\n            \"tss\",\n        )\n\n    def symbols_lut(self: GeneIndex) -&gt; DataFrame:\n        \"\"\"Gene symbol lookup table.\n\n        Pre-processess gene/target dataset to create lookup table of gene symbols, including\n        obsoleted gene symbols.\n\n        Returns:\n            DataFrame: Gene LUT for symbol mapping containing `geneId` and `geneSymbol` columns.\n        \"\"\"\n        return self.df.select(\n            f.explode(\n                f.array_union(f.array(\"approvedSymbol\"), f.col(\"obsoleteSymbols\"))\n            ).alias(\"geneSymbol\"),\n            \"*\",\n        )\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.filter_by_biotypes","title":"<code>filter_by_biotypes(biotypes)</code>","text":"<p>Filter by approved biotypes.</p> <p>Parameters:</p> Name Type Description Default <code>biotypes</code> <code>list</code> <p>List of Ensembl biotypes to keep.</p> required <p>Returns:</p> Name Type Description <code>GeneIndex</code> <code>GeneIndex</code> <p>Gene index dataset filtered by biotypes.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>def filter_by_biotypes(self: GeneIndex, biotypes: list) -&gt; GeneIndex:\n    \"\"\"Filter by approved biotypes.\n\n    Args:\n        biotypes (list): List of Ensembl biotypes to keep.\n\n    Returns:\n        GeneIndex: Gene index dataset filtered by biotypes.\n    \"\"\"\n    self.df = self._df.filter(f.col(\"biotype\").isin(biotypes))\n    return self\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the GeneIndex dataset.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[GeneIndex]) -&gt; StructType:\n    \"\"\"Provides the schema for the GeneIndex dataset.\"\"\"\n    return parse_spark_schema(\"gene_index.json\")\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.locations_lut","title":"<code>locations_lut()</code>","text":"<p>Gene location information.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Gene LUT including genomic location information.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>def locations_lut(self: GeneIndex) -&gt; DataFrame:\n    \"\"\"Gene location information.\n\n    Returns:\n        DataFrame: Gene LUT including genomic location information.\n    \"\"\"\n    return self.df.select(\n        \"geneId\",\n        \"chromosome\",\n        \"start\",\n        \"end\",\n        \"strand\",\n        \"tss\",\n    )\n</code></pre>"},{"location":"python_api/dataset/gene_index/#otg.dataset.gene_index.GeneIndex.symbols_lut","title":"<code>symbols_lut()</code>","text":"<p>Gene symbol lookup table.</p> <p>Pre-processess gene/target dataset to create lookup table of gene symbols, including obsoleted gene symbols.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Gene LUT for symbol mapping containing <code>geneId</code> and <code>geneSymbol</code> columns.</p> Source code in <code>src/otg/dataset/gene_index.py</code> <pre><code>def symbols_lut(self: GeneIndex) -&gt; DataFrame:\n    \"\"\"Gene symbol lookup table.\n\n    Pre-processess gene/target dataset to create lookup table of gene symbols, including\n    obsoleted gene symbols.\n\n    Returns:\n        DataFrame: Gene LUT for symbol mapping containing `geneId` and `geneSymbol` columns.\n    \"\"\"\n    return self.df.select(\n        f.explode(\n            f.array_union(f.array(\"approvedSymbol\"), f.col(\"obsoleteSymbols\"))\n        ).alias(\"geneSymbol\"),\n        \"*\",\n    )\n</code></pre>"},{"location":"python_api/dataset/intervals/","title":"Intervals","text":""},{"location":"python_api/dataset/intervals/#schema","title":"Schema","text":"<pre><code>root\n |-- chromosome: string (nullable = false)\n |-- start: string (nullable = false)\n |-- end: string (nullable = false)\n |-- geneId: string (nullable = false)\n |-- resourceScore: double (nullable = true)\n |-- score: double (nullable = true)\n |-- datasourceId: string (nullable = false)\n |-- datatypeId: string (nullable = false)\n |-- pmid: string (nullable = true)\n |-- biofeature: string (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/intervals/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Intervals dataset links genes to genomic regions based on genome interaction studies.</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>@dataclass\nclass Intervals(Dataset):\n    \"\"\"Intervals dataset links genes to genomic regions based on genome interaction studies.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[Intervals]) -&gt; StructType:\n        \"\"\"Provides the schema for the Intervals dataset.\"\"\"\n        return parse_spark_schema(\"intervals.json\")\n\n    @classmethod\n    def from_source(\n        cls: type[Intervals],\n        spark: SparkSession,\n        source_name: str,\n        source_path: str,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; Intervals:\n        \"\"\"Collect interval data for a particular source.\n\n        Args:\n            spark (SparkSession): Spark session\n            source_name (str): Name of the interval source\n            source_path (str): Path to the interval source file\n            gene_index (GeneIndex): Gene index\n            lift (LiftOverSpark): LiftOverSpark instance to convert coordinats from hg37 to hg38\n\n        Returns:\n            Intervals: Intervals dataset\n        \"\"\"\n        from otg.datasource.intervals.andersson import IntervalsAndersson\n        from otg.datasource.intervals.javierre import IntervalsJavierre\n        from otg.datasource.intervals.jung import IntervalsJung\n        from otg.datasource.intervals.thurman import IntervalsThurman\n\n        source_to_class = {\n            \"andersson\": IntervalsAndersson,\n            \"javierre\": IntervalsJavierre,\n            \"jung\": IntervalsJung,\n            \"thurman\": IntervalsThurman,\n        }\n\n        if source_name not in source_to_class:\n            raise ValueError(f\"Unknown interval source: {source_name}\")\n\n        source_class = source_to_class[source_name]\n        data = source_class.read(spark, source_path)\n        return source_class.parse(data, gene_index, lift)\n\n    def v2g(self: Intervals, variant_index: VariantIndex) -&gt; V2G:\n        \"\"\"Convert intervals into V2G by intersecting with a variant index.\n\n        Args:\n            variant_index (VariantIndex): Variant index dataset\n\n        Returns:\n            V2G: Variant-to-gene evidence dataset\n        \"\"\"\n        return V2G(\n            _df=(\n                self.df.alias(\"interval\")\n                .join(\n                    variant_index.df.selectExpr(\n                        \"chromosome as vi_chromosome\", \"variantId\", \"position\"\n                    ).alias(\"vi\"),\n                    on=[\n                        f.col(\"vi.vi_chromosome\") == f.col(\"interval.chromosome\"),\n                        f.col(\"vi.position\").between(\n                            f.col(\"interval.start\"), f.col(\"interval.end\")\n                        ),\n                    ],\n                    how=\"inner\",\n                )\n                .drop(\"start\", \"end\", \"vi_chromosome\", \"position\")\n            ),\n            _schema=V2G.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/intervals/#otg.dataset.intervals.Intervals.from_source","title":"<code>from_source(spark, source_name, source_path, gene_index, lift)</code>  <code>classmethod</code>","text":"<p>Collect interval data for a particular source.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>source_name</code> <code>str</code> <p>Name of the interval source</p> required <code>source_path</code> <code>str</code> <p>Path to the interval source file</p> required <code>gene_index</code> <code>GeneIndex</code> <p>Gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance to convert coordinats from hg37 to hg38</p> required <p>Returns:</p> Name Type Description <code>Intervals</code> <code>Intervals</code> <p>Intervals dataset</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[Intervals],\n    spark: SparkSession,\n    source_name: str,\n    source_path: str,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; Intervals:\n    \"\"\"Collect interval data for a particular source.\n\n    Args:\n        spark (SparkSession): Spark session\n        source_name (str): Name of the interval source\n        source_path (str): Path to the interval source file\n        gene_index (GeneIndex): Gene index\n        lift (LiftOverSpark): LiftOverSpark instance to convert coordinats from hg37 to hg38\n\n    Returns:\n        Intervals: Intervals dataset\n    \"\"\"\n    from otg.datasource.intervals.andersson import IntervalsAndersson\n    from otg.datasource.intervals.javierre import IntervalsJavierre\n    from otg.datasource.intervals.jung import IntervalsJung\n    from otg.datasource.intervals.thurman import IntervalsThurman\n\n    source_to_class = {\n        \"andersson\": IntervalsAndersson,\n        \"javierre\": IntervalsJavierre,\n        \"jung\": IntervalsJung,\n        \"thurman\": IntervalsThurman,\n    }\n\n    if source_name not in source_to_class:\n        raise ValueError(f\"Unknown interval source: {source_name}\")\n\n    source_class = source_to_class[source_name]\n    data = source_class.read(spark, source_path)\n    return source_class.parse(data, gene_index, lift)\n</code></pre>"},{"location":"python_api/dataset/intervals/#otg.dataset.intervals.Intervals.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the Intervals dataset.</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[Intervals]) -&gt; StructType:\n    \"\"\"Provides the schema for the Intervals dataset.\"\"\"\n    return parse_spark_schema(\"intervals.json\")\n</code></pre>"},{"location":"python_api/dataset/intervals/#otg.dataset.intervals.Intervals.v2g","title":"<code>v2g(variant_index)</code>","text":"<p>Convert intervals into V2G by intersecting with a variant index.</p> <p>Parameters:</p> Name Type Description Default <code>variant_index</code> <code>VariantIndex</code> <p>Variant index dataset</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>Variant-to-gene evidence dataset</p> Source code in <code>src/otg/dataset/intervals.py</code> <pre><code>def v2g(self: Intervals, variant_index: VariantIndex) -&gt; V2G:\n    \"\"\"Convert intervals into V2G by intersecting with a variant index.\n\n    Args:\n        variant_index (VariantIndex): Variant index dataset\n\n    Returns:\n        V2G: Variant-to-gene evidence dataset\n    \"\"\"\n    return V2G(\n        _df=(\n            self.df.alias(\"interval\")\n            .join(\n                variant_index.df.selectExpr(\n                    \"chromosome as vi_chromosome\", \"variantId\", \"position\"\n                ).alias(\"vi\"),\n                on=[\n                    f.col(\"vi.vi_chromosome\") == f.col(\"interval.chromosome\"),\n                    f.col(\"vi.position\").between(\n                        f.col(\"interval.start\"), f.col(\"interval.end\")\n                    ),\n                ],\n                how=\"inner\",\n            )\n            .drop(\"start\", \"end\", \"vi_chromosome\", \"position\")\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/ld_index/","title":"LDIndex","text":""},{"location":"python_api/dataset/ld_index/#schema","title":"Schema","text":"<pre><code>root\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- ldSet: array (nullable = false)\n |    |-- element: struct (containsNull = false)\n |    |    |-- tagVariantId: string (nullable = false)\n |    |    |-- rValues: array (nullable = false)\n |    |    |    |-- element: struct (containsNull = false)\n |    |    |    |    |-- population: string (nullable = false)\n |    |    |    |    |-- r: double (nullable = false)\n</code></pre>"},{"location":"python_api/dataset/ld_index/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Dataset containing linkage desequilibrium information between variants.</p> Source code in <code>src/otg/dataset/ld_index.py</code> <pre><code>@dataclass\nclass LDIndex(Dataset):\n    \"\"\"Dataset containing linkage desequilibrium information between variants.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[LDIndex]) -&gt; StructType:\n        \"\"\"Provides the schema for the LDIndex dataset.\"\"\"\n        return parse_spark_schema(\"ld_index.json\")\n</code></pre>"},{"location":"python_api/dataset/ld_index/#otg.dataset.ld_index.LDIndex.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the LDIndex dataset.</p> Source code in <code>src/otg/dataset/ld_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[LDIndex]) -&gt; StructType:\n    \"\"\"Provides the schema for the LDIndex dataset.\"\"\"\n    return parse_spark_schema(\"ld_index.json\")\n</code></pre>"},{"location":"python_api/dataset/study_index/","title":"StudyIndex","text":""},{"location":"python_api/dataset/study_index/#schema","title":"Schema","text":"<pre><code>root\n |-- studyId: string (nullable = false)\n |-- projectId: string (nullable = false)\n |-- studyType: string (nullable = false)\n |-- traitFromSource: string (nullable = false)\n |-- traitFromSourceMappedIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- pubmedId: string (nullable = true)\n |-- publicationTitle: string (nullable = true)\n |-- publicationFirstAuthor: string (nullable = true)\n |-- publicationDate: string (nullable = true)\n |-- publicationJournal: string (nullable = true)\n |-- backgroundTraitFromSourceMappedIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- initialSampleSize: string (nullable = true)\n |-- nCases: long (nullable = true)\n |-- nControls: long (nullable = true)\n |-- nSamples: long (nullable = true)\n |-- ldPopulationStructure: array (nullable = true)\n |    |-- element: struct (containsNull = false)\n |    |    |-- ldPopulation: string (nullable = true)\n |    |    |-- relativeSampleSize: double (nullable = true)\n |-- discoverySamples: array (nullable = true)\n |    |-- element: struct (containsNull = false)\n |    |    |-- sampleSize: long (nullable = true)\n |    |    |-- ancestry: string (nullable = true)\n |-- replicationSamples: array (nullable = true)\n |    |-- element: struct (containsNull = false)\n |    |    |-- sampleSize: long (nullable = true)\n |    |    |-- ancestry: string (nullable = true)\n |-- summarystatsLocation: string (nullable = true)\n |-- hasSumstats: boolean (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/study_index/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Study index dataset.</p> <p>A study index dataset captures all the metadata for all studies including GWAS and Molecular QTL.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>@dataclass\nclass StudyIndex(Dataset):\n    \"\"\"Study index dataset.\n\n    A study index dataset captures all the metadata for all studies including GWAS and Molecular QTL.\n    \"\"\"\n\n    @staticmethod\n    def _aggregate_samples_by_ancestry(merged: Column, ancestry: Column) -&gt; Column:\n        \"\"\"Aggregate sample counts by ancestry in a list of struct colmns.\n\n        Args:\n            merged (Column): A column representing merged data (list of structs).\n            ancestry (Column): The `ancestry` parameter is a column that represents the ancestry of each\n                sample. (a struct)\n\n        Returns:\n            the modified \"merged\" column after aggregating the samples by ancestry.\n        \"\"\"\n        # Iterating over the list of ancestries and adding the sample size if label matches:\n        return f.transform(\n            merged,\n            lambda a: f.when(\n                a.ancestry == ancestry.ancestry,\n                f.struct(\n                    a.ancestry.alias(\"ancestry\"),\n                    (a.sampleSize + ancestry.sampleSize).alias(\"sampleSize\"),\n                ),\n            ).otherwise(a),\n        )\n\n    @staticmethod\n    def _map_ancestries_to_ld_population(gwas_ancestry_label: Column) -&gt; Column:\n        \"\"\"Normalise ancestry column from GWAS studies into reference LD panel based on a pre-defined map.\n\n        This function assumes all possible ancestry categories have a corresponding\n        LD panel in the LD index. It is very important to have the ancestry labels\n        moved to the LD panel map.\n\n        Args:\n            gwas_ancestry_label (Column): A struct column with ancestry label like Finnish,\n                European, African etc. and the corresponding sample size.\n\n        Returns:\n            Column: Struct column with the mapped LD population label and the sample size.\n        \"\"\"\n        # Loading ancestry label to LD population label:\n        json_dict = json.loads(\n            pkg_resources.read_text(\n                data, \"gwas_population_2_LD_panel_map.json\", encoding=\"utf-8\"\n            )\n        )\n        map_expr = f.create_map(*[f.lit(x) for x in chain(*json_dict.items())])\n\n        return f.struct(\n            map_expr[gwas_ancestry_label.ancestry].alias(\"ancestry\"),\n            gwas_ancestry_label.sampleSize.alias(\"sampleSize\"),\n        )\n\n    @classmethod\n    def get_schema(cls: type[StudyIndex]) -&gt; StructType:\n        \"\"\"Provide the schema for the StudyIndex dataset.\"\"\"\n        return parse_spark_schema(\"study_index.json\")\n\n    @classmethod\n    def aggregate_and_map_ancestries(\n        cls: type[StudyIndex], discovery_samples: Column\n    ) -&gt; Column:\n        \"\"\"Map ancestries to populations in the LD reference and calculate relative sample size.\n\n        Args:\n            discovery_samples (Column): A list of struct column. Has an `ancestry` column and a `sampleSize` columns\n\n        Returns:\n            A list of struct with mapped LD population and their relative sample size.\n        \"\"\"\n        # Map ancestry categories to population labels of the LD index:\n        mapped_ancestries = f.transform(\n            discovery_samples, cls._map_ancestries_to_ld_population\n        )\n\n        # Aggregate sample sizes belonging to the same LD population:\n        aggregated_counts = f.aggregate(\n            mapped_ancestries,\n            f.array_distinct(\n                f.transform(\n                    mapped_ancestries,\n                    lambda x: f.struct(\n                        x.ancestry.alias(\"ancestry\"), f.lit(0.0).alias(\"sampleSize\")\n                    ),\n                )\n            ),\n            cls._aggregate_samples_by_ancestry,\n        )\n        # Getting total sample count:\n        total_sample_count = f.aggregate(\n            aggregated_counts, f.lit(0.0), lambda total, pop: total + pop.sampleSize\n        ).alias(\"sampleSize\")\n\n        # Calculating relative sample size for each LD population:\n        return f.transform(\n            aggregated_counts,\n            lambda ld_population: f.struct(\n                ld_population.ancestry.alias(\"ldPopulation\"),\n                (ld_population.sampleSize / total_sample_count).alias(\n                    \"relativeSampleSize\"\n                ),\n            ),\n        )\n\n    def study_type_lut(self: StudyIndex) -&gt; DataFrame:\n        \"\"\"Return a lookup table of study type.\n\n        Returns:\n            DataFrame: A dataframe containing `studyId` and `studyType` columns.\n        \"\"\"\n        return self.df.select(\"studyId\", \"studyType\")\n</code></pre>"},{"location":"python_api/dataset/study_index/#otg.dataset.study_index.StudyIndex.aggregate_and_map_ancestries","title":"<code>aggregate_and_map_ancestries(discovery_samples)</code>  <code>classmethod</code>","text":"<p>Map ancestries to populations in the LD reference and calculate relative sample size.</p> <p>Parameters:</p> Name Type Description Default <code>discovery_samples</code> <code>Column</code> <p>A list of struct column. Has an <code>ancestry</code> column and a <code>sampleSize</code> columns</p> required <p>Returns:</p> Type Description <code>Column</code> <p>A list of struct with mapped LD population and their relative sample size.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>@classmethod\ndef aggregate_and_map_ancestries(\n    cls: type[StudyIndex], discovery_samples: Column\n) -&gt; Column:\n    \"\"\"Map ancestries to populations in the LD reference and calculate relative sample size.\n\n    Args:\n        discovery_samples (Column): A list of struct column. Has an `ancestry` column and a `sampleSize` columns\n\n    Returns:\n        A list of struct with mapped LD population and their relative sample size.\n    \"\"\"\n    # Map ancestry categories to population labels of the LD index:\n    mapped_ancestries = f.transform(\n        discovery_samples, cls._map_ancestries_to_ld_population\n    )\n\n    # Aggregate sample sizes belonging to the same LD population:\n    aggregated_counts = f.aggregate(\n        mapped_ancestries,\n        f.array_distinct(\n            f.transform(\n                mapped_ancestries,\n                lambda x: f.struct(\n                    x.ancestry.alias(\"ancestry\"), f.lit(0.0).alias(\"sampleSize\")\n                ),\n            )\n        ),\n        cls._aggregate_samples_by_ancestry,\n    )\n    # Getting total sample count:\n    total_sample_count = f.aggregate(\n        aggregated_counts, f.lit(0.0), lambda total, pop: total + pop.sampleSize\n    ).alias(\"sampleSize\")\n\n    # Calculating relative sample size for each LD population:\n    return f.transform(\n        aggregated_counts,\n        lambda ld_population: f.struct(\n            ld_population.ancestry.alias(\"ldPopulation\"),\n            (ld_population.sampleSize / total_sample_count).alias(\n                \"relativeSampleSize\"\n            ),\n        ),\n    )\n</code></pre>"},{"location":"python_api/dataset/study_index/#otg.dataset.study_index.StudyIndex.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provide the schema for the StudyIndex dataset.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[StudyIndex]) -&gt; StructType:\n    \"\"\"Provide the schema for the StudyIndex dataset.\"\"\"\n    return parse_spark_schema(\"study_index.json\")\n</code></pre>"},{"location":"python_api/dataset/study_index/#otg.dataset.study_index.StudyIndex.study_type_lut","title":"<code>study_type_lut()</code>","text":"<p>Return a lookup table of study type.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A dataframe containing <code>studyId</code> and <code>studyType</code> columns.</p> Source code in <code>src/otg/dataset/study_index.py</code> <pre><code>def study_type_lut(self: StudyIndex) -&gt; DataFrame:\n    \"\"\"Return a lookup table of study type.\n\n    Returns:\n        DataFrame: A dataframe containing `studyId` and `studyType` columns.\n    \"\"\"\n    return self.df.select(\"studyId\", \"studyType\")\n</code></pre>"},{"location":"python_api/dataset/study_locus/","title":"StudyLocus","text":""},{"location":"python_api/dataset/study_locus/#schema","title":"Schema","text":"<pre><code>root\n |-- studyLocusId: long (nullable = false)\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = true)\n |-- position: integer (nullable = true)\n |-- studyId: string (nullable = false)\n |-- beta: double (nullable = true)\n |-- oddsRatio: double (nullable = true)\n |-- oddsRatioConfidenceIntervalLower: double (nullable = true)\n |-- oddsRatioConfidenceIntervalUpper: double (nullable = true)\n |-- betaConfidenceIntervalLower: double (nullable = true)\n |-- betaConfidenceIntervalUpper: double (nullable = true)\n |-- pValueMantissa: float (nullable = true)\n |-- pValueExponent: integer (nullable = true)\n |-- effectAlleleFrequencyFromSource: float (nullable = true)\n |-- standardError: double (nullable = true)\n |-- subStudyDescription: string (nullable = true)\n |-- qualityControls: array (nullable = true)\n |    |-- element: string (containsNull = false)\n |-- finemappingMethod: string (nullable = true)\n |-- ldSet: array (nullable = true)\n |    |-- element: struct (containsNull = true)\n |    |    |-- tagVariantId: string (nullable = true)\n |    |    |-- r2Overall: double (nullable = true)\n |-- locus: array (nullable = true)\n |    |-- element: struct (containsNull = true)\n |    |    |-- is95CredibleSet: boolean (nullable = true)\n |    |    |-- is99CredibleSet: boolean (nullable = true)\n |    |    |-- logABF: double (nullable = true)\n |    |    |-- posteriorProbability: double (nullable = true)\n |    |    |-- variantId: string (nullable = true)\n |    |    |-- pValueMantissa: float (nullable = true)\n |    |    |-- pValueExponent: integer (nullable = true)\n |    |    |-- pValueMantissaConditioned: float (nullable = true)\n |    |    |-- pValueExponentConditioned: integer (nullable = true)\n |    |    |-- beta: double (nullable = true)\n |    |    |-- standardError: double (nullable = true)\n |    |    |-- betaConditioned: double (nullable = true)\n |    |    |-- standardErrorConditioned: double (nullable = true)\n |    |    |-- r2Overall: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/study_locus/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Study-Locus dataset.</p> <p>This dataset captures associations between study/traits and a genetic loci as provided by finemapping methods.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>@dataclass\nclass StudyLocus(Dataset):\n    \"\"\"Study-Locus dataset.\n\n    This dataset captures associations between study/traits and a genetic loci as provided by finemapping methods.\n    \"\"\"\n\n    @staticmethod\n    def _overlapping_peaks(credset_to_overlap: DataFrame) -&gt; DataFrame:\n        \"\"\"Calculate overlapping signals (study-locus) between GWAS-GWAS and GWAS-Molecular trait.\n\n        Args:\n            credset_to_overlap (DataFrame): DataFrame containing at least `studyLocusId`, `studyType`, `chromosome` and `tagVariantId` columns.\n\n        Returns:\n            DataFrame: containing `leftStudyLocusId`, `rightStudyLocusId` and `chromosome` columns.\n        \"\"\"\n        # Reduce columns to the minimum to reduce the size of the dataframe\n        credset_to_overlap = credset_to_overlap.select(\n            \"studyLocusId\", \"studyType\", \"chromosome\", \"tagVariantId\"\n        )\n        return (\n            credset_to_overlap.alias(\"left\")\n            .filter(f.col(\"studyType\") == \"gwas\")\n            # Self join with complex condition. Left it's all gwas and right can be gwas or molecular trait\n            .join(\n                credset_to_overlap.alias(\"right\"),\n                on=[\n                    f.col(\"left.chromosome\") == f.col(\"right.chromosome\"),\n                    f.col(\"left.tagVariantId\") == f.col(\"right.tagVariantId\"),\n                    (f.col(\"right.studyType\") != \"gwas\")\n                    | (f.col(\"left.studyLocusId\") &gt; f.col(\"right.studyLocusId\")),\n                ],\n                how=\"inner\",\n            )\n            .select(\n                f.col(\"left.studyLocusId\").alias(\"leftStudyLocusId\"),\n                f.col(\"right.studyLocusId\").alias(\"rightStudyLocusId\"),\n                f.col(\"left.chromosome\").alias(\"chromosome\"),\n            )\n            .distinct()\n            .repartition(\"chromosome\")\n            .persist()\n        )\n\n    @staticmethod\n    def _align_overlapping_tags(\n        loci_to_overlap: DataFrame, peak_overlaps: DataFrame\n    ) -&gt; StudyLocusOverlap:\n        \"\"\"Align overlapping tags in pairs of overlapping study-locus, keeping all tags in both loci.\n\n        Args:\n            loci_to_overlap (DataFrame): containing `studyLocusId`, `studyType`, `chromosome`, `tagVariantId`, `logABF` and `posteriorProbability` columns.\n            peak_overlaps (DataFrame): containing `left_studyLocusId`, `right_studyLocusId` and `chromosome` columns.\n\n        Returns:\n            StudyLocusOverlap: Pairs of overlapping study-locus with aligned tags.\n        \"\"\"\n        # Complete information about all tags in the left study-locus of the overlap\n        stats_cols = [\n            \"logABF\",\n            \"posteriorProbability\",\n            \"beta\",\n            \"pValueMantissa\",\n            \"pValueExponent\",\n        ]\n        overlapping_left = loci_to_overlap.select(\n            f.col(\"chromosome\"),\n            f.col(\"tagVariantId\"),\n            f.col(\"studyLocusId\").alias(\"leftStudyLocusId\"),\n            *[f.col(col).alias(f\"left_{col}\") for col in stats_cols],\n        ).join(peak_overlaps, on=[\"chromosome\", \"leftStudyLocusId\"], how=\"inner\")\n\n        # Complete information about all tags in the right study-locus of the overlap\n        overlapping_right = loci_to_overlap.select(\n            f.col(\"chromosome\"),\n            f.col(\"tagVariantId\"),\n            f.col(\"studyLocusId\").alias(\"rightStudyLocusId\"),\n            *[f.col(col).alias(f\"right_{col}\") for col in stats_cols],\n        ).join(peak_overlaps, on=[\"chromosome\", \"rightStudyLocusId\"], how=\"inner\")\n\n        # Include information about all tag variants in both study-locus aligned by tag variant id\n        overlaps = overlapping_left.join(\n            overlapping_right,\n            on=[\n                \"chromosome\",\n                \"rightStudyLocusId\",\n                \"leftStudyLocusId\",\n                \"tagVariantId\",\n            ],\n            how=\"outer\",\n        ).select(\n            \"leftStudyLocusId\",\n            \"rightStudyLocusId\",\n            \"chromosome\",\n            \"tagVariantId\",\n            f.struct(\n                *[f\"left_{e}\" for e in stats_cols] + [f\"right_{e}\" for e in stats_cols]\n            ).alias(\"statistics\"),\n        )\n        return StudyLocusOverlap(\n            _df=overlaps,\n            _schema=StudyLocusOverlap.get_schema(),\n        )\n\n    @staticmethod\n    def _update_quality_flag(\n        qc: Column, flag_condition: Column, flag_text: StudyLocusQualityCheck\n    ) -&gt; Column:\n        \"\"\"Update the provided quality control list with a new flag if condition is met.\n\n        Args:\n            qc (Column): Array column with the current list of qc flags.\n            flag_condition (Column): This is a column of booleans, signing which row should be flagged\n            flag_text (StudyLocusQualityCheck): Text for the new quality control flag\n\n        Returns:\n            Column: Array column with the updated list of qc flags.\n        \"\"\"\n        qc = f.when(qc.isNull(), f.array()).otherwise(qc)\n        return f.when(\n            flag_condition,\n            f.array_union(qc, f.array(f.lit(flag_text.value))),\n        ).otherwise(qc)\n\n    @staticmethod\n    def assign_study_locus_id(study_id_col: Column, variant_id_col: Column) -&gt; Column:\n        \"\"\"Hashes a column with a variant ID and a study ID to extract a consistent studyLocusId.\n\n        Args:\n            study_id_col (Column): column name with a study ID\n            variant_id_col (Column): column name with a variant ID\n\n        Returns:\n            Column: column with a study locus ID\n\n        Examples:\n            &gt;&gt;&gt; df = spark.createDataFrame([(\"GCST000001\", \"1_1000_A_C\"), (\"GCST000002\", \"1_1000_A_C\")]).toDF(\"studyId\", \"variantId\")\n            &gt;&gt;&gt; df.withColumn(\"study_locus_id\", StudyLocus.assign_study_locus_id(*[f.col(\"variantId\"), f.col(\"studyId\")])).show()\n            +----------+----------+--------------------+\n            |   studyId| variantId|      study_locus_id|\n            +----------+----------+--------------------+\n            |GCST000001|1_1000_A_C| 7437284926964690765|\n            |GCST000002|1_1000_A_C|-7653912547667845377|\n            +----------+----------+--------------------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        return f.xxhash64(*[study_id_col, variant_id_col]).alias(\"studyLocusId\")\n\n    @classmethod\n    def get_schema(cls: type[StudyLocus]) -&gt; StructType:\n        \"\"\"Provides the schema for the StudyLocus dataset.\"\"\"\n        return parse_spark_schema(\"study_locus.json\")\n\n    def filter_credible_set(\n        self: StudyLocus,\n        credible_interval: CredibleInterval,\n    ) -&gt; StudyLocus:\n        \"\"\"Filter study-locus tag variants based on given credible interval.\n\n        Args:\n            credible_interval (CredibleInterval): Credible interval to filter for.\n\n        Returns:\n            StudyLocus: Filtered study-locus dataset.\n        \"\"\"\n        self.df = self._df.withColumn(\n            \"locus\",\n            f.expr(f\"filter(locus, tag -&gt; (tag.{credible_interval.value}))\"),\n        )\n        return self\n\n    def find_overlaps(self: StudyLocus, study_index: StudyIndex) -&gt; StudyLocusOverlap:\n        \"\"\"Calculate overlapping study-locus.\n\n        Find overlapping study-locus that share at least one tagging variant. All GWAS-GWAS and all GWAS-Molecular traits are computed with the Molecular traits always\n        appearing on the right side.\n\n        Args:\n            study_index (StudyIndex): Study index to resolve study types.\n\n        Returns:\n            StudyLocusOverlap: Pairs of overlapping study-locus with aligned tags.\n        \"\"\"\n        loci_to_overlap = (\n            self.df.join(study_index.study_type_lut(), on=\"studyId\", how=\"inner\")\n            .withColumn(\"locus\", f.explode(\"locus\"))\n            .select(\n                \"studyLocusId\",\n                \"studyType\",\n                \"chromosome\",\n                f.col(\"locus.variantId\").alias(\"tagVariantId\"),\n                f.col(\"locus.logABF\").alias(\"logABF\"),\n                f.col(\"locus.posteriorProbability\").alias(\"posteriorProbability\"),\n                f.col(\"locus.pValueMantissa\").alias(\"pValueMantissa\"),\n                f.col(\"locus.pValueExponent\").alias(\"pValueExponent\"),\n                f.col(\"locus.beta\").alias(\"beta\"),\n            )\n            .persist()\n        )\n\n        # overlapping study-locus\n        peak_overlaps = self._overlapping_peaks(loci_to_overlap)\n\n        # study-locus overlap by aligning overlapping variants\n        return self._align_overlapping_tags(loci_to_overlap, peak_overlaps)\n\n    def unique_variants_in_locus(self: StudyLocus) -&gt; DataFrame:\n        \"\"\"All unique variants collected in a `StudyLocus` dataframe.\n\n        Returns:\n            DataFrame: A dataframe containing `variantId` and `chromosome` columns.\n        \"\"\"\n        return (\n            self.df.withColumn(\n                \"variantId\",\n                # Joint array of variants in that studylocus. Locus can be null\n                f.explode(\n                    f.array_union(\n                        f.array(f.col(\"variantId\")),\n                        f.coalesce(f.col(\"locus.variantId\"), f.array()),\n                    )\n                ),\n            )\n            .select(\n                \"variantId\", f.split(f.col(\"variantId\"), \"_\")[0].alias(\"chromosome\")\n            )\n            .distinct()\n        )\n\n    def neglog_pvalue(self: StudyLocus) -&gt; Column:\n        \"\"\"Returns the negative log p-value.\n\n        Returns:\n            Column: Negative log p-value\n        \"\"\"\n        return calculate_neglog_pvalue(\n            self.df.pValueMantissa,\n            self.df.pValueExponent,\n        )\n\n    def annotate_credible_sets(self: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Annotate study-locus dataset with credible set flags.\n\n        Sorts the array in the `locus` column elements by their `posteriorProbability` values in descending order and adds\n        `is95CredibleSet` and `is99CredibleSet` fields to the elements, indicating which are the tagging variants whose cumulative sum\n        of their `posteriorProbability` values is below 0.95 and 0.99, respectively.\n\n        Returns:\n            StudyLocus: including annotation on `is95CredibleSet` and `is99CredibleSet`.\n        \"\"\"\n        if \"locus\" not in self.df.columns:\n            raise ValueError(\"Locus column not available.\")\n\n        self.df = self.df.withColumn(\n            # Sort credible set by posterior probability in descending order\n            \"locus\",\n            f.when(\n                f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n                order_array_of_structs_by_field(\"locus\", \"posteriorProbability\"),\n            ),\n        ).withColumn(\n            # Calculate array of cumulative sums of posterior probabilities to determine which variants are in the 95% and 99% credible sets\n            # and zip the cumulative sums array with the credible set array to add the flags\n            \"locus\",\n            f.when(\n                f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n                f.zip_with(\n                    f.col(\"locus\"),\n                    f.transform(\n                        f.sequence(f.lit(1), f.size(f.col(\"locus\"))),\n                        lambda index: f.aggregate(\n                            f.slice(\n                                # By using `index - 1` we introduce a value of `0.0` in the cumulative sums array. to ensure that the last variant\n                                # that exceeds the 0.95 threshold is included in the cumulative sum, as its probability is necessary to satisfy the threshold.\n                                f.col(\"locus.posteriorProbability\"),\n                                1,\n                                index - 1,\n                            ),\n                            f.lit(0.0),\n                            lambda acc, el: acc + el,\n                        ),\n                    ),\n                    lambda struct_e, acc: struct_e.withField(\n                        CredibleInterval.IS95.value, (acc &lt; 0.95) &amp; acc.isNotNull()\n                    ).withField(\n                        CredibleInterval.IS99.value, (acc &lt; 0.99) &amp; acc.isNotNull()\n                    ),\n                ),\n            ),\n        )\n        return self\n\n    def clump(self: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Perform LD clumping of the studyLocus.\n\n        Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.\n\n        Returns:\n            StudyLocus: with empty credible sets for linked variants and QC flag.\n        \"\"\"\n        self.df = (\n            self.df.withColumn(\n                \"is_lead_linked\",\n                LDclumping._is_lead_linked(\n                    self.df.studyId,\n                    self.df.variantId,\n                    self.df.pValueExponent,\n                    self.df.pValueMantissa,\n                    self.df.ldSet,\n                ),\n            )\n            .withColumn(\n                \"ldSet\",\n                f.when(f.col(\"is_lead_linked\"), f.array()).otherwise(f.col(\"ldSet\")),\n            )\n            .withColumn(\n                \"qualityControls\",\n                StudyLocus._update_quality_flag(\n                    f.col(\"qualityControls\"),\n                    f.col(\"is_lead_linked\"),\n                    StudyLocusQualityCheck.LD_CLUMPED,\n                ),\n            )\n            .drop(\"is_lead_linked\")\n        )\n        return self\n\n    def _qc_unresolved_ld(\n        self: StudyLocus,\n    ) -&gt; StudyLocus:\n        \"\"\"Flag associations with variants that are not found in the LD reference.\n\n        Returns:\n            StudyLocusGWASCatalog | StudyLocus: Updated study locus.\n        \"\"\"\n        self.df = self.df.withColumn(\n            \"qualityControls\",\n            self._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.col(\"ldSet\").isNull(),\n                StudyLocusQualityCheck.UNRESOLVED_LD,\n            ),\n        )\n        return self\n\n    def _qc_no_population(self: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Flag associations where the study doesn't have population information to resolve LD.\n\n        Returns:\n            StudyLocusGWASCatalog | StudyLocus: Updated study locus.\n        \"\"\"\n        # If the tested column is not present, return self unchanged:\n        if \"ldPopulationStructure\" not in self.df.columns:\n            return self\n\n        self.df = self.df.withColumn(\n            \"qualityControls\",\n            self._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.col(\"ldPopulationStructure\").isNull(),\n                StudyLocusQualityCheck.NO_POPULATION,\n            ),\n        )\n        return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.annotate_credible_sets","title":"<code>annotate_credible_sets()</code>","text":"<p>Annotate study-locus dataset with credible set flags.</p> <p>Sorts the array in the <code>locus</code> column elements by their <code>posteriorProbability</code> values in descending order and adds <code>is95CredibleSet</code> and <code>is99CredibleSet</code> fields to the elements, indicating which are the tagging variants whose cumulative sum of their <code>posteriorProbability</code> values is below 0.95 and 0.99, respectively.</p> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>including annotation on <code>is95CredibleSet</code> and <code>is99CredibleSet</code>.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def annotate_credible_sets(self: StudyLocus) -&gt; StudyLocus:\n    \"\"\"Annotate study-locus dataset with credible set flags.\n\n    Sorts the array in the `locus` column elements by their `posteriorProbability` values in descending order and adds\n    `is95CredibleSet` and `is99CredibleSet` fields to the elements, indicating which are the tagging variants whose cumulative sum\n    of their `posteriorProbability` values is below 0.95 and 0.99, respectively.\n\n    Returns:\n        StudyLocus: including annotation on `is95CredibleSet` and `is99CredibleSet`.\n    \"\"\"\n    if \"locus\" not in self.df.columns:\n        raise ValueError(\"Locus column not available.\")\n\n    self.df = self.df.withColumn(\n        # Sort credible set by posterior probability in descending order\n        \"locus\",\n        f.when(\n            f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n            order_array_of_structs_by_field(\"locus\", \"posteriorProbability\"),\n        ),\n    ).withColumn(\n        # Calculate array of cumulative sums of posterior probabilities to determine which variants are in the 95% and 99% credible sets\n        # and zip the cumulative sums array with the credible set array to add the flags\n        \"locus\",\n        f.when(\n            f.col(\"locus\").isNotNull() &amp; (f.size(f.col(\"locus\")) &gt; 0),\n            f.zip_with(\n                f.col(\"locus\"),\n                f.transform(\n                    f.sequence(f.lit(1), f.size(f.col(\"locus\"))),\n                    lambda index: f.aggregate(\n                        f.slice(\n                            # By using `index - 1` we introduce a value of `0.0` in the cumulative sums array. to ensure that the last variant\n                            # that exceeds the 0.95 threshold is included in the cumulative sum, as its probability is necessary to satisfy the threshold.\n                            f.col(\"locus.posteriorProbability\"),\n                            1,\n                            index - 1,\n                        ),\n                        f.lit(0.0),\n                        lambda acc, el: acc + el,\n                    ),\n                ),\n                lambda struct_e, acc: struct_e.withField(\n                    CredibleInterval.IS95.value, (acc &lt; 0.95) &amp; acc.isNotNull()\n                ).withField(\n                    CredibleInterval.IS99.value, (acc &lt; 0.99) &amp; acc.isNotNull()\n                ),\n            ),\n        ),\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.assign_study_locus_id","title":"<code>assign_study_locus_id(study_id_col, variant_id_col)</code>  <code>staticmethod</code>","text":"<p>Hashes a column with a variant ID and a study ID to extract a consistent studyLocusId.</p> <p>Parameters:</p> Name Type Description Default <code>study_id_col</code> <code>Column</code> <p>column name with a study ID</p> required <code>variant_id_col</code> <code>Column</code> <p>column name with a variant ID</p> required <p>Returns:</p> Name Type Description <code>Column</code> <code>Column</code> <p>column with a study locus ID</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = spark.createDataFrame([(\"GCST000001\", \"1_1000_A_C\"), (\"GCST000002\", \"1_1000_A_C\")]).toDF(\"studyId\", \"variantId\")\n&gt;&gt;&gt; df.withColumn(\"study_locus_id\", StudyLocus.assign_study_locus_id(*[f.col(\"variantId\"), f.col(\"studyId\")])).show()\n+----------+----------+--------------------+\n|   studyId| variantId|      study_locus_id|\n+----------+----------+--------------------+\n|GCST000001|1_1000_A_C| 7437284926964690765|\n|GCST000002|1_1000_A_C|-7653912547667845377|\n+----------+----------+--------------------+\n</code></pre> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>@staticmethod\ndef assign_study_locus_id(study_id_col: Column, variant_id_col: Column) -&gt; Column:\n    \"\"\"Hashes a column with a variant ID and a study ID to extract a consistent studyLocusId.\n\n    Args:\n        study_id_col (Column): column name with a study ID\n        variant_id_col (Column): column name with a variant ID\n\n    Returns:\n        Column: column with a study locus ID\n\n    Examples:\n        &gt;&gt;&gt; df = spark.createDataFrame([(\"GCST000001\", \"1_1000_A_C\"), (\"GCST000002\", \"1_1000_A_C\")]).toDF(\"studyId\", \"variantId\")\n        &gt;&gt;&gt; df.withColumn(\"study_locus_id\", StudyLocus.assign_study_locus_id(*[f.col(\"variantId\"), f.col(\"studyId\")])).show()\n        +----------+----------+--------------------+\n        |   studyId| variantId|      study_locus_id|\n        +----------+----------+--------------------+\n        |GCST000001|1_1000_A_C| 7437284926964690765|\n        |GCST000002|1_1000_A_C|-7653912547667845377|\n        +----------+----------+--------------------+\n        &lt;BLANKLINE&gt;\n    \"\"\"\n    return f.xxhash64(*[study_id_col, variant_id_col]).alias(\"studyLocusId\")\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.clump","title":"<code>clump()</code>","text":"<p>Perform LD clumping of the studyLocus.</p> <p>Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.</p> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>with empty credible sets for linked variants and QC flag.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def clump(self: StudyLocus) -&gt; StudyLocus:\n    \"\"\"Perform LD clumping of the studyLocus.\n\n    Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.\n\n    Returns:\n        StudyLocus: with empty credible sets for linked variants and QC flag.\n    \"\"\"\n    self.df = (\n        self.df.withColumn(\n            \"is_lead_linked\",\n            LDclumping._is_lead_linked(\n                self.df.studyId,\n                self.df.variantId,\n                self.df.pValueExponent,\n                self.df.pValueMantissa,\n                self.df.ldSet,\n            ),\n        )\n        .withColumn(\n            \"ldSet\",\n            f.when(f.col(\"is_lead_linked\"), f.array()).otherwise(f.col(\"ldSet\")),\n        )\n        .withColumn(\n            \"qualityControls\",\n            StudyLocus._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.col(\"is_lead_linked\"),\n                StudyLocusQualityCheck.LD_CLUMPED,\n            ),\n        )\n        .drop(\"is_lead_linked\")\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.filter_credible_set","title":"<code>filter_credible_set(credible_interval)</code>","text":"<p>Filter study-locus tag variants based on given credible interval.</p> <p>Parameters:</p> Name Type Description Default <code>credible_interval</code> <code>CredibleInterval</code> <p>Credible interval to filter for.</p> required <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>Filtered study-locus dataset.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def filter_credible_set(\n    self: StudyLocus,\n    credible_interval: CredibleInterval,\n) -&gt; StudyLocus:\n    \"\"\"Filter study-locus tag variants based on given credible interval.\n\n    Args:\n        credible_interval (CredibleInterval): Credible interval to filter for.\n\n    Returns:\n        StudyLocus: Filtered study-locus dataset.\n    \"\"\"\n    self.df = self._df.withColumn(\n        \"locus\",\n        f.expr(f\"filter(locus, tag -&gt; (tag.{credible_interval.value}))\"),\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.find_overlaps","title":"<code>find_overlaps(study_index)</code>","text":"<p>Calculate overlapping study-locus.</p> <p>Find overlapping study-locus that share at least one tagging variant. All GWAS-GWAS and all GWAS-Molecular traits are computed with the Molecular traits always appearing on the right side.</p> <p>Parameters:</p> Name Type Description Default <code>study_index</code> <code>StudyIndex</code> <p>Study index to resolve study types.</p> required <p>Returns:</p> Name Type Description <code>StudyLocusOverlap</code> <code>StudyLocusOverlap</code> <p>Pairs of overlapping study-locus with aligned tags.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def find_overlaps(self: StudyLocus, study_index: StudyIndex) -&gt; StudyLocusOverlap:\n    \"\"\"Calculate overlapping study-locus.\n\n    Find overlapping study-locus that share at least one tagging variant. All GWAS-GWAS and all GWAS-Molecular traits are computed with the Molecular traits always\n    appearing on the right side.\n\n    Args:\n        study_index (StudyIndex): Study index to resolve study types.\n\n    Returns:\n        StudyLocusOverlap: Pairs of overlapping study-locus with aligned tags.\n    \"\"\"\n    loci_to_overlap = (\n        self.df.join(study_index.study_type_lut(), on=\"studyId\", how=\"inner\")\n        .withColumn(\"locus\", f.explode(\"locus\"))\n        .select(\n            \"studyLocusId\",\n            \"studyType\",\n            \"chromosome\",\n            f.col(\"locus.variantId\").alias(\"tagVariantId\"),\n            f.col(\"locus.logABF\").alias(\"logABF\"),\n            f.col(\"locus.posteriorProbability\").alias(\"posteriorProbability\"),\n            f.col(\"locus.pValueMantissa\").alias(\"pValueMantissa\"),\n            f.col(\"locus.pValueExponent\").alias(\"pValueExponent\"),\n            f.col(\"locus.beta\").alias(\"beta\"),\n        )\n        .persist()\n    )\n\n    # overlapping study-locus\n    peak_overlaps = self._overlapping_peaks(loci_to_overlap)\n\n    # study-locus overlap by aligning overlapping variants\n    return self._align_overlapping_tags(loci_to_overlap, peak_overlaps)\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the StudyLocus dataset.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[StudyLocus]) -&gt; StructType:\n    \"\"\"Provides the schema for the StudyLocus dataset.\"\"\"\n    return parse_spark_schema(\"study_locus.json\")\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.neglog_pvalue","title":"<code>neglog_pvalue()</code>","text":"<p>Returns the negative log p-value.</p> <p>Returns:</p> Name Type Description <code>Column</code> <code>Column</code> <p>Negative log p-value</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def neglog_pvalue(self: StudyLocus) -&gt; Column:\n    \"\"\"Returns the negative log p-value.\n\n    Returns:\n        Column: Negative log p-value\n    \"\"\"\n    return calculate_neglog_pvalue(\n        self.df.pValueMantissa,\n        self.df.pValueExponent,\n    )\n</code></pre>"},{"location":"python_api/dataset/study_locus/#otg.dataset.study_locus.StudyLocus.unique_variants_in_locus","title":"<code>unique_variants_in_locus()</code>","text":"<p>All unique variants collected in a <code>StudyLocus</code> dataframe.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A dataframe containing <code>variantId</code> and <code>chromosome</code> columns.</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>def unique_variants_in_locus(self: StudyLocus) -&gt; DataFrame:\n    \"\"\"All unique variants collected in a `StudyLocus` dataframe.\n\n    Returns:\n        DataFrame: A dataframe containing `variantId` and `chromosome` columns.\n    \"\"\"\n    return (\n        self.df.withColumn(\n            \"variantId\",\n            # Joint array of variants in that studylocus. Locus can be null\n            f.explode(\n                f.array_union(\n                    f.array(f.col(\"variantId\")),\n                    f.coalesce(f.col(\"locus.variantId\"), f.array()),\n                )\n            ),\n        )\n        .select(\n            \"variantId\", f.split(f.col(\"variantId\"), \"_\")[0].alias(\"chromosome\")\n        )\n        .distinct()\n    )\n</code></pre>"},{"location":"python_api/dataset/study_locus/#study-locus-quality-controls","title":"Study-locus quality controls","text":"<p>             Bases: <code>Enum</code></p> <p>Study-Locus quality control options listing concerns on the quality of the association.</p> <p>Attributes:</p> Name Type Description <code>SUBSIGNIFICANT_FLAG</code> <code>str</code> <p>p-value below significance threshold</p> <code>NO_GENOMIC_LOCATION_FLAG</code> <code>str</code> <p>Incomplete genomic mapping</p> <code>COMPOSITE_FLAG</code> <code>str</code> <p>Composite association due to variant x variant interactions</p> <code>VARIANT_INCONSISTENCY_FLAG</code> <code>str</code> <p>Inconsistencies in the reported variants</p> <code>NON_MAPPED_VARIANT_FLAG</code> <code>str</code> <p>Variant not mapped to GnomAd</p> <code>PALINDROMIC_ALLELE_FLAG</code> <code>str</code> <p>Alleles are palindromic - cannot harmonize</p> <code>AMBIGUOUS_STUDY</code> <code>str</code> <p>Association with ambiguous study</p> <code>UNRESOLVED_LD</code> <code>str</code> <p>Variant not found in LD reference</p> <code>LD_CLUMPED</code> <code>str</code> <p>Explained by a more significant variant in high LD (clumped)</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>class StudyLocusQualityCheck(Enum):\n    \"\"\"Study-Locus quality control options listing concerns on the quality of the association.\n\n    Attributes:\n        SUBSIGNIFICANT_FLAG (str): p-value below significance threshold\n        NO_GENOMIC_LOCATION_FLAG (str): Incomplete genomic mapping\n        COMPOSITE_FLAG (str): Composite association due to variant x variant interactions\n        VARIANT_INCONSISTENCY_FLAG (str): Inconsistencies in the reported variants\n        NON_MAPPED_VARIANT_FLAG (str): Variant not mapped to GnomAd\n        PALINDROMIC_ALLELE_FLAG (str): Alleles are palindromic - cannot harmonize\n        AMBIGUOUS_STUDY (str): Association with ambiguous study\n        UNRESOLVED_LD (str): Variant not found in LD reference\n        LD_CLUMPED (str): Explained by a more significant variant in high LD (clumped)\n    \"\"\"\n\n    SUBSIGNIFICANT_FLAG = \"Subsignificant p-value\"\n    NO_GENOMIC_LOCATION_FLAG = \"Incomplete genomic mapping\"\n    COMPOSITE_FLAG = \"Composite association\"\n    INCONSISTENCY_FLAG = \"Variant inconsistency\"\n    NON_MAPPED_VARIANT_FLAG = \"No mapping in GnomAd\"\n    PALINDROMIC_ALLELE_FLAG = \"Palindrome alleles - cannot harmonize\"\n    AMBIGUOUS_STUDY = \"Association with ambiguous study\"\n    UNRESOLVED_LD = \"Variant not found in LD reference\"\n    LD_CLUMPED = \"Explained by a more significant variant in high LD (clumped)\"\n    NO_POPULATION = \"Study does not have population annotation to resolve LD\"\n</code></pre>"},{"location":"python_api/dataset/study_locus/#credible-interval","title":"Credible interval","text":"<p>             Bases: <code>Enum</code></p> <p>Credible interval enum.</p> <p>Interval within which an unobserved parameter value falls with a particular probability.</p> <p>Attributes:</p> Name Type Description <code>IS95</code> <code>str</code> <p>95% credible interval</p> <code>IS99</code> <code>str</code> <p>99% credible interval</p> Source code in <code>src/otg/dataset/study_locus.py</code> <pre><code>class CredibleInterval(Enum):\n    \"\"\"Credible interval enum.\n\n    Interval within which an unobserved parameter value falls with a particular probability.\n\n    Attributes:\n        IS95 (str): 95% credible interval\n        IS99 (str): 99% credible interval\n    \"\"\"\n\n    IS95 = \"is95CredibleSet\"\n    IS99 = \"is99CredibleSet\"\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/","title":"StudyLocusOverlap","text":""},{"location":"python_api/dataset/study_locus_overlap/#schema","title":"Schema","text":"<pre><code>root\n |-- leftStudyLocusId: long (nullable = false)\n |-- rightStudyLocusId: long (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- tagVariantId: string (nullable = false)\n |-- statistics: struct (nullable = false)\n |    |-- left_pValueMantissa: float (nullable = true)\n |    |-- left_pValueExponent: integer (nullable = true)\n |    |-- right_pValueMantissa: float (nullable = true)\n |    |-- right_pValueExponent: integer (nullable = true)\n |    |-- left_beta: double (nullable = true)\n |    |-- right_beta: double (nullable = true)\n |    |-- left_logABF: double (nullable = true)\n |    |-- right_logABF: double (nullable = true)\n |    |-- left_posteriorProbability: double (nullable = true)\n |    |-- right_posteriorProbability: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Study-Locus overlap.</p> <p>This dataset captures pairs of overlapping <code>StudyLocus</code>: that is associations whose credible sets share at least one tagging variant.</p> <p>Note</p> <p>This is a helpful dataset for other downstream analyses, such as colocalisation. This dataset will contain the overlapping signals between studyLocus associations once they have been clumped and fine-mapped.</p> Source code in <code>src/otg/dataset/study_locus_overlap.py</code> <pre><code>@dataclass\nclass StudyLocusOverlap(Dataset):\n    \"\"\"Study-Locus overlap.\n\n    This dataset captures pairs of overlapping `StudyLocus`: that is associations whose credible sets share at least one tagging variant.\n\n    !!! note\n        This is a helpful dataset for other downstream analyses, such as colocalisation. This dataset will contain the overlapping signals between studyLocus associations once they have been clumped and fine-mapped.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[StudyLocusOverlap]) -&gt; StructType:\n        \"\"\"Provides the schema for the StudyLocusOverlap dataset.\"\"\"\n        return parse_spark_schema(\"study_locus_overlap.json\")\n\n    @classmethod\n    def from_associations(\n        cls: type[StudyLocusOverlap], study_locus: StudyLocus, study_index: StudyIndex\n    ) -&gt; StudyLocusOverlap:\n        \"\"\"Find the overlapping signals in a particular set of associations (StudyLocus dataset).\n\n        Args:\n            study_locus (StudyLocus): Study-locus associations to find the overlapping signals\n            study_index (StudyIndex): Study index to find the overlapping signals\n\n        Returns:\n            StudyLocusOverlap: Study-locus overlap dataset\n        \"\"\"\n        return study_locus.find_overlaps(study_index)\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/#otg.dataset.study_locus_overlap.StudyLocusOverlap.from_associations","title":"<code>from_associations(study_locus, study_index)</code>  <code>classmethod</code>","text":"<p>Find the overlapping signals in a particular set of associations (StudyLocus dataset).</p> <p>Parameters:</p> Name Type Description Default <code>study_locus</code> <code>StudyLocus</code> <p>Study-locus associations to find the overlapping signals</p> required <code>study_index</code> <code>StudyIndex</code> <p>Study index to find the overlapping signals</p> required <p>Returns:</p> Name Type Description <code>StudyLocusOverlap</code> <code>StudyLocusOverlap</code> <p>Study-locus overlap dataset</p> Source code in <code>src/otg/dataset/study_locus_overlap.py</code> <pre><code>@classmethod\ndef from_associations(\n    cls: type[StudyLocusOverlap], study_locus: StudyLocus, study_index: StudyIndex\n) -&gt; StudyLocusOverlap:\n    \"\"\"Find the overlapping signals in a particular set of associations (StudyLocus dataset).\n\n    Args:\n        study_locus (StudyLocus): Study-locus associations to find the overlapping signals\n        study_index (StudyIndex): Study index to find the overlapping signals\n\n    Returns:\n        StudyLocusOverlap: Study-locus overlap dataset\n    \"\"\"\n    return study_locus.find_overlaps(study_index)\n</code></pre>"},{"location":"python_api/dataset/study_locus_overlap/#otg.dataset.study_locus_overlap.StudyLocusOverlap.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the StudyLocusOverlap dataset.</p> Source code in <code>src/otg/dataset/study_locus_overlap.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[StudyLocusOverlap]) -&gt; StructType:\n    \"\"\"Provides the schema for the StudyLocusOverlap dataset.\"\"\"\n    return parse_spark_schema(\"study_locus_overlap.json\")\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/","title":"SummaryStatistics","text":""},{"location":"python_api/dataset/summary_statistics/#schema","title":"Schema","text":"<pre><code>root\n |-- studyId: string (nullable = false)\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- position: integer (nullable = false)\n |-- beta: double (nullable = false)\n |-- betaConfidenceIntervalLower: double (nullable = true)\n |-- betaConfidenceIntervalUpper: double (nullable = true)\n |-- pValueMantissa: float (nullable = false)\n |-- pValueExponent: integer (nullable = false)\n |-- effectAlleleFrequencyFromSource: float (nullable = true)\n |-- standardError: double (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Summary Statistics dataset.</p> <p>A summary statistics dataset contains all single point statistics resulting from a GWAS.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>@dataclass\nclass SummaryStatistics(Dataset):\n    \"\"\"Summary Statistics dataset.\n\n    A summary statistics dataset contains all single point statistics resulting from a GWAS.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[SummaryStatistics]) -&gt; StructType:\n        \"\"\"Provides the schema for the SummaryStatistics dataset.\"\"\"\n        return parse_spark_schema(\"summary_statistics.json\")\n\n    def pvalue_filter(self: SummaryStatistics, pvalue: float) -&gt; SummaryStatistics:\n        \"\"\"Filter summary statistics based on the provided p-value threshold.\n\n        Args:\n            pvalue (float): upper limit of the p-value to be filtered upon.\n\n        Returns:\n            SummaryStatistics: summary statistics object containing single point associations with p-values at least as significant as the provided threshold.\n        \"\"\"\n        # Converting p-value to mantissa and exponent:\n        (mantissa, exponent) = split_pvalue(pvalue)\n\n        # Applying filter:\n        df = self._df.filter(\n            (f.col(\"pValueExponent\") &lt; exponent)\n            | (\n                (f.col(\"pValueExponent\") == exponent)\n                &amp; (f.col(\"pValueMantissa\") &lt;= mantissa)\n            )\n        )\n        return SummaryStatistics(_df=df, _schema=self._schema)\n\n    def window_based_clumping(\n        self: SummaryStatistics,\n        distance: int,\n        gwas_significance: float = 5e-8,\n        baseline_significance: float = 0.05,\n        locus_collect_distance: int | None = None,\n    ) -&gt; StudyLocus:\n        \"\"\"Generate study-locus from summary statistics by distance based clumping + collect locus.\n\n        Args:\n            distance (int): Distance in base pairs to be used for clumping.\n            gwas_significance (float, optional): GWAS significance threshold. Defaults to 5e-8.\n            baseline_significance (float, optional): Baseline significance threshold for inclusion in the locus. Defaults to 0.05.\n            locus_collect_distance (int, optional): The distance to collect locus around semi-indices. If not provided, defaults to `distance`.\n\n        Returns:\n            StudyLocus: Clumped study-locus containing variants based on window.\n        \"\"\"\n        # If locus collect distance is present, collect locus with the provided distance:\n        if locus_collect_distance:\n            clumped_df = WindowBasedClumping.clump_with_locus(\n                self,\n                window_length=distance,\n                p_value_significance=gwas_significance,\n                p_value_baseline=baseline_significance,\n                locus_window_length=locus_collect_distance,\n            )\n        else:\n            clumped_df = WindowBasedClumping.clump(\n                self, window_length=distance, p_value_significance=gwas_significance\n            )\n\n        return clumped_df\n\n    def exclude_region(self: SummaryStatistics, region: str) -&gt; SummaryStatistics:\n        \"\"\"Exclude a region from the summary stats dataset.\n\n        Args:\n            region (str): region given in \"chr##:#####-####\" format\n\n        Returns:\n            SummaryStatistics: filtered summary statistics.\n        \"\"\"\n        (chromosome, start_position, end_position) = parse_region(region)\n\n        return SummaryStatistics(\n            _df=(\n                self.df.filter(\n                    ~(\n                        (f.col(\"chromosome\") == chromosome)\n                        &amp; (\n                            (f.col(\"position\") &gt;= start_position)\n                            &amp; (f.col(\"position\") &lt;= end_position)\n                        )\n                    )\n                )\n            ),\n            _schema=SummaryStatistics.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.exclude_region","title":"<code>exclude_region(region)</code>","text":"<p>Exclude a region from the summary stats dataset.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>region given in \"chr##:#####-####\" format</p> required <p>Returns:</p> Name Type Description <code>SummaryStatistics</code> <code>SummaryStatistics</code> <p>filtered summary statistics.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>def exclude_region(self: SummaryStatistics, region: str) -&gt; SummaryStatistics:\n    \"\"\"Exclude a region from the summary stats dataset.\n\n    Args:\n        region (str): region given in \"chr##:#####-####\" format\n\n    Returns:\n        SummaryStatistics: filtered summary statistics.\n    \"\"\"\n    (chromosome, start_position, end_position) = parse_region(region)\n\n    return SummaryStatistics(\n        _df=(\n            self.df.filter(\n                ~(\n                    (f.col(\"chromosome\") == chromosome)\n                    &amp; (\n                        (f.col(\"position\") &gt;= start_position)\n                        &amp; (f.col(\"position\") &lt;= end_position)\n                    )\n                )\n            )\n        ),\n        _schema=SummaryStatistics.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the SummaryStatistics dataset.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[SummaryStatistics]) -&gt; StructType:\n    \"\"\"Provides the schema for the SummaryStatistics dataset.\"\"\"\n    return parse_spark_schema(\"summary_statistics.json\")\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.pvalue_filter","title":"<code>pvalue_filter(pvalue)</code>","text":"<p>Filter summary statistics based on the provided p-value threshold.</p> <p>Parameters:</p> Name Type Description Default <code>pvalue</code> <code>float</code> <p>upper limit of the p-value to be filtered upon.</p> required <p>Returns:</p> Name Type Description <code>SummaryStatistics</code> <code>SummaryStatistics</code> <p>summary statistics object containing single point associations with p-values at least as significant as the provided threshold.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>def pvalue_filter(self: SummaryStatistics, pvalue: float) -&gt; SummaryStatistics:\n    \"\"\"Filter summary statistics based on the provided p-value threshold.\n\n    Args:\n        pvalue (float): upper limit of the p-value to be filtered upon.\n\n    Returns:\n        SummaryStatistics: summary statistics object containing single point associations with p-values at least as significant as the provided threshold.\n    \"\"\"\n    # Converting p-value to mantissa and exponent:\n    (mantissa, exponent) = split_pvalue(pvalue)\n\n    # Applying filter:\n    df = self._df.filter(\n        (f.col(\"pValueExponent\") &lt; exponent)\n        | (\n            (f.col(\"pValueExponent\") == exponent)\n            &amp; (f.col(\"pValueMantissa\") &lt;= mantissa)\n        )\n    )\n    return SummaryStatistics(_df=df, _schema=self._schema)\n</code></pre>"},{"location":"python_api/dataset/summary_statistics/#otg.dataset.summary_statistics.SummaryStatistics.window_based_clumping","title":"<code>window_based_clumping(distance, gwas_significance=5e-08, baseline_significance=0.05, locus_collect_distance=None)</code>","text":"<p>Generate study-locus from summary statistics by distance based clumping + collect locus.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>int</code> <p>Distance in base pairs to be used for clumping.</p> required <code>gwas_significance</code> <code>float</code> <p>GWAS significance threshold. Defaults to 5e-8.</p> <code>5e-08</code> <code>baseline_significance</code> <code>float</code> <p>Baseline significance threshold for inclusion in the locus. Defaults to 0.05.</p> <code>0.05</code> <code>locus_collect_distance</code> <code>int</code> <p>The distance to collect locus around semi-indices. If not provided, defaults to <code>distance</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>Clumped study-locus containing variants based on window.</p> Source code in <code>src/otg/dataset/summary_statistics.py</code> <pre><code>def window_based_clumping(\n    self: SummaryStatistics,\n    distance: int,\n    gwas_significance: float = 5e-8,\n    baseline_significance: float = 0.05,\n    locus_collect_distance: int | None = None,\n) -&gt; StudyLocus:\n    \"\"\"Generate study-locus from summary statistics by distance based clumping + collect locus.\n\n    Args:\n        distance (int): Distance in base pairs to be used for clumping.\n        gwas_significance (float, optional): GWAS significance threshold. Defaults to 5e-8.\n        baseline_significance (float, optional): Baseline significance threshold for inclusion in the locus. Defaults to 0.05.\n        locus_collect_distance (int, optional): The distance to collect locus around semi-indices. If not provided, defaults to `distance`.\n\n    Returns:\n        StudyLocus: Clumped study-locus containing variants based on window.\n    \"\"\"\n    # If locus collect distance is present, collect locus with the provided distance:\n    if locus_collect_distance:\n        clumped_df = WindowBasedClumping.clump_with_locus(\n            self,\n            window_length=distance,\n            p_value_significance=gwas_significance,\n            p_value_baseline=baseline_significance,\n            locus_window_length=locus_collect_distance,\n        )\n    else:\n        clumped_df = WindowBasedClumping.clump(\n            self, window_length=distance, p_value_significance=gwas_significance\n        )\n\n    return clumped_df\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/","title":"VariantAnnotation","text":""},{"location":"python_api/dataset/variant_annotation/#schema","title":"Schema","text":"<pre><code>root\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- position: integer (nullable = false)\n |-- gnomad3VariantId: string (nullable = false)\n |-- referenceAllele: string (nullable = false)\n |-- alternateAllele: string (nullable = false)\n |-- chromosomeB37: string (nullable = true)\n |-- positionB37: integer (nullable = true)\n |-- alleleType: string (nullable = true)\n |-- rsIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- alleleFrequencies: array (nullable = false)\n |    |-- element: struct (containsNull = true)\n |    |    |-- populationName: string (nullable = true)\n |    |    |-- alleleFrequency: double (nullable = true)\n |-- cadd: struct (nullable = true)\n |    |-- phred: float (nullable = true)\n |    |-- raw: float (nullable = true)\n |-- vep: struct (nullable = false)\n |    |-- mostSevereConsequence: string (nullable = true)\n |    |-- transcriptConsequences: array (nullable = true)\n |    |    |-- element: struct (containsNull = true)\n |    |    |    |-- aminoAcids: string (nullable = true)\n |    |    |    |-- consequenceTerms: array (nullable = true)\n |    |    |    |    |-- element: string (containsNull = true)\n |    |    |    |-- geneId: string (nullable = true)\n |    |    |    |-- lof: string (nullable = true)\n |    |    |    |-- polyphenScore: double (nullable = true)\n |    |    |    |-- polyphenPrediction: string (nullable = true)\n |    |    |    |-- siftScore: double (nullable = true)\n |    |    |    |-- siftPrediction: string (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Dataset with variant-level annotations.</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>@dataclass\nclass VariantAnnotation(Dataset):\n    \"\"\"Dataset with variant-level annotations.\"\"\"\n\n    @classmethod\n    def get_schema(cls: type[VariantAnnotation]) -&gt; StructType:\n        \"\"\"Provides the schema for the VariantAnnotation dataset.\"\"\"\n        return parse_spark_schema(\"variant_annotation.json\")\n\n    def max_maf(self: VariantAnnotation) -&gt; Column:\n        \"\"\"Maximum minor allele frequency accross all populations.\n\n        Returns:\n            Column: Maximum minor allele frequency accross all populations.\n        \"\"\"\n        return f.array_max(\n            f.transform(\n                self.df.alleleFrequencies,\n                lambda af: f.when(\n                    af.alleleFrequency &gt; 0.5, 1 - af.alleleFrequency\n                ).otherwise(af.alleleFrequency),\n            )\n        )\n\n    def filter_by_variant_df(\n        self: VariantAnnotation, df: DataFrame\n    ) -&gt; VariantAnnotation:\n        \"\"\"Filter variant annotation dataset by a variant dataframe.\n\n        Args:\n            df (DataFrame): A dataframe of variants\n\n        Returns:\n            VariantAnnotation: A filtered variant annotation dataset\n        \"\"\"\n        self.df = self._df.join(\n            f.broadcast(df.select(\"variantId\", \"chromosome\")),\n            on=[\"variantId\", \"chromosome\"],\n            how=\"inner\",\n        )\n        return self\n\n    def get_transcript_consequence_df(\n        self: VariantAnnotation, gene_index: Optional[GeneIndex] = None\n    ) -&gt; DataFrame:\n        \"\"\"Dataframe of exploded transcript consequences.\n\n        Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n        Args:\n            gene_index (GeneIndex): A gene index. Defaults to None.\n\n        Returns:\n            DataFrame: A dataframe exploded by transcript consequences with the columns variantId, chromosome, transcriptConsequence\n        \"\"\"\n        # exploding the array removes records without VEP annotation\n        transript_consequences = self.df.withColumn(\n            \"transcriptConsequence\", f.explode(\"vep.transcriptConsequences\")\n        ).select(\n            \"variantId\",\n            \"chromosome\",\n            \"position\",\n            \"transcriptConsequence\",\n            f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n        )\n        if gene_index:\n            transript_consequences = transript_consequences.join(\n                f.broadcast(gene_index.df),\n                on=[\"chromosome\", \"geneId\"],\n            )\n        return transript_consequences.persist()\n\n    def get_most_severe_vep_v2g(\n        self: VariantAnnotation,\n        vep_consequences: DataFrame,\n        gene_index: GeneIndex,\n    ) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments based on VEP's predicted consequence of the transcript.\n\n        Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n        Args:\n            vep_consequences (DataFrame): A dataframe of VEP consequences\n            gene_index (GeneIndex): A gene index to filter by. Defaults to None.\n\n        Returns:\n            V2G: High and medium severity variant to gene assignments\n        \"\"\"\n        return V2G(\n            _df=self.get_transcript_consequence_df(gene_index)\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n                f.explode(\"transcriptConsequence.consequenceTerms\").alias(\"label\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"variantConsequence\").alias(\"datasourceId\"),\n            )\n            .join(\n                f.broadcast(vep_consequences),\n                on=\"label\",\n                how=\"inner\",\n            )\n            .drop(\"label\")\n            .filter(f.col(\"score\") != 0)\n            # A variant can have multiple predicted consequences on a transcript, the most severe one is selected\n            .transform(\n                lambda df: get_record_with_maximum_value(\n                    df, [\"variantId\", \"geneId\"], \"score\"\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_polyphen_v2g(\n        self: VariantAnnotation, gene_index: Optional[GeneIndex] = None\n    ) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments with a PolyPhen's predicted score on the transcript.\n\n        Polyphen informs about the probability that a substitution is damaging.The score can be interpreted as follows:\n            - 0.0 to 0.15 -- Predicted to be benign.\n            - 0.15 to 1.0 -- Possibly damaging.\n            - 0.85 to 1.0 -- Predicted to be damaging.\n\n        Args:\n            gene_index (GeneIndex): A gene index to filter by. Defaults to None.\n\n        Returns:\n            V2G: variant to gene assignments with their polyphen scores\n        \"\"\"\n        return V2G(\n            _df=(\n                self.get_transcript_consequence_df(gene_index)\n                .filter(f.col(\"transcriptConsequence.polyphenScore\").isNotNull())\n                .select(\n                    \"variantId\",\n                    \"chromosome\",\n                    \"geneId\",\n                    f.col(\"transcriptConsequence.polyphenScore\").alias(\"score\"),\n                    f.lit(\"vep\").alias(\"datatypeId\"),\n                    f.lit(\"polyphen\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_sift_v2g(self: VariantAnnotation, filter_by: GeneIndex) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments with a SIFT's predicted score on the transcript.\n\n        SIFT informs about the probability that a substitution is tolerated. The score can be interpreted as follows:\n            - 0.0 to 0.05 -- Likely to be deleterious.\n            - 0.05 to 1.0 -- Likely to be tolerated.\n\n        Args:\n            gene_index (GeneIndex): A gene index to filter by.\n\n        Returns:\n            V2G: variant to gene assignments with their SIFT scores\n        \"\"\"\n        return V2G(\n            _df=(\n                self.get_transcript_consequence_df(filter_by)\n                .filter(f.col(\"transcriptConsequence.siftScore\").isNotNull())\n                .select(\n                    \"variantId\",\n                    \"chromosome\",\n                    \"geneId\",\n                    f.expr(\"1 - transcriptConsequence.siftScore\").alias(\"score\"),\n                    f.lit(\"vep\").alias(\"datatypeId\"),\n                    f.lit(\"sift\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_plof_v2g(self: VariantAnnotation, gene_index: GeneIndex) -&gt; V2G:\n        \"\"\"Creates a dataset with variant to gene assignments with a flag indicating if the variant is predicted to be a loss-of-function variant by the LOFTEE algorithm.\n\n        Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n        Args:\n            gene_index (GeneIndex): A gene index to filter by.\n\n        Returns:\n            V2G: variant to gene assignments from the LOFTEE algorithm\n        \"\"\"\n        return V2G(\n            _df=(\n                self.get_transcript_consequence_df(gene_index)\n                .filter(f.col(\"transcriptConsequence.lof\").isNotNull())\n                .withColumn(\n                    \"isHighQualityPlof\",\n                    f.when(f.col(\"transcriptConsequence.lof\") == \"HC\", True).when(\n                        f.col(\"transcriptConsequence.lof\") == \"LC\", False\n                    ),\n                )\n                .withColumn(\n                    \"score\",\n                    f.when(f.col(\"isHighQualityPlof\"), 1.0).when(\n                        ~f.col(\"isHighQualityPlof\"), 0\n                    ),\n                )\n                .select(\n                    \"variantId\",\n                    \"chromosome\",\n                    \"geneId\",\n                    \"isHighQualityPlof\",\n                    f.col(\"score\"),\n                    f.lit(\"vep\").alias(\"datatypeId\"),\n                    f.lit(\"loftee\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n\n    def get_distance_to_tss(\n        self: VariantAnnotation,\n        gene_index: GeneIndex,\n        max_distance: int = 500_000,\n    ) -&gt; V2G:\n        \"\"\"Extracts variant to gene assignments for variants falling within a window of a gene's TSS.\n\n        Args:\n            filter_by (GeneIndex): A gene index to filter by.\n            max_distance (int): The maximum distance from the TSS to consider. Defaults to 500_000.\n\n        Returns:\n            V2G: variant to gene assignments with their distance to the TSS\n        \"\"\"\n        return V2G(\n            _df=(\n                self.df.alias(\"variant\")\n                .join(\n                    f.broadcast(gene_index.locations_lut()).alias(\"gene\"),\n                    on=[\n                        f.col(\"variant.chromosome\") == f.col(\"gene.chromosome\"),\n                        f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n                        &lt;= max_distance,\n                    ],\n                    how=\"inner\",\n                )\n                .withColumn(\n                    \"distance\", f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n                )\n                .withColumn(\n                    \"inverse_distance\",\n                    max_distance - f.col(\"distance\"),\n                )\n                .transform(lambda df: normalise_column(df, \"inverse_distance\", \"score\"))\n                .select(\n                    \"variantId\",\n                    f.col(\"variant.chromosome\").alias(\"chromosome\"),\n                    \"distance\",\n                    \"geneId\",\n                    \"score\",\n                    f.lit(\"distance\").alias(\"datatypeId\"),\n                    f.lit(\"canonical_tss\").alias(\"datasourceId\"),\n                )\n            ),\n            _schema=V2G.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.filter_by_variant_df","title":"<code>filter_by_variant_df(df)</code>","text":"<p>Filter variant annotation dataset by a variant dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A dataframe of variants</p> required <p>Returns:</p> Name Type Description <code>VariantAnnotation</code> <code>VariantAnnotation</code> <p>A filtered variant annotation dataset</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def filter_by_variant_df(\n    self: VariantAnnotation, df: DataFrame\n) -&gt; VariantAnnotation:\n    \"\"\"Filter variant annotation dataset by a variant dataframe.\n\n    Args:\n        df (DataFrame): A dataframe of variants\n\n    Returns:\n        VariantAnnotation: A filtered variant annotation dataset\n    \"\"\"\n    self.df = self._df.join(\n        f.broadcast(df.select(\"variantId\", \"chromosome\")),\n        on=[\"variantId\", \"chromosome\"],\n        how=\"inner\",\n    )\n    return self\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_distance_to_tss","title":"<code>get_distance_to_tss(gene_index, max_distance=500000)</code>","text":"<p>Extracts variant to gene assignments for variants falling within a window of a gene's TSS.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by</code> <code>GeneIndex</code> <p>A gene index to filter by.</p> required <code>max_distance</code> <code>int</code> <p>The maximum distance from the TSS to consider. Defaults to 500_000.</p> <code>500000</code> <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments with their distance to the TSS</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_distance_to_tss(\n    self: VariantAnnotation,\n    gene_index: GeneIndex,\n    max_distance: int = 500_000,\n) -&gt; V2G:\n    \"\"\"Extracts variant to gene assignments for variants falling within a window of a gene's TSS.\n\n    Args:\n        filter_by (GeneIndex): A gene index to filter by.\n        max_distance (int): The maximum distance from the TSS to consider. Defaults to 500_000.\n\n    Returns:\n        V2G: variant to gene assignments with their distance to the TSS\n    \"\"\"\n    return V2G(\n        _df=(\n            self.df.alias(\"variant\")\n            .join(\n                f.broadcast(gene_index.locations_lut()).alias(\"gene\"),\n                on=[\n                    f.col(\"variant.chromosome\") == f.col(\"gene.chromosome\"),\n                    f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n                    &lt;= max_distance,\n                ],\n                how=\"inner\",\n            )\n            .withColumn(\n                \"distance\", f.abs(f.col(\"variant.position\") - f.col(\"gene.tss\"))\n            )\n            .withColumn(\n                \"inverse_distance\",\n                max_distance - f.col(\"distance\"),\n            )\n            .transform(lambda df: normalise_column(df, \"inverse_distance\", \"score\"))\n            .select(\n                \"variantId\",\n                f.col(\"variant.chromosome\").alias(\"chromosome\"),\n                \"distance\",\n                \"geneId\",\n                \"score\",\n                f.lit(\"distance\").alias(\"datatypeId\"),\n                f.lit(\"canonical_tss\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_most_severe_vep_v2g","title":"<code>get_most_severe_vep_v2g(vep_consequences, gene_index)</code>","text":"<p>Creates a dataset with variant to gene assignments based on VEP's predicted consequence of the transcript.</p> <p>Optionally the trancript consequences can be reduced to the universe of a gene index.</p> <p>Parameters:</p> Name Type Description Default <code>vep_consequences</code> <code>DataFrame</code> <p>A dataframe of VEP consequences</p> required <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by. Defaults to None.</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>High and medium severity variant to gene assignments</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_most_severe_vep_v2g(\n    self: VariantAnnotation,\n    vep_consequences: DataFrame,\n    gene_index: GeneIndex,\n) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments based on VEP's predicted consequence of the transcript.\n\n    Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n    Args:\n        vep_consequences (DataFrame): A dataframe of VEP consequences\n        gene_index (GeneIndex): A gene index to filter by. Defaults to None.\n\n    Returns:\n        V2G: High and medium severity variant to gene assignments\n    \"\"\"\n    return V2G(\n        _df=self.get_transcript_consequence_df(gene_index)\n        .select(\n            \"variantId\",\n            \"chromosome\",\n            f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n            f.explode(\"transcriptConsequence.consequenceTerms\").alias(\"label\"),\n            f.lit(\"vep\").alias(\"datatypeId\"),\n            f.lit(\"variantConsequence\").alias(\"datasourceId\"),\n        )\n        .join(\n            f.broadcast(vep_consequences),\n            on=\"label\",\n            how=\"inner\",\n        )\n        .drop(\"label\")\n        .filter(f.col(\"score\") != 0)\n        # A variant can have multiple predicted consequences on a transcript, the most severe one is selected\n        .transform(\n            lambda df: get_record_with_maximum_value(\n                df, [\"variantId\", \"geneId\"], \"score\"\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_plof_v2g","title":"<code>get_plof_v2g(gene_index)</code>","text":"<p>Creates a dataset with variant to gene assignments with a flag indicating if the variant is predicted to be a loss-of-function variant by the LOFTEE algorithm.</p> <p>Optionally the trancript consequences can be reduced to the universe of a gene index.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by.</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments from the LOFTEE algorithm</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_plof_v2g(self: VariantAnnotation, gene_index: GeneIndex) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments with a flag indicating if the variant is predicted to be a loss-of-function variant by the LOFTEE algorithm.\n\n    Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n    Args:\n        gene_index (GeneIndex): A gene index to filter by.\n\n    Returns:\n        V2G: variant to gene assignments from the LOFTEE algorithm\n    \"\"\"\n    return V2G(\n        _df=(\n            self.get_transcript_consequence_df(gene_index)\n            .filter(f.col(\"transcriptConsequence.lof\").isNotNull())\n            .withColumn(\n                \"isHighQualityPlof\",\n                f.when(f.col(\"transcriptConsequence.lof\") == \"HC\", True).when(\n                    f.col(\"transcriptConsequence.lof\") == \"LC\", False\n                ),\n            )\n            .withColumn(\n                \"score\",\n                f.when(f.col(\"isHighQualityPlof\"), 1.0).when(\n                    ~f.col(\"isHighQualityPlof\"), 0\n                ),\n            )\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                \"geneId\",\n                \"isHighQualityPlof\",\n                f.col(\"score\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"loftee\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_polyphen_v2g","title":"<code>get_polyphen_v2g(gene_index=None)</code>","text":"<p>Creates a dataset with variant to gene assignments with a PolyPhen's predicted score on the transcript.</p> <p>Polyphen informs about the probability that a substitution is damaging.The score can be interpreted as follows:     - 0.0 to 0.15 -- Predicted to be benign.     - 0.15 to 1.0 -- Possibly damaging.     - 0.85 to 1.0 -- Predicted to be damaging.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments with their polyphen scores</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_polyphen_v2g(\n    self: VariantAnnotation, gene_index: Optional[GeneIndex] = None\n) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments with a PolyPhen's predicted score on the transcript.\n\n    Polyphen informs about the probability that a substitution is damaging.The score can be interpreted as follows:\n        - 0.0 to 0.15 -- Predicted to be benign.\n        - 0.15 to 1.0 -- Possibly damaging.\n        - 0.85 to 1.0 -- Predicted to be damaging.\n\n    Args:\n        gene_index (GeneIndex): A gene index to filter by. Defaults to None.\n\n    Returns:\n        V2G: variant to gene assignments with their polyphen scores\n    \"\"\"\n    return V2G(\n        _df=(\n            self.get_transcript_consequence_df(gene_index)\n            .filter(f.col(\"transcriptConsequence.polyphenScore\").isNotNull())\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                \"geneId\",\n                f.col(\"transcriptConsequence.polyphenScore\").alias(\"score\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"polyphen\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the VariantAnnotation dataset.</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[VariantAnnotation]) -&gt; StructType:\n    \"\"\"Provides the schema for the VariantAnnotation dataset.\"\"\"\n    return parse_spark_schema(\"variant_annotation.json\")\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_sift_v2g","title":"<code>get_sift_v2g(filter_by)</code>","text":"<p>Creates a dataset with variant to gene assignments with a SIFT's predicted score on the transcript.</p> <p>SIFT informs about the probability that a substitution is tolerated. The score can be interpreted as follows:     - 0.0 to 0.05 -- Likely to be deleterious.     - 0.05 to 1.0 -- Likely to be tolerated.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex</code> <p>A gene index to filter by.</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>variant to gene assignments with their SIFT scores</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_sift_v2g(self: VariantAnnotation, filter_by: GeneIndex) -&gt; V2G:\n    \"\"\"Creates a dataset with variant to gene assignments with a SIFT's predicted score on the transcript.\n\n    SIFT informs about the probability that a substitution is tolerated. The score can be interpreted as follows:\n        - 0.0 to 0.05 -- Likely to be deleterious.\n        - 0.05 to 1.0 -- Likely to be tolerated.\n\n    Args:\n        gene_index (GeneIndex): A gene index to filter by.\n\n    Returns:\n        V2G: variant to gene assignments with their SIFT scores\n    \"\"\"\n    return V2G(\n        _df=(\n            self.get_transcript_consequence_df(filter_by)\n            .filter(f.col(\"transcriptConsequence.siftScore\").isNotNull())\n            .select(\n                \"variantId\",\n                \"chromosome\",\n                \"geneId\",\n                f.expr(\"1 - transcriptConsequence.siftScore\").alias(\"score\"),\n                f.lit(\"vep\").alias(\"datatypeId\"),\n                f.lit(\"sift\").alias(\"datasourceId\"),\n            )\n        ),\n        _schema=V2G.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.get_transcript_consequence_df","title":"<code>get_transcript_consequence_df(gene_index=None)</code>","text":"<p>Dataframe of exploded transcript consequences.</p> <p>Optionally the trancript consequences can be reduced to the universe of a gene index.</p> <p>Parameters:</p> Name Type Description Default <code>gene_index</code> <code>GeneIndex</code> <p>A gene index. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A dataframe exploded by transcript consequences with the columns variantId, chromosome, transcriptConsequence</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def get_transcript_consequence_df(\n    self: VariantAnnotation, gene_index: Optional[GeneIndex] = None\n) -&gt; DataFrame:\n    \"\"\"Dataframe of exploded transcript consequences.\n\n    Optionally the trancript consequences can be reduced to the universe of a gene index.\n\n    Args:\n        gene_index (GeneIndex): A gene index. Defaults to None.\n\n    Returns:\n        DataFrame: A dataframe exploded by transcript consequences with the columns variantId, chromosome, transcriptConsequence\n    \"\"\"\n    # exploding the array removes records without VEP annotation\n    transript_consequences = self.df.withColumn(\n        \"transcriptConsequence\", f.explode(\"vep.transcriptConsequences\")\n    ).select(\n        \"variantId\",\n        \"chromosome\",\n        \"position\",\n        \"transcriptConsequence\",\n        f.col(\"transcriptConsequence.geneId\").alias(\"geneId\"),\n    )\n    if gene_index:\n        transript_consequences = transript_consequences.join(\n            f.broadcast(gene_index.df),\n            on=[\"chromosome\", \"geneId\"],\n        )\n    return transript_consequences.persist()\n</code></pre>"},{"location":"python_api/dataset/variant_annotation/#otg.dataset.variant_annotation.VariantAnnotation.max_maf","title":"<code>max_maf()</code>","text":"<p>Maximum minor allele frequency accross all populations.</p> <p>Returns:</p> Name Type Description <code>Column</code> <code>Column</code> <p>Maximum minor allele frequency accross all populations.</p> Source code in <code>src/otg/dataset/variant_annotation.py</code> <pre><code>def max_maf(self: VariantAnnotation) -&gt; Column:\n    \"\"\"Maximum minor allele frequency accross all populations.\n\n    Returns:\n        Column: Maximum minor allele frequency accross all populations.\n    \"\"\"\n    return f.array_max(\n        f.transform(\n            self.df.alleleFrequencies,\n            lambda af: f.when(\n                af.alleleFrequency &gt; 0.5, 1 - af.alleleFrequency\n            ).otherwise(af.alleleFrequency),\n        )\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_index/","title":"VariantIndex","text":""},{"location":"python_api/dataset/variant_index/#schema","title":"Schema","text":"<pre><code>root\n |-- variantId: string (nullable = false)\n |-- chromosome: string (nullable = false)\n |-- position: integer (nullable = false)\n |-- referenceAllele: string (nullable = false)\n |-- alternateAllele: string (nullable = false)\n |-- chromosomeB37: string (nullable = true)\n |-- positionB37: integer (nullable = true)\n |-- alleleType: string (nullable = false)\n |-- alleleFrequencies: array (nullable = false)\n |    |-- element: struct (containsNull = true)\n |    |    |-- populationName: string (nullable = true)\n |    |    |-- alleleFrequency: double (nullable = true)\n |-- cadd: struct (nullable = true)\n |    |-- phred: float (nullable = true)\n |    |-- raw: float (nullable = true)\n |-- mostSevereConsequence: string (nullable = true)\n |-- rsIds: array (nullable = true)\n |    |-- element: string (containsNull = true)\n</code></pre>"},{"location":"python_api/dataset/variant_index/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Variant index dataset.</p> <p>Variant index dataset is the result of intersecting the variant annotation dataset with the variants with V2D available information.</p> Source code in <code>src/otg/dataset/variant_index.py</code> <pre><code>@dataclass\nclass VariantIndex(Dataset):\n    \"\"\"Variant index dataset.\n\n    Variant index dataset is the result of intersecting the variant annotation dataset with the variants with V2D available information.\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[VariantIndex]) -&gt; StructType:\n        \"\"\"Provides the schema for the VariantIndex dataset.\"\"\"\n        return parse_spark_schema(\"variant_index.json\")\n\n    @classmethod\n    def from_variant_annotation(\n        cls: type[VariantIndex],\n        variant_annotation: VariantAnnotation,\n        study_locus: StudyLocus,\n    ) -&gt; VariantIndex:\n        \"\"\"Initialise VariantIndex from pre-existing variant annotation dataset.\"\"\"\n        unchanged_cols = [\n            \"variantId\",\n            \"chromosome\",\n            \"position\",\n            \"referenceAllele\",\n            \"alternateAllele\",\n            \"chromosomeB37\",\n            \"positionB37\",\n            \"alleleType\",\n            \"alleleFrequencies\",\n            \"cadd\",\n        ]\n        va_slimmed = variant_annotation.filter_by_variant_df(\n            study_locus.unique_variants_in_locus()\n        )\n        return cls(\n            _df=(\n                va_slimmed.df.select(\n                    *unchanged_cols,\n                    f.col(\"vep.mostSevereConsequence\").alias(\"mostSevereConsequence\"),\n                    # filters/rsid are arrays that can be empty, in this case we convert them to null\n                    nullify_empty_array(f.col(\"rsIds\")).alias(\"rsIds\"),\n                )\n                .repartition(400, \"chromosome\")\n                .sortWithinPartitions(\"chromosome\", \"position\")\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/dataset/variant_index/#otg.dataset.variant_index.VariantIndex.from_variant_annotation","title":"<code>from_variant_annotation(variant_annotation, study_locus)</code>  <code>classmethod</code>","text":"<p>Initialise VariantIndex from pre-existing variant annotation dataset.</p> Source code in <code>src/otg/dataset/variant_index.py</code> <pre><code>@classmethod\ndef from_variant_annotation(\n    cls: type[VariantIndex],\n    variant_annotation: VariantAnnotation,\n    study_locus: StudyLocus,\n) -&gt; VariantIndex:\n    \"\"\"Initialise VariantIndex from pre-existing variant annotation dataset.\"\"\"\n    unchanged_cols = [\n        \"variantId\",\n        \"chromosome\",\n        \"position\",\n        \"referenceAllele\",\n        \"alternateAllele\",\n        \"chromosomeB37\",\n        \"positionB37\",\n        \"alleleType\",\n        \"alleleFrequencies\",\n        \"cadd\",\n    ]\n    va_slimmed = variant_annotation.filter_by_variant_df(\n        study_locus.unique_variants_in_locus()\n    )\n    return cls(\n        _df=(\n            va_slimmed.df.select(\n                *unchanged_cols,\n                f.col(\"vep.mostSevereConsequence\").alias(\"mostSevereConsequence\"),\n                # filters/rsid are arrays that can be empty, in this case we convert them to null\n                nullify_empty_array(f.col(\"rsIds\")).alias(\"rsIds\"),\n            )\n            .repartition(400, \"chromosome\")\n            .sortWithinPartitions(\"chromosome\", \"position\")\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/dataset/variant_index/#otg.dataset.variant_index.VariantIndex.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the VariantIndex dataset.</p> Source code in <code>src/otg/dataset/variant_index.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[VariantIndex]) -&gt; StructType:\n    \"\"\"Provides the schema for the VariantIndex dataset.\"\"\"\n    return parse_spark_schema(\"variant_index.json\")\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/","title":"V2G","text":""},{"location":"python_api/dataset/variant_to_gene/#schema","title":"Schema","text":"<pre><code>root\n |-- geneId: string (nullable = false)\n |-- variantId: string (nullable = false)\n |-- distance: long (nullable = true)\n |-- chromosome: string (nullable = false)\n |-- datatypeId: string (nullable = false)\n |-- datasourceId: string (nullable = false)\n |-- score: double (nullable = true)\n |-- resourceScore: double (nullable = true)\n |-- pmid: string (nullable = true)\n |-- biofeature: string (nullable = true)\n |-- variantFunctionalConsequenceId: string (nullable = true)\n |-- isHighQualityPlof: boolean (nullable = true)\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/#class","title":"Class","text":"<p>             Bases: <code>Dataset</code></p> <p>Variant-to-gene (V2G) evidence dataset.</p> <p>A variant-to-gene (V2G) evidence is understood as any piece of evidence that supports the association of a variant with a likely causal gene. The evidence can sometimes be context-specific and refer to specific <code>biofeatures</code> (e.g. cell types)</p> Source code in <code>src/otg/dataset/v2g.py</code> <pre><code>@dataclass\nclass V2G(Dataset):\n    \"\"\"Variant-to-gene (V2G) evidence dataset.\n\n    A variant-to-gene (V2G) evidence is understood as any piece of evidence that supports the association of a variant with a likely causal gene. The evidence can sometimes be context-specific and refer to specific `biofeatures` (e.g. cell types)\n    \"\"\"\n\n    @classmethod\n    def get_schema(cls: type[V2G]) -&gt; StructType:\n        \"\"\"Provides the schema for the V2G dataset.\"\"\"\n        return parse_spark_schema(\"v2g.json\")\n\n    def filter_by_genes(self: V2G, genes: GeneIndex) -&gt; V2G:\n        \"\"\"Filter by V2G dataset by genes.\n\n        Args:\n            genes (GeneIndex): Gene index dataset to filter by\n\n        Returns:\n            V2G: V2G dataset filtered by genes\n        \"\"\"\n        self.df = self._df.join(genes.df.select(\"geneId\"), on=\"geneId\", how=\"inner\")\n        return self\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/#otg.dataset.v2g.V2G.filter_by_genes","title":"<code>filter_by_genes(genes)</code>","text":"<p>Filter by V2G dataset by genes.</p> <p>Parameters:</p> Name Type Description Default <code>genes</code> <code>GeneIndex</code> <p>Gene index dataset to filter by</p> required <p>Returns:</p> Name Type Description <code>V2G</code> <code>V2G</code> <p>V2G dataset filtered by genes</p> Source code in <code>src/otg/dataset/v2g.py</code> <pre><code>def filter_by_genes(self: V2G, genes: GeneIndex) -&gt; V2G:\n    \"\"\"Filter by V2G dataset by genes.\n\n    Args:\n        genes (GeneIndex): Gene index dataset to filter by\n\n    Returns:\n        V2G: V2G dataset filtered by genes\n    \"\"\"\n    self.df = self._df.join(genes.df.select(\"geneId\"), on=\"geneId\", how=\"inner\")\n    return self\n</code></pre>"},{"location":"python_api/dataset/variant_to_gene/#otg.dataset.v2g.V2G.get_schema","title":"<code>get_schema()</code>  <code>classmethod</code>","text":"<p>Provides the schema for the V2G dataset.</p> Source code in <code>src/otg/dataset/v2g.py</code> <pre><code>@classmethod\ndef get_schema(cls: type[V2G]) -&gt; StructType:\n    \"\"\"Provides the schema for the V2G dataset.\"\"\"\n    return parse_spark_schema(\"v2g.json\")\n</code></pre>"},{"location":"python_api/datasource/_datasource/","title":"Datasource","text":"<p>TBC</p>"},{"location":"python_api/datasource/finngen/_finngen/","title":"FinnGen","text":""},{"location":"python_api/datasource/finngen/study_index/","title":"Study index","text":"<p>             Bases: <code>StudyIndex</code></p> <p>Study index dataset from FinnGen.</p> <p>The following information is aggregated/extracted:</p> <ul> <li>Study ID in the special format (FINNGEN_R9_*)</li> <li>Trait name (for example, Amoebiasis)</li> <li>Number of cases and controls</li> <li>Link to the summary statistics location</li> </ul> <p>Some fields are also populated as constants, such as study type and the initial sample size.</p> Source code in <code>src/otg/datasource/finngen/study_index.py</code> <pre><code>class FinnGenStudyIndex(StudyIndex):\n    \"\"\"Study index dataset from FinnGen.\n\n    The following information is aggregated/extracted:\n\n    - Study ID in the special format (FINNGEN_R9_*)\n    - Trait name (for example, Amoebiasis)\n    - Number of cases and controls\n    - Link to the summary statistics location\n\n    Some fields are also populated as constants, such as study type and the initial sample size.\n    \"\"\"\n\n    @classmethod\n    def from_source(\n        cls: type[FinnGenStudyIndex],\n        finngen_studies: DataFrame,\n        finngen_release_prefix: str,\n        finngen_summary_stats_url_prefix: str,\n        finngen_summary_stats_url_suffix: str,\n    ) -&gt; FinnGenStudyIndex:\n        \"\"\"This function ingests study level metadata from FinnGen.\n\n        Args:\n            finngen_studies (DataFrame): FinnGen raw study table\n            finngen_release_prefix (str): Release prefix pattern.\n            finngen_summary_stats_url_prefix (str): URL prefix for summary statistics location.\n            finngen_summary_stats_url_suffix (str): URL prefix suffix for summary statistics location.\n\n        Returns:\n            FinnGenStudyIndex: Parsed and annotated FinnGen study table.\n        \"\"\"\n        return FinnGenStudyIndex(\n            _df=finngen_studies.select(\n                f.concat(f.lit(f\"{finngen_release_prefix}_\"), f.col(\"phenocode\")).alias(\n                    \"studyId\"\n                ),\n                f.col(\"phenostring\").alias(\"traitFromSource\"),\n                f.col(\"num_cases\").alias(\"nCases\"),\n                f.col(\"num_controls\").alias(\"nControls\"),\n                (f.col(\"num_cases\") + f.col(\"num_controls\")).alias(\"nSamples\"),\n                f.lit(finngen_release_prefix).alias(\"projectId\"),\n                f.lit(\"gwas\").alias(\"studyType\"),\n                f.lit(True).alias(\"hasSumstats\"),\n                f.lit(\"377,277 (210,870 females and 166,407 males)\").alias(\n                    \"initialSampleSize\"\n                ),\n                f.array(\n                    f.struct(\n                        f.lit(377277).cast(\"long\").alias(\"sampleSize\"),\n                        f.lit(\"Finnish\").alias(\"ancestry\"),\n                    )\n                ).alias(\"discoverySamples\"),\n                f.concat(\n                    f.lit(finngen_summary_stats_url_prefix),\n                    f.col(\"phenocode\"),\n                    f.lit(finngen_summary_stats_url_suffix),\n                ).alias(\"summarystatsLocation\"),\n            ).withColumn(\n                \"ldPopulationStructure\",\n                cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/finngen/study_index/#otg.datasource.finngen.study_index.FinnGenStudyIndex.from_source","title":"<code>from_source(finngen_studies, finngen_release_prefix, finngen_summary_stats_url_prefix, finngen_summary_stats_url_suffix)</code>  <code>classmethod</code>","text":"<p>This function ingests study level metadata from FinnGen.</p> <p>Parameters:</p> Name Type Description Default <code>finngen_studies</code> <code>DataFrame</code> <p>FinnGen raw study table</p> required <code>finngen_release_prefix</code> <code>str</code> <p>Release prefix pattern.</p> required <code>finngen_summary_stats_url_prefix</code> <code>str</code> <p>URL prefix for summary statistics location.</p> required <code>finngen_summary_stats_url_suffix</code> <code>str</code> <p>URL prefix suffix for summary statistics location.</p> required <p>Returns:</p> Name Type Description <code>FinnGenStudyIndex</code> <code>FinnGenStudyIndex</code> <p>Parsed and annotated FinnGen study table.</p> Source code in <code>src/otg/datasource/finngen/study_index.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[FinnGenStudyIndex],\n    finngen_studies: DataFrame,\n    finngen_release_prefix: str,\n    finngen_summary_stats_url_prefix: str,\n    finngen_summary_stats_url_suffix: str,\n) -&gt; FinnGenStudyIndex:\n    \"\"\"This function ingests study level metadata from FinnGen.\n\n    Args:\n        finngen_studies (DataFrame): FinnGen raw study table\n        finngen_release_prefix (str): Release prefix pattern.\n        finngen_summary_stats_url_prefix (str): URL prefix for summary statistics location.\n        finngen_summary_stats_url_suffix (str): URL prefix suffix for summary statistics location.\n\n    Returns:\n        FinnGenStudyIndex: Parsed and annotated FinnGen study table.\n    \"\"\"\n    return FinnGenStudyIndex(\n        _df=finngen_studies.select(\n            f.concat(f.lit(f\"{finngen_release_prefix}_\"), f.col(\"phenocode\")).alias(\n                \"studyId\"\n            ),\n            f.col(\"phenostring\").alias(\"traitFromSource\"),\n            f.col(\"num_cases\").alias(\"nCases\"),\n            f.col(\"num_controls\").alias(\"nControls\"),\n            (f.col(\"num_cases\") + f.col(\"num_controls\")).alias(\"nSamples\"),\n            f.lit(finngen_release_prefix).alias(\"projectId\"),\n            f.lit(\"gwas\").alias(\"studyType\"),\n            f.lit(True).alias(\"hasSumstats\"),\n            f.lit(\"377,277 (210,870 females and 166,407 males)\").alias(\n                \"initialSampleSize\"\n            ),\n            f.array(\n                f.struct(\n                    f.lit(377277).cast(\"long\").alias(\"sampleSize\"),\n                    f.lit(\"Finnish\").alias(\"ancestry\"),\n                )\n            ).alias(\"discoverySamples\"),\n            f.concat(\n                f.lit(finngen_summary_stats_url_prefix),\n                f.col(\"phenocode\"),\n                f.lit(finngen_summary_stats_url_suffix),\n            ).alias(\"summarystatsLocation\"),\n        ).withColumn(\n            \"ldPopulationStructure\",\n            cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gnomad/_gnomad/","title":"Gnomad","text":""},{"location":"python_api/datasource/gnomad/gnomad_ld/","title":"Gnomad ld","text":"<p>Importer of LD information from GnomAD.</p> <p>The information comes from LD matrices made available by GnomAD in Hail's native format. We aggregate the LD information across 8 ancestries. The basic steps to generate the LDIndex are:</p> <ol> <li>Convert a LD matrix to a Spark DataFrame.</li> <li>Resolve the matrix indices to variant IDs by lifting over the coordinates to GRCh38.</li> <li>Aggregate the LD information across populations.</li> </ol> Source code in <code>src/otg/datasource/gnomad/ld.py</code> <pre><code>class GnomADLDMatrix:\n    \"\"\"Importer of LD information from GnomAD.\n\n    The information comes from LD matrices [made available by GnomAD](https://gnomad.broadinstitute.org/downloads/#v2-linkage-disequilibrium) in Hail's native format. We aggregate the LD information across 8 ancestries.\n    The basic steps to generate the LDIndex are:\n\n    1. Convert a LD matrix to a Spark DataFrame.\n    2. Resolve the matrix indices to variant IDs by lifting over the coordinates to GRCh38.\n    3. Aggregate the LD information across populations.\n\n    \"\"\"\n\n    @staticmethod\n    def _aggregate_ld_index_across_populations(\n        unaggregated_ld_index: DataFrame,\n    ) -&gt; DataFrame:\n        \"\"\"Aggregate LDIndex across populations.\n\n        Args:\n            unaggregated_ld_index (DataFrame): Unaggregate LDIndex index dataframe  each row is a variant pair in a population\n\n        Returns:\n            DataFrame: Aggregated LDIndex index dataframe  each row is a variant with the LD set across populations\n\n        Examples:\n            &gt;&gt;&gt; data = [(\"1.0\", \"var1\", \"X\", \"var1\", \"pop1\"), (\"1.0\", \"X\", \"var2\", \"var2\", \"pop1\"),\n            ...         (\"0.5\", \"var1\", \"X\", \"var2\", \"pop1\"), (\"0.5\", \"var1\", \"X\", \"var2\", \"pop2\"),\n            ...         (\"0.5\", \"var2\", \"X\", \"var1\", \"pop1\"), (\"0.5\", \"X\", \"var2\", \"var1\", \"pop2\")]\n            &gt;&gt;&gt; df = spark.createDataFrame(data, [\"r\", \"variantId\", \"chromosome\", \"tagvariantId\", \"population\"])\n            &gt;&gt;&gt; GnomADLDMatrix._aggregate_ld_index_across_populations(df).printSchema()\n            root\n             |-- variantId: string (nullable = true)\n             |-- chromosome: string (nullable = true)\n             |-- ldSet: array (nullable = false)\n             |    |-- element: struct (containsNull = false)\n             |    |    |-- tagVariantId: string (nullable = true)\n             |    |    |-- rValues: array (nullable = false)\n             |    |    |    |-- element: struct (containsNull = false)\n             |    |    |    |    |-- population: string (nullable = true)\n             |    |    |    |    |-- r: string (nullable = true)\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        return (\n            unaggregated_ld_index\n            # First level of aggregation: get r/population for each variant/tagVariant pair\n            .withColumn(\"r_pop_struct\", f.struct(\"population\", \"r\"))\n            .groupBy(\"chromosome\", \"variantId\", \"tagVariantId\")\n            .agg(\n                f.collect_set(\"r_pop_struct\").alias(\"rValues\"),\n            )\n            # Second level of aggregation: get r/population for each variant\n            .withColumn(\"r_pop_tag_struct\", f.struct(\"tagVariantId\", \"rValues\"))\n            .groupBy(\"variantId\", \"chromosome\")\n            .agg(\n                f.collect_set(\"r_pop_tag_struct\").alias(\"ldSet\"),\n            )\n        )\n\n    @staticmethod\n    def _convert_ld_matrix_to_table(\n        block_matrix: BlockMatrix, min_r2: float\n    ) -&gt; DataFrame:\n        \"\"\"Convert LD matrix to table.\"\"\"\n        table = block_matrix.entries(keyed=False)\n        return (\n            table.filter(hl.abs(table.entry) &gt;= min_r2**0.5)\n            .to_spark()\n            .withColumnRenamed(\"entry\", \"r\")\n        )\n\n    @staticmethod\n    def _create_ldindex_for_population(\n        population_id: str,\n        ld_matrix_path: str,\n        ld_index_raw_path: str,\n        grch37_to_grch38_chain_path: str,\n        min_r2: float,\n    ) -&gt; DataFrame:\n        \"\"\"Create LDIndex for a specific population.\"\"\"\n        # Prepare LD Block matrix\n        ld_matrix = GnomADLDMatrix._convert_ld_matrix_to_table(\n            BlockMatrix.read(ld_matrix_path), min_r2\n        )\n\n        # Prepare table with variant indices\n        ld_index = GnomADLDMatrix._process_variant_indices(\n            hl.read_table(ld_index_raw_path),\n            grch37_to_grch38_chain_path,\n        )\n\n        return GnomADLDMatrix._resolve_variant_indices(ld_index, ld_matrix).select(\n            \"*\",\n            f.lit(population_id).alias(\"population\"),\n        )\n\n    @staticmethod\n    def _process_variant_indices(\n        ld_index_raw: hl.Table, grch37_to_grch38_chain_path: str\n    ) -&gt; DataFrame:\n        \"\"\"Creates a look up table between variants and their coordinates in the LD Matrix.\n\n        !!! info \"Gnomad's LD Matrix and Index are based on GRCh37 coordinates. This function will lift over the coordinates to GRCh38 to build the lookup table.\"\n\n        Args:\n            ld_index_raw (hl.Table): LD index table from GnomAD\n            grch37_to_grch38_chain_path (str): Path to the chain file used to lift over the coordinates\n\n        Returns:\n            DataFrame: Look up table between variants in build hg38 and their coordinates in the LD Matrix\n        \"\"\"\n        ld_index_38 = _liftover_loci(\n            ld_index_raw, grch37_to_grch38_chain_path, \"GRCh38\"\n        )\n\n        return (\n            ld_index_38.to_spark()\n            # Filter out variants where the liftover failed\n            .filter(f.col(\"`locus_GRCh38.position`\").isNotNull())\n            .withColumn(\n                \"chromosome\", f.regexp_replace(\"`locus_GRCh38.contig`\", \"chr\", \"\")\n            )\n            .withColumn(\n                \"position\",\n                convert_gnomad_position_to_ensembl(\n                    f.col(\"`locus_GRCh38.position`\"),\n                    f.col(\"`alleles`\").getItem(0),\n                    f.col(\"`alleles`\").getItem(1),\n                ),\n            )\n            .select(\n                \"chromosome\",\n                f.concat_ws(\n                    \"_\",\n                    f.col(\"chromosome\"),\n                    f.col(\"position\"),\n                    f.col(\"`alleles`\").getItem(0),\n                    f.col(\"`alleles`\").getItem(1),\n                ).alias(\"variantId\"),\n                f.col(\"idx\"),\n            )\n            # Filter out ambiguous liftover results: multiple indices for the same variant\n            .withColumn(\"count\", f.count(\"*\").over(Window.partitionBy([\"variantId\"])))\n            .filter(f.col(\"count\") == 1)\n            .drop(\"count\")\n        )\n\n    @staticmethod\n    def _resolve_variant_indices(\n        ld_index: DataFrame, ld_matrix: DataFrame\n    ) -&gt; DataFrame:\n        \"\"\"Resolve the `i` and `j` indices of the block matrix to variant IDs (build 38).\"\"\"\n        ld_index_i = ld_index.selectExpr(\n            \"idx as i\", \"variantId as variantId_i\", \"chromosome\"\n        )\n        ld_index_j = ld_index.selectExpr(\"idx as j\", \"variantId as variantId_j\")\n        return (\n            ld_matrix.join(ld_index_i, on=\"i\", how=\"inner\")\n            .join(ld_index_j, on=\"j\", how=\"inner\")\n            .drop(\"i\", \"j\")\n        )\n\n    @staticmethod\n    def _transpose_ld_matrix(ld_matrix: DataFrame) -&gt; DataFrame:\n        \"\"\"Transpose LD matrix to a square matrix format.\n\n        Args:\n            ld_matrix (DataFrame): Triangular LD matrix converted to a Spark DataFrame\n\n        Returns:\n            DataFrame: Square LD matrix without diagonal duplicates\n\n        Examples:\n            &gt;&gt;&gt; df = spark.createDataFrame(\n            ...     [\n            ...         (1, 1, 1.0, \"1\", \"AFR\"),\n            ...         (1, 2, 0.5, \"1\", \"AFR\"),\n            ...         (2, 2, 1.0, \"1\", \"AFR\"),\n            ...     ],\n            ...     [\"variantId_i\", \"variantId_j\", \"r\", \"chromosome\", \"population\"],\n            ... )\n            &gt;&gt;&gt; GnomADLDMatrix._transpose_ld_matrix(df).show()\n            +-----------+-----------+---+----------+----------+\n            |variantId_i|variantId_j|  r|chromosome|population|\n            +-----------+-----------+---+----------+----------+\n            |          1|          2|0.5|         1|       AFR|\n            |          1|          1|1.0|         1|       AFR|\n            |          2|          1|0.5|         1|       AFR|\n            |          2|          2|1.0|         1|       AFR|\n            +-----------+-----------+---+----------+----------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        ld_matrix_transposed = ld_matrix.selectExpr(\n            \"variantId_i as variantId_j\",\n            \"variantId_j as variantId_i\",\n            \"r\",\n            \"chromosome\",\n            \"population\",\n        )\n        return ld_matrix.filter(\n            f.col(\"variantId_i\") != f.col(\"variantId_j\")\n        ).unionByName(ld_matrix_transposed)\n\n    @classmethod\n    def as_ld_index(\n        cls: type[GnomADLDMatrix],\n        ld_populations: list[str],\n        ld_matrix_template: str,\n        ld_index_raw_template: str,\n        grch37_to_grch38_chain_path: str,\n        min_r2: float,\n    ) -&gt; LDIndex:\n        \"\"\"Create LDIndex dataset aggregating the LD information across a set of populations.\"\"\"\n        ld_indices_unaggregated = []\n        for pop in ld_populations:\n            try:\n                ld_matrix_path = ld_matrix_template.format(POP=pop)\n                ld_index_raw_path = ld_index_raw_template.format(POP=pop)\n                pop_ld_index = cls._create_ldindex_for_population(\n                    pop,\n                    ld_matrix_path,\n                    ld_index_raw_path.format(pop),\n                    grch37_to_grch38_chain_path,\n                    min_r2,\n                )\n                ld_indices_unaggregated.append(pop_ld_index)\n            except Exception as e:\n                print(f\"Failed to create LDIndex for population {pop}: {e}\")\n                sys.exit(1)\n\n        ld_index_unaggregated = (\n            GnomADLDMatrix._transpose_ld_matrix(\n                reduce(lambda df1, df2: df1.unionByName(df2), ld_indices_unaggregated)\n            )\n            .withColumnRenamed(\"variantId_i\", \"variantId\")\n            .withColumnRenamed(\"variantId_j\", \"tagVariantId\")\n        )\n        return LDIndex(\n            _df=cls._aggregate_ld_index_across_populations(ld_index_unaggregated),\n            _schema=LDIndex.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_ld/#otg.datasource.gnomad.ld.GnomADLDMatrix.as_ld_index","title":"<code>as_ld_index(ld_populations, ld_matrix_template, ld_index_raw_template, grch37_to_grch38_chain_path, min_r2)</code>  <code>classmethod</code>","text":"<p>Create LDIndex dataset aggregating the LD information across a set of populations.</p> Source code in <code>src/otg/datasource/gnomad/ld.py</code> <pre><code>@classmethod\ndef as_ld_index(\n    cls: type[GnomADLDMatrix],\n    ld_populations: list[str],\n    ld_matrix_template: str,\n    ld_index_raw_template: str,\n    grch37_to_grch38_chain_path: str,\n    min_r2: float,\n) -&gt; LDIndex:\n    \"\"\"Create LDIndex dataset aggregating the LD information across a set of populations.\"\"\"\n    ld_indices_unaggregated = []\n    for pop in ld_populations:\n        try:\n            ld_matrix_path = ld_matrix_template.format(POP=pop)\n            ld_index_raw_path = ld_index_raw_template.format(POP=pop)\n            pop_ld_index = cls._create_ldindex_for_population(\n                pop,\n                ld_matrix_path,\n                ld_index_raw_path.format(pop),\n                grch37_to_grch38_chain_path,\n                min_r2,\n            )\n            ld_indices_unaggregated.append(pop_ld_index)\n        except Exception as e:\n            print(f\"Failed to create LDIndex for population {pop}: {e}\")\n            sys.exit(1)\n\n    ld_index_unaggregated = (\n        GnomADLDMatrix._transpose_ld_matrix(\n            reduce(lambda df1, df2: df1.unionByName(df2), ld_indices_unaggregated)\n        )\n        .withColumnRenamed(\"variantId_i\", \"variantId\")\n        .withColumnRenamed(\"variantId_j\", \"tagVariantId\")\n    )\n    return LDIndex(\n        _df=cls._aggregate_ld_index_across_populations(ld_index_unaggregated),\n        _schema=LDIndex.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_variants/","title":"Gnomad variants","text":"<p>GnomAD variants included in the GnomAD genomes dataset.</p> Source code in <code>src/otg/datasource/gnomad/variants.py</code> <pre><code>class GnomADVariants:\n    \"\"\"GnomAD variants included in the GnomAD genomes dataset.\"\"\"\n\n    @staticmethod\n    def _convert_gnomad_position_to_ensembl_hail(\n        position: Int32Expression,\n        reference: StringExpression,\n        alternate: StringExpression,\n    ) -&gt; Int32Expression:\n        \"\"\"Convert GnomAD variant position to Ensembl variant position in hail table.\n\n        For indels (the reference or alternate allele is longer than 1), then adding 1 to the position, for SNPs, the position is unchanged.\n        More info about the problem: https://www.biostars.org/p/84686/\n\n        Args:\n            position (Int32Expression): Position of the variant in the GnomAD genome.\n            reference (StringExpression): The reference allele.\n            alternate (StringExpression): The alternate allele\n\n        Returns:\n            The position of the variant according to Ensembl genome.\n        \"\"\"\n        return hl.if_else(\n            (reference.length() &gt; 1) | (alternate.length() &gt; 1), position + 1, position\n        )\n\n    @classmethod\n    def as_variant_annotation(\n        cls: type[GnomADVariants],\n        gnomad_file: str,\n        grch38_to_grch37_chain: str,\n        populations: list,\n    ) -&gt; VariantAnnotation:\n        \"\"\"Generate variant annotation dataset from gnomAD.\n\n        Some relevant modifications to the original dataset are:\n\n        1. The transcript consequences features provided by VEP are filtered to only refer to the Ensembl canonical transcript.\n        2. Genome coordinates are liftovered from GRCh38 to GRCh37 to keep as annotation.\n        3. Field names are converted to camel case to follow the convention.\n\n        Args:\n            gnomad_file (str): Path to `gnomad.genomes.vX.X.X.sites.ht` gnomAD dataset\n            grch38_to_grch37_chain (str): Path to chain file for liftover\n            populations (list): List of populations to include in the dataset\n\n        Returns:\n            VariantAnnotation: Variant annotation dataset\n        \"\"\"\n        # Load variants dataset\n        ht = hl.read_table(\n            gnomad_file,\n            _load_refs=False,\n        )\n\n        # Liftover\n        grch37 = hl.get_reference(\"GRCh37\")\n        grch38 = hl.get_reference(\"GRCh38\")\n        grch38.add_liftover(grch38_to_grch37_chain, grch37)\n\n        # Drop non biallelic variants\n        ht = ht.filter(ht.alleles.length() == 2)\n        # Liftover\n        ht = ht.annotate(locus_GRCh37=hl.liftover(ht.locus, \"GRCh37\"))\n        # Select relevant fields and nested records to create class\n        return VariantAnnotation(\n            _df=(\n                ht.select(\n                    gnomad3VariantId=hl.str(\"-\").join(\n                        [\n                            ht.locus.contig.replace(\"chr\", \"\"),\n                            hl.str(ht.locus.position),\n                            ht.alleles[0],\n                            ht.alleles[1],\n                        ]\n                    ),\n                    chromosome=ht.locus.contig.replace(\"chr\", \"\"),\n                    position=GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                        ht.locus.position, ht.alleles[0], ht.alleles[1]\n                    ),\n                    variantId=hl.str(\"_\").join(\n                        [\n                            ht.locus.contig.replace(\"chr\", \"\"),\n                            hl.str(\n                                GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                                    ht.locus.position, ht.alleles[0], ht.alleles[1]\n                                )\n                            ),\n                            ht.alleles[0],\n                            ht.alleles[1],\n                        ]\n                    ),\n                    chromosomeB37=ht.locus_GRCh37.contig.replace(\"chr\", \"\"),\n                    positionB37=ht.locus_GRCh37.position,\n                    referenceAllele=ht.alleles[0],\n                    alternateAllele=ht.alleles[1],\n                    rsIds=ht.rsid,\n                    alleleType=ht.allele_info.allele_type,\n                    cadd=hl.struct(\n                        phred=ht.cadd.phred,\n                        raw=ht.cadd.raw_score,\n                    ),\n                    alleleFrequencies=hl.set([f\"{pop}-adj\" for pop in populations]).map(\n                        lambda p: hl.struct(\n                            populationName=p,\n                            alleleFrequency=ht.freq[ht.globals.freq_index_dict[p]].AF,\n                        )\n                    ),\n                    vep=hl.struct(\n                        mostSevereConsequence=ht.vep.most_severe_consequence,\n                        transcriptConsequences=hl.map(\n                            lambda x: hl.struct(\n                                aminoAcids=x.amino_acids,\n                                consequenceTerms=x.consequence_terms,\n                                geneId=x.gene_id,\n                                lof=x.lof,\n                                polyphenScore=x.polyphen_score,\n                                polyphenPrediction=x.polyphen_prediction,\n                                siftScore=x.sift_score,\n                                siftPrediction=x.sift_prediction,\n                            ),\n                            # Only keeping canonical transcripts\n                            ht.vep.transcript_consequences.filter(\n                                lambda x: (x.canonical == 1)\n                                &amp; (x.gene_symbol_source == \"HGNC\")\n                            ),\n                        ),\n                    ),\n                )\n                .key_by(\"chromosome\", \"position\")\n                .drop(\"locus\", \"alleles\")\n                .select_globals()\n                .to_spark(flatten=False)\n            ),\n            _schema=VariantAnnotation.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/gnomad/gnomad_variants/#otg.datasource.gnomad.variants.GnomADVariants.as_variant_annotation","title":"<code>as_variant_annotation(gnomad_file, grch38_to_grch37_chain, populations)</code>  <code>classmethod</code>","text":"<p>Generate variant annotation dataset from gnomAD.</p> <p>Some relevant modifications to the original dataset are:</p> <ol> <li>The transcript consequences features provided by VEP are filtered to only refer to the Ensembl canonical transcript.</li> <li>Genome coordinates are liftovered from GRCh38 to GRCh37 to keep as annotation.</li> <li>Field names are converted to camel case to follow the convention.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>gnomad_file</code> <code>str</code> <p>Path to <code>gnomad.genomes.vX.X.X.sites.ht</code> gnomAD dataset</p> required <code>grch38_to_grch37_chain</code> <code>str</code> <p>Path to chain file for liftover</p> required <code>populations</code> <code>list</code> <p>List of populations to include in the dataset</p> required <p>Returns:</p> Name Type Description <code>VariantAnnotation</code> <code>VariantAnnotation</code> <p>Variant annotation dataset</p> Source code in <code>src/otg/datasource/gnomad/variants.py</code> <pre><code>@classmethod\ndef as_variant_annotation(\n    cls: type[GnomADVariants],\n    gnomad_file: str,\n    grch38_to_grch37_chain: str,\n    populations: list,\n) -&gt; VariantAnnotation:\n    \"\"\"Generate variant annotation dataset from gnomAD.\n\n    Some relevant modifications to the original dataset are:\n\n    1. The transcript consequences features provided by VEP are filtered to only refer to the Ensembl canonical transcript.\n    2. Genome coordinates are liftovered from GRCh38 to GRCh37 to keep as annotation.\n    3. Field names are converted to camel case to follow the convention.\n\n    Args:\n        gnomad_file (str): Path to `gnomad.genomes.vX.X.X.sites.ht` gnomAD dataset\n        grch38_to_grch37_chain (str): Path to chain file for liftover\n        populations (list): List of populations to include in the dataset\n\n    Returns:\n        VariantAnnotation: Variant annotation dataset\n    \"\"\"\n    # Load variants dataset\n    ht = hl.read_table(\n        gnomad_file,\n        _load_refs=False,\n    )\n\n    # Liftover\n    grch37 = hl.get_reference(\"GRCh37\")\n    grch38 = hl.get_reference(\"GRCh38\")\n    grch38.add_liftover(grch38_to_grch37_chain, grch37)\n\n    # Drop non biallelic variants\n    ht = ht.filter(ht.alleles.length() == 2)\n    # Liftover\n    ht = ht.annotate(locus_GRCh37=hl.liftover(ht.locus, \"GRCh37\"))\n    # Select relevant fields and nested records to create class\n    return VariantAnnotation(\n        _df=(\n            ht.select(\n                gnomad3VariantId=hl.str(\"-\").join(\n                    [\n                        ht.locus.contig.replace(\"chr\", \"\"),\n                        hl.str(ht.locus.position),\n                        ht.alleles[0],\n                        ht.alleles[1],\n                    ]\n                ),\n                chromosome=ht.locus.contig.replace(\"chr\", \"\"),\n                position=GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                    ht.locus.position, ht.alleles[0], ht.alleles[1]\n                ),\n                variantId=hl.str(\"_\").join(\n                    [\n                        ht.locus.contig.replace(\"chr\", \"\"),\n                        hl.str(\n                            GnomADVariants._convert_gnomad_position_to_ensembl_hail(\n                                ht.locus.position, ht.alleles[0], ht.alleles[1]\n                            )\n                        ),\n                        ht.alleles[0],\n                        ht.alleles[1],\n                    ]\n                ),\n                chromosomeB37=ht.locus_GRCh37.contig.replace(\"chr\", \"\"),\n                positionB37=ht.locus_GRCh37.position,\n                referenceAllele=ht.alleles[0],\n                alternateAllele=ht.alleles[1],\n                rsIds=ht.rsid,\n                alleleType=ht.allele_info.allele_type,\n                cadd=hl.struct(\n                    phred=ht.cadd.phred,\n                    raw=ht.cadd.raw_score,\n                ),\n                alleleFrequencies=hl.set([f\"{pop}-adj\" for pop in populations]).map(\n                    lambda p: hl.struct(\n                        populationName=p,\n                        alleleFrequency=ht.freq[ht.globals.freq_index_dict[p]].AF,\n                    )\n                ),\n                vep=hl.struct(\n                    mostSevereConsequence=ht.vep.most_severe_consequence,\n                    transcriptConsequences=hl.map(\n                        lambda x: hl.struct(\n                            aminoAcids=x.amino_acids,\n                            consequenceTerms=x.consequence_terms,\n                            geneId=x.gene_id,\n                            lof=x.lof,\n                            polyphenScore=x.polyphen_score,\n                            polyphenPrediction=x.polyphen_prediction,\n                            siftScore=x.sift_score,\n                            siftPrediction=x.sift_prediction,\n                        ),\n                        # Only keeping canonical transcripts\n                        ht.vep.transcript_consequences.filter(\n                            lambda x: (x.canonical == 1)\n                            &amp; (x.gene_symbol_source == \"HGNC\")\n                        ),\n                    ),\n                ),\n            )\n            .key_by(\"chromosome\", \"position\")\n            .drop(\"locus\", \"alleles\")\n            .select_globals()\n            .to_spark(flatten=False)\n        ),\n        _schema=VariantAnnotation.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/_gwas_catalog/","title":"Gwas catalog","text":"GWAS Catalog"},{"location":"python_api/datasource/gwas_catalog/associations/","title":"Associations","text":"<p>             Bases: <code>StudyLocus</code></p> <p>Study-locus dataset derived from GWAS Catalog.</p> Source code in <code>src/otg/datasource/gwas_catalog/associations.py</code> <pre><code>@dataclass\nclass GWASCatalogAssociations(StudyLocus):\n    \"\"\"Study-locus dataset derived from GWAS Catalog.\"\"\"\n\n    @staticmethod\n    def _parse_pvalue(pvalue: Column) -&gt; tuple[Column, Column]:\n        \"\"\"Parse p-value column.\n\n        Args:\n            pvalue (Column): p-value [string]\n\n        Returns:\n            tuple[Column, Column]: p-value mantissa and exponent\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [(\"1.0\"), (\"0.5\"), (\"1E-20\"), (\"3E-3\"), (\"1E-1000\")]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StringType())\n            &gt;&gt;&gt; df.select('value',*GWASCatalogAssociations._parse_pvalue(f.col('value'))).show()\n            +-------+--------------+--------------+\n            |  value|pValueMantissa|pValueExponent|\n            +-------+--------------+--------------+\n            |    1.0|           1.0|             1|\n            |    0.5|           0.5|             1|\n            |  1E-20|           1.0|           -20|\n            |   3E-3|           3.0|            -3|\n            |1E-1000|           1.0|         -1000|\n            +-------+--------------+--------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        split = f.split(pvalue, \"E\")\n        return split.getItem(0).cast(\"float\").alias(\"pValueMantissa\"), f.coalesce(\n            split.getItem(1).cast(\"integer\"), f.lit(1)\n        ).alias(\"pValueExponent\")\n\n    @staticmethod\n    def _normalise_pvaluetext(p_value_text: Column) -&gt; Column:\n        \"\"\"Normalised p-value text column to a standardised format.\n\n        For cases where there is no mapping, the value is set to null.\n\n        Args:\n            p_value_text (Column): `pValueText` column from GWASCatalog\n\n        Returns:\n            Column: Array column after using GWAS Catalog mappings. There might be multiple mappings for a single p-value text.\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [(\"European Ancestry\"), (\"African ancestry\"), (\"Alzheimer\u2019s Disease\"), (\"(progression)\"), (\"\"), (None)]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StringType())\n            &gt;&gt;&gt; df.withColumn('normalised', GWASCatalogAssociations._normalise_pvaluetext(f.col('value'))).show()\n            +-------------------+----------+\n            |              value|normalised|\n            +-------------------+----------+\n            |  European Ancestry|      [EA]|\n            |   African ancestry|      [AA]|\n            |Alzheimer\u2019s Disease|      [AD]|\n            |      (progression)|      null|\n            |                   |      null|\n            |               null|      null|\n            +-------------------+----------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # GWAS Catalog to p-value mapping\n        json_dict = json.loads(\n            pkg_resources.read_text(data, \"gwas_pValueText_map.json\", encoding=\"utf-8\")\n        )\n        map_expr = f.create_map(*[f.lit(x) for x in chain(*json_dict.items())])\n\n        splitted_col = f.split(f.regexp_replace(p_value_text, r\"[\\(\\)]\", \"\"), \",\")\n        mapped_col = f.transform(splitted_col, lambda x: map_expr[x])\n        return f.when(f.forall(mapped_col, lambda x: x.isNull()), None).otherwise(\n            mapped_col\n        )\n\n    @staticmethod\n    def _normalise_risk_allele(risk_allele: Column) -&gt; Column:\n        \"\"\"Normalised risk allele column to a standardised format.\n\n        If multiple risk alleles are present, the first one is returned.\n\n        Args:\n            risk_allele (Column): `riskAllele` column from GWASCatalog\n\n        Returns:\n            Column: mapped using GWAS Catalog mapping\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [(\"rs1234-A-G\"), (\"rs1234-A\"), (\"rs1234-A; rs1235-G\")]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StringType())\n            &gt;&gt;&gt; df.withColumn('normalised', GWASCatalogAssociations._normalise_risk_allele(f.col('value'))).show()\n            +------------------+----------+\n            |             value|normalised|\n            +------------------+----------+\n            |        rs1234-A-G|         A|\n            |          rs1234-A|         A|\n            |rs1234-A; rs1235-G|         A|\n            +------------------+----------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # GWAS Catalog to risk allele mapping\n        return f.split(f.split(risk_allele, \"; \").getItem(0), \"-\").getItem(1)\n\n    @staticmethod\n    def _collect_rsids(\n        snp_id: Column, snp_id_current: Column, risk_allele: Column\n    ) -&gt; Column:\n        \"\"\"It takes three columns, and returns an array of distinct values from those columns.\n\n        Args:\n            snp_id (Column): The original snp id from the GWAS catalog.\n            snp_id_current (Column): The current snp id field is just a number at the moment (stored as a string). Adding 'rs' prefix if looks good.\n            risk_allele (Column): The risk allele for the SNP.\n\n        Returns:\n            An array of distinct values.\n        \"\"\"\n        # The current snp id field is just a number at the moment (stored as a string). Adding 'rs' prefix if looks good.\n        snp_id_current = f.when(\n            snp_id_current.rlike(\"^[0-9]*$\"),\n            f.format_string(\"rs%s\", snp_id_current),\n        )\n        # Cleaning risk allele:\n        risk_allele = f.split(risk_allele, \"-\").getItem(0)\n\n        # Collecting all values:\n        return f.array_distinct(f.array(snp_id, snp_id_current, risk_allele))\n\n    @staticmethod\n    def _map_to_variant_annotation_variants(\n        gwas_associations: DataFrame, variant_annotation: VariantAnnotation\n    ) -&gt; DataFrame:\n        \"\"\"Add variant metadata in associations.\n\n        Args:\n            gwas_associations (DataFrame): raw GWAS Catalog associations\n            variant_annotation (VariantAnnotation): variant annotation dataset\n\n        Returns:\n            DataFrame: GWAS Catalog associations data including `variantId`, `referenceAllele`,\n            `alternateAllele`, `chromosome`, `position` with variant metadata\n        \"\"\"\n        # Subset of GWAS Catalog associations required for resolving variant IDs:\n        gwas_associations_subset = gwas_associations.select(\n            \"studyLocusId\",\n            f.col(\"CHR_ID\").alias(\"chromosome\"),\n            f.col(\"CHR_POS\").cast(IntegerType()).alias(\"position\"),\n            # List of all SNPs associated with the variant\n            GWASCatalogAssociations._collect_rsids(\n                f.split(f.col(\"SNPS\"), \"; \").getItem(0),\n                f.col(\"SNP_ID_CURRENT\"),\n                f.split(f.col(\"STRONGEST SNP-RISK ALLELE\"), \"; \").getItem(0),\n            ).alias(\"rsIdsGwasCatalog\"),\n            GWASCatalogAssociations._normalise_risk_allele(\n                f.col(\"STRONGEST SNP-RISK ALLELE\")\n            ).alias(\"riskAllele\"),\n        )\n\n        # Subset of variant annotation required for GWAS Catalog annotations:\n        va_subset = variant_annotation.df.select(\n            \"variantId\",\n            \"chromosome\",\n            \"position\",\n            f.col(\"rsIds\").alias(\"rsIdsGnomad\"),\n            \"referenceAllele\",\n            \"alternateAllele\",\n            \"alleleFrequencies\",\n            variant_annotation.max_maf().alias(\"maxMaf\"),\n        ).join(\n            f.broadcast(\n                gwas_associations_subset.select(\"chromosome\", \"position\").distinct()\n            ),\n            on=[\"chromosome\", \"position\"],\n            how=\"inner\",\n        )\n\n        # Semi-resolved ids (still contains duplicates when conclusion was not possible to make\n        # based on rsIds or allele concordance)\n        filtered_associations = (\n            gwas_associations_subset.join(\n                f.broadcast(va_subset),\n                on=[\"chromosome\", \"position\"],\n                how=\"left\",\n            )\n            .withColumn(\n                \"rsIdFilter\",\n                GWASCatalogAssociations._flag_mappings_to_retain(\n                    f.col(\"studyLocusId\"),\n                    GWASCatalogAssociations._compare_rsids(\n                        f.col(\"rsIdsGnomad\"), f.col(\"rsIdsGwasCatalog\")\n                    ),\n                ),\n            )\n            .withColumn(\n                \"concordanceFilter\",\n                GWASCatalogAssociations._flag_mappings_to_retain(\n                    f.col(\"studyLocusId\"),\n                    GWASCatalogAssociations._check_concordance(\n                        f.col(\"riskAllele\"),\n                        f.col(\"referenceAllele\"),\n                        f.col(\"alternateAllele\"),\n                    ),\n                ),\n            )\n            .filter(\n                # Filter out rows where GWAS Catalog rsId does not match with GnomAD rsId,\n                # but there is corresponding variant for the same association\n                f.col(\"rsIdFilter\")\n                # or filter out rows where GWAS Catalog alleles are not concordant with GnomAD alleles,\n                # but there is corresponding variant for the same association\n                | f.col(\"concordanceFilter\")\n            )\n        )\n\n        # Keep only highest maxMaf variant per studyLocusId\n        fully_mapped_associations = get_record_with_maximum_value(\n            filtered_associations, grouping_col=\"studyLocusId\", sorting_col=\"maxMaf\"\n        ).select(\n            \"studyLocusId\",\n            \"variantId\",\n            \"referenceAllele\",\n            \"alternateAllele\",\n            \"chromosome\",\n            \"position\",\n        )\n\n        return gwas_associations.join(\n            fully_mapped_associations, on=\"studyLocusId\", how=\"left\"\n        )\n\n    @staticmethod\n    def _compare_rsids(gnomad: Column, gwas: Column) -&gt; Column:\n        \"\"\"If the intersection of the two arrays is greater than 0, return True, otherwise return False.\n\n        Args:\n            gnomad (Column): rsids from gnomad\n            gwas (Column): rsids from the GWAS Catalog\n\n        Returns:\n            A boolean column that is true if the GnomAD rsIDs can be found in the GWAS rsIDs.\n\n        Examples:\n            &gt;&gt;&gt; d = [\n            ...    (1, [\"rs123\", \"rs523\"], [\"rs123\"]),\n            ...    (2, [], [\"rs123\"]),\n            ...    (3, [\"rs123\", \"rs523\"], []),\n            ...    (4, [], []),\n            ... ]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, ['associationId', 'gnomad', 'gwas'])\n            &gt;&gt;&gt; df.withColumn(\"rsid_matches\", GWASCatalogAssociations._compare_rsids(f.col(\"gnomad\"),f.col('gwas'))).show()\n            +-------------+--------------+-------+------------+\n            |associationId|        gnomad|   gwas|rsid_matches|\n            +-------------+--------------+-------+------------+\n            |            1|[rs123, rs523]|[rs123]|        true|\n            |            2|            []|[rs123]|       false|\n            |            3|[rs123, rs523]|     []|       false|\n            |            4|            []|     []|       false|\n            +-------------+--------------+-------+------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return f.when(f.size(f.array_intersect(gnomad, gwas)) &gt; 0, True).otherwise(\n            False\n        )\n\n    @staticmethod\n    def _flag_mappings_to_retain(\n        association_id: Column, filter_column: Column\n    ) -&gt; Column:\n        \"\"\"Flagging mappings to drop for each association.\n\n        Some associations have multiple mappings. Some has matching rsId others don't. We only\n        want to drop the non-matching mappings, when a matching is available for the given association.\n        This logic can be generalised for other measures eg. allele concordance.\n\n        Args:\n            association_id (Column): association identifier column\n            filter_column (Column): boolean col indicating to keep a mapping\n\n        Returns:\n            A column with a boolean value.\n\n        Examples:\n        &gt;&gt;&gt; d = [\n        ...    (1, False),\n        ...    (1, False),\n        ...    (2, False),\n        ...    (2, True),\n        ...    (3, True),\n        ...    (3, True),\n        ... ]\n        &gt;&gt;&gt; df = spark.createDataFrame(d, ['associationId', 'filter'])\n        &gt;&gt;&gt; df.withColumn(\"isConcordant\", GWASCatalogAssociations._flag_mappings_to_retain(f.col(\"associationId\"),f.col('filter'))).show()\n        +-------------+------+------------+\n        |associationId|filter|isConcordant|\n        +-------------+------+------------+\n        |            1| false|        true|\n        |            1| false|        true|\n        |            2| false|       false|\n        |            2|  true|        true|\n        |            3|  true|        true|\n        |            3|  true|        true|\n        +-------------+------+------------+\n        &lt;BLANKLINE&gt;\n\n        \"\"\"\n        w = Window.partitionBy(association_id)\n\n        # Generating a boolean column informing if the filter column contains true anywhere for the association:\n        aggregated_filter = f.when(\n            f.array_contains(f.collect_set(filter_column).over(w), True), True\n        ).otherwise(False)\n\n        # Generate a filter column:\n        return f.when(aggregated_filter &amp; (~filter_column), False).otherwise(True)\n\n    @staticmethod\n    def _check_concordance(\n        risk_allele: Column, reference_allele: Column, alternate_allele: Column\n    ) -&gt; Column:\n        \"\"\"A function to check if the risk allele is concordant with the alt or ref allele.\n\n        If the risk allele is the same as the reference or alternate allele, or if the reverse complement of\n        the risk allele is the same as the reference or alternate allele, then the allele is concordant.\n        If no mapping is available (ref/alt is null), the function returns True.\n\n        Args:\n            risk_allele (Column): The allele that is associated with the risk of the disease.\n            reference_allele (Column): The reference allele from the GWAS catalog\n            alternate_allele (Column): The alternate allele of the variant.\n\n        Returns:\n            A boolean column that is True if the risk allele is the same as the reference or alternate allele,\n            or if the reverse complement of the risk allele is the same as the reference or alternate allele.\n\n        Examples:\n            &gt;&gt;&gt; d = [\n            ...     ('A', 'A', 'G'),\n            ...     ('A', 'T', 'G'),\n            ...     ('A', 'C', 'G'),\n            ...     ('A', 'A', '?'),\n            ...     (None, None, 'A'),\n            ... ]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, ['riskAllele', 'referenceAllele', 'alternateAllele'])\n            &gt;&gt;&gt; df.withColumn(\"isConcordant\", GWASCatalogAssociations._check_concordance(f.col(\"riskAllele\"),f.col('referenceAllele'), f.col('alternateAllele'))).show()\n            +----------+---------------+---------------+------------+\n            |riskAllele|referenceAllele|alternateAllele|isConcordant|\n            +----------+---------------+---------------+------------+\n            |         A|              A|              G|        true|\n            |         A|              T|              G|        true|\n            |         A|              C|              G|       false|\n            |         A|              A|              ?|        true|\n            |      null|           null|              A|        true|\n            +----------+---------------+---------------+------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # Calculating the reverse complement of the risk allele:\n        risk_allele_reverse_complement = f.when(\n            risk_allele.rlike(r\"^[ACTG]+$\"),\n            f.reverse(f.translate(risk_allele, \"ACTG\", \"TGAC\")),\n        ).otherwise(risk_allele)\n\n        # OK, is the risk allele or the reverse complent is the same as the mapped alleles:\n        return (\n            f.when(\n                (risk_allele == reference_allele) | (risk_allele == alternate_allele),\n                True,\n            )\n            # If risk allele is found on the negative strand:\n            .when(\n                (risk_allele_reverse_complement == reference_allele)\n                | (risk_allele_reverse_complement == alternate_allele),\n                True,\n            )\n            # If risk allele is ambiguous, still accepted: &lt; This condition could be reconsidered\n            .when(risk_allele == \"?\", True)\n            # If the association could not be mapped we keep it:\n            .when(reference_allele.isNull(), True)\n            # Allele is discordant:\n            .otherwise(False)\n        )\n\n    @staticmethod\n    def _get_reverse_complement(allele_col: Column) -&gt; Column:\n        \"\"\"A function to return the reverse complement of an allele column.\n\n        It takes a string and returns the reverse complement of that string if it's a DNA sequence,\n        otherwise it returns the original string. Assumes alleles in upper case.\n\n        Args:\n            allele_col (Column): The column containing the allele to reverse complement.\n\n        Returns:\n            A column that is the reverse complement of the allele column.\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"allele\": 'A'}, {\"allele\": 'T'},{\"allele\": 'G'}, {\"allele\": 'C'},{\"allele\": 'AC'}, {\"allele\": 'GTaatc'},{\"allele\": '?'}, {\"allele\": None}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"revcom_allele\", GWASCatalogAssociations._get_reverse_complement(f.col(\"allele\"))).show()\n            +------+-------------+\n            |allele|revcom_allele|\n            +------+-------------+\n            |     A|            T|\n            |     T|            A|\n            |     G|            C|\n            |     C|            G|\n            |    AC|           GT|\n            |GTaatc|       GATTAC|\n            |     ?|            ?|\n            |  null|         null|\n            +------+-------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        allele_col = f.upper(allele_col)\n        return f.when(\n            allele_col.rlike(\"[ACTG]+\"),\n            f.reverse(f.translate(allele_col, \"ACTG\", \"TGAC\")),\n        ).otherwise(allele_col)\n\n    @staticmethod\n    def _effect_needs_harmonisation(\n        risk_allele: Column, reference_allele: Column\n    ) -&gt; Column:\n        \"\"\"A function to check if the effect allele needs to be harmonised.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Effect allele column\n\n        Returns:\n            A boolean column indicating if the effect allele needs to be harmonised.\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"risk\": 'A', \"reference\": 'A'}, {\"risk\": 'A', \"reference\": 'T'}, {\"risk\": 'AT', \"reference\": 'TA'}, {\"risk\": 'AT', \"reference\": 'AT'}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"needs_harmonisation\", GWASCatalogAssociations._effect_needs_harmonisation(f.col(\"risk\"), f.col(\"reference\"))).show()\n            +---------+----+-------------------+\n            |reference|risk|needs_harmonisation|\n            +---------+----+-------------------+\n            |        A|   A|               true|\n            |        T|   A|               true|\n            |       TA|  AT|              false|\n            |       AT|  AT|               true|\n            +---------+----+-------------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return (risk_allele == reference_allele) | (\n            risk_allele\n            == GWASCatalogAssociations._get_reverse_complement(reference_allele)\n        )\n\n    @staticmethod\n    def _are_alleles_palindromic(\n        reference_allele: Column, alternate_allele: Column\n    ) -&gt; Column:\n        \"\"\"A function to check if the alleles are palindromic.\n\n        Args:\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n\n        Returns:\n            A boolean column indicating if the alleles are palindromic.\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"reference\": 'A', \"alternate\": 'T'}, {\"reference\": 'AT', \"alternate\": 'AG'}, {\"reference\": 'AT', \"alternate\": 'AT'}, {\"reference\": 'CATATG', \"alternate\": 'CATATG'}, {\"reference\": '-', \"alternate\": None}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"is_palindromic\", GWASCatalogAssociations._are_alleles_palindromic(f.col(\"reference\"), f.col(\"alternate\"))).show()\n            +---------+---------+--------------+\n            |alternate|reference|is_palindromic|\n            +---------+---------+--------------+\n            |        T|        A|          true|\n            |       AG|       AT|         false|\n            |       AT|       AT|          true|\n            |   CATATG|   CATATG|          true|\n            |     null|        -|         false|\n            +---------+---------+--------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        revcomp = GWASCatalogAssociations._get_reverse_complement(alternate_allele)\n        return (\n            f.when(reference_allele == revcomp, True)\n            .when(revcomp.isNull(), False)\n            .otherwise(False)\n        )\n\n    @staticmethod\n    def _harmonise_beta(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n    ) -&gt; Column:\n        \"\"\"A function to extract the beta value from the effect size and confidence interval.\n\n        If the confidence interval contains the word \"increase\" or \"decrease\" it indicates, we are dealing with betas.\n        If it's \"increase\" and the effect size needs to be harmonized, then multiply the effect size by -1\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n\n        Returns:\n            A column containing the beta value.\n        \"\"\"\n        return (\n            f.when(\n                GWASCatalogAssociations._are_alleles_palindromic(\n                    reference_allele, alternate_allele\n                ),\n                None,\n            )\n            .when(\n                (\n                    GWASCatalogAssociations._effect_needs_harmonisation(\n                        risk_allele, reference_allele\n                    )\n                    &amp; confidence_interval.contains(\"increase\")\n                )\n                | (\n                    ~GWASCatalogAssociations._effect_needs_harmonisation(\n                        risk_allele, reference_allele\n                    )\n                    &amp; confidence_interval.contains(\"decrease\")\n                ),\n                -effect_size,\n            )\n            .otherwise(effect_size)\n            .cast(DoubleType())\n        )\n\n    @staticmethod\n    def _harmonise_beta_ci(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n        p_value: Column,\n        direction: str,\n    ) -&gt; Column:\n        \"\"\"Calculating confidence intervals for beta values.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n            p_value (Column): GWAS Catalog p-value column\n            direction (str): This is the direction of the confidence interval. It can be either \"upper\" or \"lower\".\n\n        Returns:\n            The upper and lower bounds of the confidence interval for the beta coefficient.\n        \"\"\"\n        zscore_95 = f.lit(1.96)\n        beta = GWASCatalogAssociations._harmonise_beta(\n            risk_allele,\n            reference_allele,\n            alternate_allele,\n            effect_size,\n            confidence_interval,\n        )\n        zscore = pvalue_to_zscore(p_value)\n        return (\n            f.when(f.lit(direction) == \"upper\", beta + f.abs(zscore_95 * beta) / zscore)\n            .when(f.lit(direction) == \"lower\", beta - f.abs(zscore_95 * beta) / zscore)\n            .otherwise(None)\n        )\n\n    @staticmethod\n    def _harmonise_odds_ratio(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n    ) -&gt; Column:\n        \"\"\"Harmonizing odds ratio.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n\n        Returns:\n            A column with the odds ratio, or 1/odds_ratio if harmonization required.\n        \"\"\"\n        return (\n            f.when(\n                GWASCatalogAssociations._are_alleles_palindromic(\n                    reference_allele, alternate_allele\n                ),\n                None,\n            )\n            .when(\n                (\n                    GWASCatalogAssociations._effect_needs_harmonisation(\n                        risk_allele, reference_allele\n                    )\n                    &amp; ~confidence_interval.rlike(\"|\".join([\"decrease\", \"increase\"]))\n                ),\n                1 / effect_size,\n            )\n            .otherwise(effect_size)\n            .cast(DoubleType())\n        )\n\n    @staticmethod\n    def _harmonise_odds_ratio_ci(\n        risk_allele: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        effect_size: Column,\n        confidence_interval: Column,\n        p_value: Column,\n        direction: str,\n    ) -&gt; Column:\n        \"\"\"Calculating confidence intervals for beta values.\n\n        Args:\n            risk_allele (Column): Risk allele column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            effect_size (Column): GWAS Catalog effect size column\n            confidence_interval (Column): GWAS Catalog confidence interval column\n            p_value (Column): GWAS Catalog p-value column\n            direction (str): This is the direction of the confidence interval. It can be either \"upper\" or \"lower\".\n\n        Returns:\n            The upper and lower bounds of the 95% confidence interval for the odds ratio.\n        \"\"\"\n        zscore_95 = f.lit(1.96)\n        odds_ratio = GWASCatalogAssociations._harmonise_odds_ratio(\n            risk_allele,\n            reference_allele,\n            alternate_allele,\n            effect_size,\n            confidence_interval,\n        )\n        odds_ratio_estimate = f.log(odds_ratio)\n        zscore = pvalue_to_zscore(p_value)\n        odds_ratio_se = odds_ratio_estimate / zscore\n        return f.when(\n            f.lit(direction) == \"upper\",\n            f.exp(odds_ratio_estimate + f.abs(zscore_95 * odds_ratio_se)),\n        ).when(\n            f.lit(direction) == \"lower\",\n            f.exp(odds_ratio_estimate - f.abs(zscore_95 * odds_ratio_se)),\n        )\n\n    @staticmethod\n    def _concatenate_substudy_description(\n        association_trait: Column, pvalue_text: Column, mapped_trait_uri: Column\n    ) -&gt; Column:\n        \"\"\"Substudy description parsing. Complex string containing metadata about the substudy (e.g. QTL, specific EFO, etc.).\n\n        Args:\n            association_trait (Column): GWAS Catalog association trait column\n            pvalue_text (Column): GWAS Catalog p-value text column\n            mapped_trait_uri (Column): GWAS Catalog mapped trait URI column\n\n        Returns:\n            A column with the substudy description in the shape trait|pvaluetext1_pvaluetext2|EFO1_EFO2.\n\n        Examples:\n        &gt;&gt;&gt; df = spark.createDataFrame([\n        ...    (\"Height\", \"http://www.ebi.ac.uk/efo/EFO_0000001,http://www.ebi.ac.uk/efo/EFO_0000002\", \"European Ancestry\"),\n        ...    (\"Schizophrenia\", \"http://www.ebi.ac.uk/efo/MONDO_0005090\", None)],\n        ...    [\"association_trait\", \"mapped_trait_uri\", \"pvalue_text\"]\n        ... )\n        &gt;&gt;&gt; df.withColumn('substudy_description', GWASCatalogAssociations._concatenate_substudy_description(df.association_trait, df.pvalue_text, df.mapped_trait_uri)).show(truncate=False)\n        +-----------------+-------------------------------------------------------------------------+-----------------+------------------------------------------+\n        |association_trait|mapped_trait_uri                                                         |pvalue_text      |substudy_description                      |\n        +-----------------+-------------------------------------------------------------------------+-----------------+------------------------------------------+\n        |Height           |http://www.ebi.ac.uk/efo/EFO_0000001,http://www.ebi.ac.uk/efo/EFO_0000002|European Ancestry|Height|EA|EFO_0000001/EFO_0000002         |\n        |Schizophrenia    |http://www.ebi.ac.uk/efo/MONDO_0005090                                   |null             |Schizophrenia|no_pvalue_text|MONDO_0005090|\n        +-----------------+-------------------------------------------------------------------------+-----------------+------------------------------------------+\n        &lt;BLANKLINE&gt;\n        \"\"\"\n        p_value_text = f.coalesce(\n            GWASCatalogAssociations._normalise_pvaluetext(pvalue_text),\n            f.array(f.lit(\"no_pvalue_text\")),\n        )\n        return f.concat_ws(\n            \"|\",\n            association_trait,\n            f.concat_ws(\n                \"/\",\n                p_value_text,\n            ),\n            f.concat_ws(\n                \"/\",\n                parse_efos(mapped_trait_uri),\n            ),\n        )\n\n    @staticmethod\n    def _qc_all(\n        qc: Column,\n        chromosome: Column,\n        position: Column,\n        reference_allele: Column,\n        alternate_allele: Column,\n        strongest_snp_risk_allele: Column,\n        p_value_mantissa: Column,\n        p_value_exponent: Column,\n        p_value_cutoff: float,\n    ) -&gt; Column:\n        \"\"\"Flag associations that fail any QC.\n\n        Args:\n            qc (Column): QC column\n            chromosome (Column): Chromosome column\n            position (Column): Position column\n            reference_allele (Column): Reference allele column\n            alternate_allele (Column): Alternate allele column\n            strongest_snp_risk_allele (Column): Strongest SNP risk allele column\n            p_value_mantissa (Column): P-value mantissa column\n            p_value_exponent (Column): P-value exponent column\n            p_value_cutoff (float): P-value cutoff\n\n        Returns:\n            Column: Updated QC column with flag.\n        \"\"\"\n        qc = GWASCatalogAssociations._qc_variant_interactions(\n            qc, strongest_snp_risk_allele\n        )\n        qc = GWASCatalogAssociations._qc_subsignificant_associations(\n            qc, p_value_mantissa, p_value_exponent, p_value_cutoff\n        )\n        qc = GWASCatalogAssociations._qc_genomic_location(qc, chromosome, position)\n        qc = GWASCatalogAssociations._qc_variant_inconsistencies(\n            qc, chromosome, position, strongest_snp_risk_allele\n        )\n        qc = GWASCatalogAssociations._qc_unmapped_variants(qc, alternate_allele)\n        qc = GWASCatalogAssociations._qc_palindromic_alleles(\n            qc, reference_allele, alternate_allele\n        )\n        return qc\n\n    @staticmethod\n    def _qc_variant_interactions(\n        qc: Column, strongest_snp_risk_allele: Column\n    ) -&gt; Column:\n        \"\"\"Flag associations based on variant x variant interactions.\n\n        Args:\n            qc (Column): QC column\n            strongest_snp_risk_allele (Column): Column with the strongest SNP risk allele\n\n        Returns:\n            Column: Updated QC column with flag.\n        \"\"\"\n        return GWASCatalogAssociations._update_quality_flag(\n            qc,\n            strongest_snp_risk_allele.contains(\";\"),\n            StudyLocusQualityCheck.COMPOSITE_FLAG,\n        )\n\n    @staticmethod\n    def _qc_subsignificant_associations(\n        qc: Column,\n        p_value_mantissa: Column,\n        p_value_exponent: Column,\n        pvalue_cutoff: float,\n    ) -&gt; Column:\n        \"\"\"Flag associations below significant threshold.\n\n        Args:\n            qc (Column): QC column\n            p_value_mantissa (Column): P-value mantissa column\n            p_value_exponent (Column): P-value exponent column\n            pvalue_cutoff (float): association p-value cut-off\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Examples:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [{'qc': None, 'p_value_mantissa': 1, 'p_value_exponent': -7}, {'qc': None, 'p_value_mantissa': 1, 'p_value_exponent': -8}, {'qc': None, 'p_value_mantissa': 5, 'p_value_exponent': -8}, {'qc': None, 'p_value_mantissa': 1, 'p_value_exponent': -9}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, t.StructType([t.StructField('qc', t.ArrayType(t.StringType()), True), t.StructField('p_value_mantissa', t.IntegerType()), t.StructField('p_value_exponent', t.IntegerType())]))\n            &gt;&gt;&gt; df.withColumn('qc', GWASCatalogAssociations._qc_subsignificant_associations(f.col(\"qc\"), f.col(\"p_value_mantissa\"), f.col(\"p_value_exponent\"), 5e-8)).show(truncate = False)\n            +------------------------+----------------+----------------+\n            |qc                      |p_value_mantissa|p_value_exponent|\n            +------------------------+----------------+----------------+\n            |[Subsignificant p-value]|1               |-7              |\n            |[]                      |1               |-8              |\n            |[]                      |5               |-8              |\n            |[]                      |1               |-9              |\n            +------------------------+----------------+----------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return StudyLocus._update_quality_flag(\n            qc,\n            calculate_neglog_pvalue(p_value_mantissa, p_value_exponent)\n            &lt; f.lit(-np.log10(pvalue_cutoff)),\n            StudyLocusQualityCheck.SUBSIGNIFICANT_FLAG,\n        )\n\n    @staticmethod\n    def _qc_genomic_location(\n        qc: Column, chromosome: Column, position: Column\n    ) -&gt; Column:\n        \"\"\"Flag associations without genomic location in GWAS Catalog.\n\n        Args:\n            qc (Column): QC column\n            chromosome (Column): Chromosome column in GWAS Catalog\n            position (Column): Position column in GWAS Catalog\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Examples:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [{'qc': None, 'chromosome': None, 'position': None}, {'qc': None, 'chromosome': '1', 'position': None}, {'qc': None, 'chromosome': None, 'position': 1}, {'qc': None, 'chromosome': '1', 'position': 1}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d, schema=t.StructType([t.StructField('qc', t.ArrayType(t.StringType()), True), t.StructField('chromosome', t.StringType()), t.StructField('position', t.IntegerType())]))\n            &gt;&gt;&gt; df.withColumn('qc', GWASCatalogAssociations._qc_genomic_location(df.qc, df.chromosome, df.position)).show(truncate=False)\n            +----------------------------+----------+--------+\n            |qc                          |chromosome|position|\n            +----------------------------+----------+--------+\n            |[Incomplete genomic mapping]|null      |null    |\n            |[Incomplete genomic mapping]|1         |null    |\n            |[Incomplete genomic mapping]|null      |1       |\n            |[]                          |1         |1       |\n            +----------------------------+----------+--------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return StudyLocus._update_quality_flag(\n            qc,\n            position.isNull() | chromosome.isNull(),\n            StudyLocusQualityCheck.NO_GENOMIC_LOCATION_FLAG,\n        )\n\n    @staticmethod\n    def _qc_variant_inconsistencies(\n        qc: Column,\n        chromosome: Column,\n        position: Column,\n        strongest_snp_risk_allele: Column,\n    ) -&gt; Column:\n        \"\"\"Flag associations with inconsistencies in the variant annotation.\n\n        Args:\n            qc (Column): QC column\n            chromosome (Column): Chromosome column in GWAS Catalog\n            position (Column): Position column in GWAS Catalog\n            strongest_snp_risk_allele (Column): Strongest SNP risk allele column in GWAS Catalog\n\n        Returns:\n            Column: Updated QC column with flag.\n        \"\"\"\n        return GWASCatalogAssociations._update_quality_flag(\n            qc,\n            # Number of chromosomes does not correspond to the number of positions:\n            (f.size(f.split(chromosome, \";\")) != f.size(f.split(position, \";\")))\n            # Number of chromosome values different from riskAllele values:\n            | (\n                f.size(f.split(chromosome, \";\"))\n                != f.size(f.split(strongest_snp_risk_allele, \";\"))\n            ),\n            StudyLocusQualityCheck.INCONSISTENCY_FLAG,\n        )\n\n    @staticmethod\n    def _qc_unmapped_variants(qc: Column, alternate_allele: Column) -&gt; Column:\n        \"\"\"Flag associations with variants not mapped to variantAnnotation.\n\n        Args:\n            qc (Column): QC column\n            alternate_allele (Column): alternate allele\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; d = [{'alternate_allele': 'A', 'qc': None}, {'alternate_allele': None, 'qc': None}]\n            &gt;&gt;&gt; schema = t.StructType([t.StructField('alternate_allele', t.StringType(), True), t.StructField('qc', t.ArrayType(t.StringType()), True)])\n            &gt;&gt;&gt; df = spark.createDataFrame(data=d, schema=schema)\n            &gt;&gt;&gt; df.withColumn(\"new_qc\", GWASCatalogAssociations._qc_unmapped_variants(f.col(\"qc\"), f.col(\"alternate_allele\"))).show()\n            +----------------+----+--------------------+\n            |alternate_allele|  qc|              new_qc|\n            +----------------+----+--------------------+\n            |               A|null|                  []|\n            |            null|null|[No mapping in Gn...|\n            +----------------+----+--------------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return GWASCatalogAssociations._update_quality_flag(\n            qc,\n            alternate_allele.isNull(),\n            StudyLocusQualityCheck.NON_MAPPED_VARIANT_FLAG,\n        )\n\n    @staticmethod\n    def _qc_palindromic_alleles(\n        qc: Column, reference_allele: Column, alternate_allele: Column\n    ) -&gt; Column:\n        \"\"\"Flag associations with palindromic variants which effects can not be harmonised.\n\n        Args:\n            qc (Column): QC column\n            reference_allele (Column): reference allele\n            alternate_allele (Column): alternate allele\n\n        Returns:\n            Column: Updated QC column with flag.\n\n        Example:\n            &gt;&gt;&gt; import pyspark.sql.types as t\n            &gt;&gt;&gt; schema = t.StructType([t.StructField('reference_allele', t.StringType(), True), t.StructField('alternate_allele', t.StringType(), True), t.StructField('qc', t.ArrayType(t.StringType()), True)])\n            &gt;&gt;&gt; d = [{'reference_allele': 'A', 'alternate_allele': 'T', 'qc': None}, {'reference_allele': 'AT', 'alternate_allele': 'TA', 'qc': None}, {'reference_allele': 'AT', 'alternate_allele': 'AT', 'qc': None}]\n            &gt;&gt;&gt; df = spark.createDataFrame(data=d, schema=schema)\n            &gt;&gt;&gt; df.withColumn(\"qc\", GWASCatalogAssociations._qc_palindromic_alleles(f.col(\"qc\"), f.col(\"reference_allele\"), f.col(\"alternate_allele\"))).show(truncate=False)\n            +----------------+----------------+---------------------------------------+\n            |reference_allele|alternate_allele|qc                                     |\n            +----------------+----------------+---------------------------------------+\n            |A               |T               |[Palindrome alleles - cannot harmonize]|\n            |AT              |TA              |[]                                     |\n            |AT              |AT              |[Palindrome alleles - cannot harmonize]|\n            +----------------+----------------+---------------------------------------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return StudyLocus._update_quality_flag(\n            qc,\n            GWASCatalogAssociations._are_alleles_palindromic(\n                reference_allele, alternate_allele\n            ),\n            StudyLocusQualityCheck.PALINDROMIC_ALLELE_FLAG,\n        )\n\n    @classmethod\n    def from_source(\n        cls: type[GWASCatalogAssociations],\n        gwas_associations: DataFrame,\n        variant_annotation: VariantAnnotation,\n        pvalue_threshold: float = 5e-8,\n    ) -&gt; GWASCatalogAssociations:\n        \"\"\"Read GWASCatalog associations.\n\n        It reads the GWAS Catalog association dataset, selects and renames columns, casts columns, and\n        applies some pre-defined filters on the data:\n\n        Args:\n            gwas_associations (DataFrame): GWAS Catalog raw associations dataset\n            variant_annotation (VariantAnnotation): Variant annotation dataset\n            pvalue_threshold (float): P-value threshold for flagging associations\n\n        Returns:\n            StudyLocusGWASCatalog: StudyLocusGWASCatalog dataset\n        \"\"\"\n        return GWASCatalogAssociations(\n            _df=gwas_associations.withColumn(\n                \"studyLocusId\", f.monotonically_increasing_id().cast(LongType())\n            )\n            .transform(\n                # Map/harmonise variants to variant annotation dataset:\n                # This function adds columns: variantId, referenceAllele, alternateAllele, chromosome, position\n                lambda df: GWASCatalogAssociations._map_to_variant_annotation_variants(\n                    df, variant_annotation\n                )\n            )\n            .withColumn(\n                # Perform all quality control checks:\n                \"qualityControls\",\n                GWASCatalogAssociations._qc_all(\n                    f.array().alias(\"qualityControls\"),\n                    f.col(\"CHR_ID\"),\n                    f.col(\"CHR_POS\").cast(IntegerType()),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"STRONGEST SNP-RISK ALLELE\"),\n                    *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n                    pvalue_threshold,\n                ),\n            )\n            .select(\n                # INSIDE STUDY-LOCUS SCHEMA:\n                \"studyLocusId\",\n                \"variantId\",\n                # Mapped genomic location of the variant (; separated list)\n                \"chromosome\",\n                \"position\",\n                f.col(\"STUDY ACCESSION\").alias(\"studyId\"),\n                # beta value of the association\n                GWASCatalogAssociations._harmonise_beta(\n                    GWASCatalogAssociations._normalise_risk_allele(\n                        f.col(\"STRONGEST SNP-RISK ALLELE\")\n                    ),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"OR or BETA\"),\n                    f.col(\"95% CI (TEXT)\"),\n                ).alias(\"beta\"),\n                # odds ratio of the association\n                GWASCatalogAssociations._harmonise_odds_ratio(\n                    GWASCatalogAssociations._normalise_risk_allele(\n                        f.col(\"STRONGEST SNP-RISK ALLELE\")\n                    ),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"OR or BETA\"),\n                    f.col(\"95% CI (TEXT)\"),\n                ).alias(\"oddsRatio\"),\n                # CI lower of the beta value\n                GWASCatalogAssociations._harmonise_beta_ci(\n                    GWASCatalogAssociations._normalise_risk_allele(\n                        f.col(\"STRONGEST SNP-RISK ALLELE\")\n                    ),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"OR or BETA\"),\n                    f.col(\"95% CI (TEXT)\"),\n                    f.col(\"P-VALUE\"),\n                    \"lower\",\n                ).alias(\"betaConfidenceIntervalLower\"),\n                # CI upper for the beta value\n                GWASCatalogAssociations._harmonise_beta_ci(\n                    GWASCatalogAssociations._normalise_risk_allele(\n                        f.col(\"STRONGEST SNP-RISK ALLELE\")\n                    ),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"OR or BETA\"),\n                    f.col(\"95% CI (TEXT)\"),\n                    f.col(\"P-VALUE\"),\n                    \"upper\",\n                ).alias(\"betaConfidenceIntervalUpper\"),\n                # CI lower of the odds ratio value\n                GWASCatalogAssociations._harmonise_odds_ratio_ci(\n                    GWASCatalogAssociations._normalise_risk_allele(\n                        f.col(\"STRONGEST SNP-RISK ALLELE\")\n                    ),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"OR or BETA\"),\n                    f.col(\"95% CI (TEXT)\"),\n                    f.col(\"P-VALUE\"),\n                    \"lower\",\n                ).alias(\"oddsRatioConfidenceIntervalLower\"),\n                # CI upper of the odds ratio value\n                GWASCatalogAssociations._harmonise_odds_ratio_ci(\n                    GWASCatalogAssociations._normalise_risk_allele(\n                        f.col(\"STRONGEST SNP-RISK ALLELE\")\n                    ),\n                    f.col(\"referenceAllele\"),\n                    f.col(\"alternateAllele\"),\n                    f.col(\"OR or BETA\"),\n                    f.col(\"95% CI (TEXT)\"),\n                    f.col(\"P-VALUE\"),\n                    \"upper\",\n                ).alias(\"oddsRatioConfidenceIntervalUpper\"),\n                # p-value of the association, string: split into exponent and mantissa.\n                *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n                # Capturing phenotype granularity at the association level\n                GWASCatalogAssociations._concatenate_substudy_description(\n                    f.col(\"DISEASE/TRAIT\"),\n                    f.col(\"P-VALUE (TEXT)\"),\n                    f.col(\"MAPPED_TRAIT_URI\"),\n                ).alias(\"subStudyDescription\"),\n                # Quality controls (array of strings)\n                \"qualityControls\",\n            ),\n            _schema=GWASCatalogAssociations.get_schema(),\n        )\n\n    def update_study_id(\n        self: GWASCatalogAssociations, study_annotation: DataFrame\n    ) -&gt; GWASCatalogAssociations:\n        \"\"\"Update final studyId and studyLocusId with a dataframe containing study annotation.\n\n        Args:\n            study_annotation (DataFrame): Dataframe containing `updatedStudyId` and key columns `studyId` and `subStudyDescription`.\n\n        Returns:\n            StudyLocusGWASCatalog: Updated study locus with new `studyId` and `studyLocusId`.\n        \"\"\"\n        self.df = (\n            self._df.join(\n                study_annotation, on=[\"studyId\", \"subStudyDescription\"], how=\"left\"\n            )\n            .withColumn(\"studyId\", f.coalesce(\"updatedStudyId\", \"studyId\"))\n            .drop(\"subStudyDescription\", \"updatedStudyId\")\n        ).withColumn(\n            \"studyLocusId\",\n            StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\")),\n        )\n        return self\n\n    def _qc_ambiguous_study(self: GWASCatalogAssociations) -&gt; GWASCatalogAssociations:\n        \"\"\"Flag associations with variants that can not be unambiguously associated with one study.\n\n        Returns:\n            StudyLocusGWASCatalog: Updated study locus.\n        \"\"\"\n        assoc_ambiguity_window = Window.partitionBy(\n            f.col(\"studyId\"), f.col(\"variantId\")\n        )\n\n        self._df.withColumn(\n            \"qualityControls\",\n            StudyLocus._update_quality_flag(\n                f.col(\"qualityControls\"),\n                f.count(f.col(\"variantId\")).over(assoc_ambiguity_window) &gt; 1,\n                StudyLocusQualityCheck.AMBIGUOUS_STUDY,\n            ),\n        )\n        return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/associations/#otg.datasource.gwas_catalog.associations.GWASCatalogAssociations.from_source","title":"<code>from_source(gwas_associations, variant_annotation, pvalue_threshold=5e-08)</code>  <code>classmethod</code>","text":"<p>Read GWASCatalog associations.</p> <p>It reads the GWAS Catalog association dataset, selects and renames columns, casts columns, and applies some pre-defined filters on the data:</p> <p>Parameters:</p> Name Type Description Default <code>gwas_associations</code> <code>DataFrame</code> <p>GWAS Catalog raw associations dataset</p> required <code>variant_annotation</code> <code>VariantAnnotation</code> <p>Variant annotation dataset</p> required <code>pvalue_threshold</code> <code>float</code> <p>P-value threshold for flagging associations</p> <code>5e-08</code> <p>Returns:</p> Name Type Description <code>StudyLocusGWASCatalog</code> <code>GWASCatalogAssociations</code> <p>StudyLocusGWASCatalog dataset</p> Source code in <code>src/otg/datasource/gwas_catalog/associations.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[GWASCatalogAssociations],\n    gwas_associations: DataFrame,\n    variant_annotation: VariantAnnotation,\n    pvalue_threshold: float = 5e-8,\n) -&gt; GWASCatalogAssociations:\n    \"\"\"Read GWASCatalog associations.\n\n    It reads the GWAS Catalog association dataset, selects and renames columns, casts columns, and\n    applies some pre-defined filters on the data:\n\n    Args:\n        gwas_associations (DataFrame): GWAS Catalog raw associations dataset\n        variant_annotation (VariantAnnotation): Variant annotation dataset\n        pvalue_threshold (float): P-value threshold for flagging associations\n\n    Returns:\n        StudyLocusGWASCatalog: StudyLocusGWASCatalog dataset\n    \"\"\"\n    return GWASCatalogAssociations(\n        _df=gwas_associations.withColumn(\n            \"studyLocusId\", f.monotonically_increasing_id().cast(LongType())\n        )\n        .transform(\n            # Map/harmonise variants to variant annotation dataset:\n            # This function adds columns: variantId, referenceAllele, alternateAllele, chromosome, position\n            lambda df: GWASCatalogAssociations._map_to_variant_annotation_variants(\n                df, variant_annotation\n            )\n        )\n        .withColumn(\n            # Perform all quality control checks:\n            \"qualityControls\",\n            GWASCatalogAssociations._qc_all(\n                f.array().alias(\"qualityControls\"),\n                f.col(\"CHR_ID\"),\n                f.col(\"CHR_POS\").cast(IntegerType()),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"STRONGEST SNP-RISK ALLELE\"),\n                *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n                pvalue_threshold,\n            ),\n        )\n        .select(\n            # INSIDE STUDY-LOCUS SCHEMA:\n            \"studyLocusId\",\n            \"variantId\",\n            # Mapped genomic location of the variant (; separated list)\n            \"chromosome\",\n            \"position\",\n            f.col(\"STUDY ACCESSION\").alias(\"studyId\"),\n            # beta value of the association\n            GWASCatalogAssociations._harmonise_beta(\n                GWASCatalogAssociations._normalise_risk_allele(\n                    f.col(\"STRONGEST SNP-RISK ALLELE\")\n                ),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"OR or BETA\"),\n                f.col(\"95% CI (TEXT)\"),\n            ).alias(\"beta\"),\n            # odds ratio of the association\n            GWASCatalogAssociations._harmonise_odds_ratio(\n                GWASCatalogAssociations._normalise_risk_allele(\n                    f.col(\"STRONGEST SNP-RISK ALLELE\")\n                ),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"OR or BETA\"),\n                f.col(\"95% CI (TEXT)\"),\n            ).alias(\"oddsRatio\"),\n            # CI lower of the beta value\n            GWASCatalogAssociations._harmonise_beta_ci(\n                GWASCatalogAssociations._normalise_risk_allele(\n                    f.col(\"STRONGEST SNP-RISK ALLELE\")\n                ),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"OR or BETA\"),\n                f.col(\"95% CI (TEXT)\"),\n                f.col(\"P-VALUE\"),\n                \"lower\",\n            ).alias(\"betaConfidenceIntervalLower\"),\n            # CI upper for the beta value\n            GWASCatalogAssociations._harmonise_beta_ci(\n                GWASCatalogAssociations._normalise_risk_allele(\n                    f.col(\"STRONGEST SNP-RISK ALLELE\")\n                ),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"OR or BETA\"),\n                f.col(\"95% CI (TEXT)\"),\n                f.col(\"P-VALUE\"),\n                \"upper\",\n            ).alias(\"betaConfidenceIntervalUpper\"),\n            # CI lower of the odds ratio value\n            GWASCatalogAssociations._harmonise_odds_ratio_ci(\n                GWASCatalogAssociations._normalise_risk_allele(\n                    f.col(\"STRONGEST SNP-RISK ALLELE\")\n                ),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"OR or BETA\"),\n                f.col(\"95% CI (TEXT)\"),\n                f.col(\"P-VALUE\"),\n                \"lower\",\n            ).alias(\"oddsRatioConfidenceIntervalLower\"),\n            # CI upper of the odds ratio value\n            GWASCatalogAssociations._harmonise_odds_ratio_ci(\n                GWASCatalogAssociations._normalise_risk_allele(\n                    f.col(\"STRONGEST SNP-RISK ALLELE\")\n                ),\n                f.col(\"referenceAllele\"),\n                f.col(\"alternateAllele\"),\n                f.col(\"OR or BETA\"),\n                f.col(\"95% CI (TEXT)\"),\n                f.col(\"P-VALUE\"),\n                \"upper\",\n            ).alias(\"oddsRatioConfidenceIntervalUpper\"),\n            # p-value of the association, string: split into exponent and mantissa.\n            *GWASCatalogAssociations._parse_pvalue(f.col(\"P-VALUE\")),\n            # Capturing phenotype granularity at the association level\n            GWASCatalogAssociations._concatenate_substudy_description(\n                f.col(\"DISEASE/TRAIT\"),\n                f.col(\"P-VALUE (TEXT)\"),\n                f.col(\"MAPPED_TRAIT_URI\"),\n            ).alias(\"subStudyDescription\"),\n            # Quality controls (array of strings)\n            \"qualityControls\",\n        ),\n        _schema=GWASCatalogAssociations.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/associations/#otg.datasource.gwas_catalog.associations.GWASCatalogAssociations.update_study_id","title":"<code>update_study_id(study_annotation)</code>","text":"<p>Update final studyId and studyLocusId with a dataframe containing study annotation.</p> <p>Parameters:</p> Name Type Description Default <code>study_annotation</code> <code>DataFrame</code> <p>Dataframe containing <code>updatedStudyId</code> and key columns <code>studyId</code> and <code>subStudyDescription</code>.</p> required <p>Returns:</p> Name Type Description <code>StudyLocusGWASCatalog</code> <code>GWASCatalogAssociations</code> <p>Updated study locus with new <code>studyId</code> and <code>studyLocusId</code>.</p> Source code in <code>src/otg/datasource/gwas_catalog/associations.py</code> <pre><code>def update_study_id(\n    self: GWASCatalogAssociations, study_annotation: DataFrame\n) -&gt; GWASCatalogAssociations:\n    \"\"\"Update final studyId and studyLocusId with a dataframe containing study annotation.\n\n    Args:\n        study_annotation (DataFrame): Dataframe containing `updatedStudyId` and key columns `studyId` and `subStudyDescription`.\n\n    Returns:\n        StudyLocusGWASCatalog: Updated study locus with new `studyId` and `studyLocusId`.\n    \"\"\"\n    self.df = (\n        self._df.join(\n            study_annotation, on=[\"studyId\", \"subStudyDescription\"], how=\"left\"\n        )\n        .withColumn(\"studyId\", f.coalesce(\"updatedStudyId\", \"studyId\"))\n        .drop(\"subStudyDescription\", \"updatedStudyId\")\n    ).withColumn(\n        \"studyLocusId\",\n        StudyLocus.assign_study_locus_id(f.col(\"studyId\"), f.col(\"variantId\")),\n    )\n    return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_index/","title":"Study index","text":"<p>             Bases: <code>StudyIndex</code></p> <p>Study index from GWAS Catalog.</p> <p>The following information is harmonised from the GWAS Catalog:</p> <ul> <li>All publication related information retained.</li> <li>Mapped measured and background traits parsed.</li> <li>Flagged if harmonized summary statistics datasets available.</li> <li>If available, the ftp path to these files presented.</li> <li>Ancestries from the discovery and replication stages are structured with sample counts.</li> <li>Case/control counts extracted.</li> <li>The number of samples with European ancestry extracted.</li> </ul> Source code in <code>src/otg/datasource/gwas_catalog/study_index.py</code> <pre><code>@dataclass\nclass GWASCatalogStudyIndex(StudyIndex):\n    \"\"\"Study index from GWAS Catalog.\n\n    The following information is harmonised from the GWAS Catalog:\n\n    - All publication related information retained.\n    - Mapped measured and background traits parsed.\n    - Flagged if harmonized summary statistics datasets available.\n    - If available, the ftp path to these files presented.\n    - Ancestries from the discovery and replication stages are structured with sample counts.\n    - Case/control counts extracted.\n    - The number of samples with European ancestry extracted.\n\n    \"\"\"\n\n    @staticmethod\n    def _parse_discovery_samples(discovery_samples: Column) -&gt; Column:\n        \"\"\"Parse discovery sample sizes from GWAS Catalog.\n\n        This is a curated field. From publication sometimes it is not clear how the samples were split\n        across the reported ancestries. In such cases we are assuming the ancestries were evenly presented\n        and the total sample size is split:\n\n        [\"European, African\", 100] -&gt; [\"European, 50], [\"African\", 50]\n\n        Args:\n            discovery_samples (Column): Raw discovery sample sizes\n\n        Returns:\n            Column: Parsed and de-duplicated list of discovery ancestries with sample size.\n\n        Examples:\n            &gt;&gt;&gt; data = [('s1', \"European\", 10), ('s1', \"African\", 10), ('s2', \"European, African, Asian\", 100), ('s2', \"European\", 50)]\n            &gt;&gt;&gt; df = (\n            ...    spark.createDataFrame(data, ['studyId', 'ancestry', 'sampleSize'])\n            ...    .groupBy('studyId')\n            ...    .agg(\n            ...        f.collect_set(\n            ...            f.struct('ancestry', 'sampleSize')\n            ...        ).alias('discoverySampleSize')\n            ...    )\n            ...    .orderBy('studyId')\n            ...    .withColumn('discoverySampleSize', GWASCatalogStudyIndex._parse_discovery_samples(f.col('discoverySampleSize')))\n            ...    .select('discoverySampleSize')\n            ...    .show(truncate=False)\n            ... )\n            +--------------------------------------------+\n            |discoverySampleSize                         |\n            +--------------------------------------------+\n            |[{African, 10}, {European, 10}]             |\n            |[{European, 83}, {African, 33}, {Asian, 33}]|\n            +--------------------------------------------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        # To initialize return objects for aggregate functions, schema has to be definied:\n        schema = t.ArrayType(\n            t.StructType(\n                [\n                    t.StructField(\"ancestry\", t.StringType(), True),\n                    t.StructField(\"sampleSize\", t.IntegerType(), True),\n                ]\n            )\n        )\n\n        # Splitting comma separated ancestries:\n        exploded_ancestries = f.transform(\n            discovery_samples,\n            lambda sample: f.split(sample.ancestry, r\",\\s(?![^()]*\\))\"),\n        )\n\n        # Initialize discoverySample object from unique list of ancestries:\n        unique_ancestries = f.transform(\n            f.aggregate(\n                exploded_ancestries,\n                f.array().cast(t.ArrayType(t.StringType())),\n                lambda x, y: f.array_union(x, y),\n                f.array_distinct,\n            ),\n            lambda ancestry: f.struct(\n                ancestry.alias(\"ancestry\"),\n                f.lit(0).cast(t.LongType()).alias(\"sampleSize\"),\n            ),\n        )\n\n        # Computing sample sizes for ancestries when splitting is needed:\n        resolved_sample_count = f.transform(\n            f.arrays_zip(\n                f.transform(exploded_ancestries, lambda pop: f.size(pop)).alias(\n                    \"pop_size\"\n                ),\n                f.transform(discovery_samples, lambda pop: pop.sampleSize).alias(\n                    \"pop_count\"\n                ),\n            ),\n            lambda pop: (pop.pop_count / pop.pop_size).cast(t.IntegerType()),\n        )\n\n        # Flattening out ancestries with sample sizes:\n        parsed_sample_size = f.aggregate(\n            f.transform(\n                f.arrays_zip(\n                    exploded_ancestries.alias(\"ancestries\"),\n                    resolved_sample_count.alias(\"sample_count\"),\n                ),\n                GWASCatalogStudyIndex._merge_ancestries_and_counts,\n            ),\n            f.array().cast(schema),\n            lambda x, y: f.array_union(x, y),\n        )\n\n        # Normalize ancestries:\n        return f.aggregate(\n            parsed_sample_size,\n            unique_ancestries,\n            GWASCatalogStudyIndex._normalize_ancestries,\n        )\n\n    @staticmethod\n    def _normalize_ancestries(merged: Column, ancestry: Column) -&gt; Column:\n        \"\"\"Normalize ancestries from a list of structs.\n\n        As some ancestry label might be repeated with different sample counts,\n        these counts need to be collected.\n\n        Args:\n            merged (Column): Resulting list of struct with unique ancestries.\n            ancestry (Column): One ancestry object coming from raw.\n\n        Returns:\n            Column: Unique list of ancestries with the sample counts.\n        \"\"\"\n        # Iterating over the list of unique ancestries and adding the sample size if label matches:\n        return f.transform(\n            merged,\n            lambda a: f.when(\n                a.ancestry == ancestry.ancestry,\n                f.struct(\n                    a.ancestry.alias(\"ancestry\"),\n                    (a.sampleSize + ancestry.sampleSize)\n                    .cast(t.LongType())\n                    .alias(\"sampleSize\"),\n                ),\n            ).otherwise(a),\n        )\n\n    @staticmethod\n    def _merge_ancestries_and_counts(ancestry_group: Column) -&gt; Column:\n        \"\"\"Merge ancestries with sample sizes.\n\n        After splitting ancestry annotations, all resulting ancestries needs to be assigned\n        with the proper sample size.\n\n        Args:\n            ancestry_group (Column): Each element is a struct with `sample_count` (int) and `ancestries` (list)\n\n        Returns:\n            Column: a list of structs with `ancestry` and `sampleSize` fields.\n\n        Examples:\n            &gt;&gt;&gt; data = [(12, ['African', 'European']),(12, ['African'])]\n            &gt;&gt;&gt; (\n            ...     spark.createDataFrame(data, ['sample_count', 'ancestries'])\n            ...     .select(GWASCatalogStudyIndex._merge_ancestries_and_counts(f.struct('sample_count', 'ancestries')).alias('test'))\n            ...     .show(truncate=False)\n            ... )\n            +-------------------------------+\n            |test                           |\n            +-------------------------------+\n            |[{African, 12}, {European, 12}]|\n            |[{African, 12}]                |\n            +-------------------------------+\n            &lt;BLANKLINE&gt;\n        \"\"\"\n        # Extract sample size for the ancestry group:\n        count = ancestry_group.sample_count\n\n        # We need to loop through the ancestries:\n        return f.transform(\n            ancestry_group.ancestries,\n            lambda ancestry: f.struct(\n                ancestry.alias(\"ancestry\"),\n                count.alias(\"sampleSize\"),\n            ),\n        )\n\n    @classmethod\n    def _parse_study_table(\n        cls: type[GWASCatalogStudyIndex], catalog_studies: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Harmonise GWASCatalog study table with `StudyIndex` schema.\n\n        Args:\n            catalog_studies (DataFrame): GWAS Catalog study table\n\n        Returns:\n            GWASCatalogStudyIndex: Parsed and annotated GWAS Catalog study table.\n        \"\"\"\n        return GWASCatalogStudyIndex(\n            _df=catalog_studies.select(\n                f.coalesce(\n                    f.col(\"STUDY ACCESSION\"), f.monotonically_increasing_id()\n                ).alias(\"studyId\"),\n                f.lit(\"GCST\").alias(\"projectId\"),\n                f.lit(\"gwas\").alias(\"studyType\"),\n                f.col(\"PUBMED ID\").alias(\"pubmedId\"),\n                f.col(\"FIRST AUTHOR\").alias(\"publicationFirstAuthor\"),\n                f.col(\"DATE\").alias(\"publicationDate\"),\n                f.col(\"JOURNAL\").alias(\"publicationJournal\"),\n                f.col(\"STUDY\").alias(\"publicationTitle\"),\n                f.coalesce(f.col(\"DISEASE/TRAIT\"), f.lit(\"Unreported\")).alias(\n                    \"traitFromSource\"\n                ),\n                f.col(\"INITIAL SAMPLE SIZE\").alias(\"initialSampleSize\"),\n                parse_efos(f.col(\"MAPPED_TRAIT_URI\")).alias(\"traitFromSourceMappedIds\"),\n                parse_efos(f.col(\"MAPPED BACKGROUND TRAIT URI\")).alias(\n                    \"backgroundTraitFromSourceMappedIds\"\n                ),\n            ),\n            _schema=GWASCatalogStudyIndex.get_schema(),\n        )\n\n    @classmethod\n    def from_source(\n        cls: type[GWASCatalogStudyIndex],\n        catalog_studies: DataFrame,\n        ancestry_file: DataFrame,\n        sumstats_lut: DataFrame,\n    ) -&gt; StudyIndex:\n        \"\"\"Ingests study level metadata from the GWAS Catalog.\n\n        Args:\n            catalog_studies (DataFrame): GWAS Catalog raw study table\n            ancestry_file (DataFrame): GWAS Catalog ancestry table.\n            sumstats_lut (DataFrame): GWAS Catalog summary statistics list.\n\n        Returns:\n            GWASCatalogStudyIndex: Parsed and annotated GWAS Catalog study table.\n        \"\"\"\n        # Read GWAS Catalogue raw data\n        return (\n            cls._parse_study_table(catalog_studies)\n            ._annotate_ancestries(ancestry_file)\n            ._annotate_sumstats_info(sumstats_lut)\n            ._annotate_discovery_sample_sizes()\n        )\n\n    def update_study_id(\n        self: GWASCatalogStudyIndex, study_annotation: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Update studyId with a dataframe containing study.\n\n        Args:\n            study_annotation (DataFrame): Dataframe containing `updatedStudyId`, `traitFromSource`, `traitFromSourceMappedIds` and key column `studyId`.\n\n        Returns:\n            GWASCatalogStudyIndex: Updated study table.\n        \"\"\"\n        self.df = (\n            self._df.join(\n                study_annotation.select(\n                    *[\n                        f.col(c).alias(f\"updated{c}\")\n                        if c not in [\"studyId\", \"updatedStudyId\"]\n                        else f.col(c)\n                        for c in study_annotation.columns\n                    ]\n                ),\n                on=\"studyId\",\n                how=\"left\",\n            )\n            .withColumn(\n                \"studyId\",\n                f.coalesce(f.col(\"updatedStudyId\"), f.col(\"studyId\")),\n            )\n            .withColumn(\n                \"traitFromSource\",\n                f.coalesce(f.col(\"updatedtraitFromSource\"), f.col(\"traitFromSource\")),\n            )\n            .withColumn(\n                \"traitFromSourceMappedIds\",\n                f.coalesce(\n                    f.col(\"updatedtraitFromSourceMappedIds\"),\n                    f.col(\"traitFromSourceMappedIds\"),\n                ),\n            )\n            .select(self._df.columns)\n        )\n\n        return self\n\n    def _annotate_ancestries(\n        self: GWASCatalogStudyIndex, ancestry_lut: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Extracting sample sizes and ancestry information.\n\n        This function parses the ancestry data. Also get counts for the europeans in the same\n        discovery stage.\n\n        Args:\n            ancestry_lut (DataFrame): Ancestry table as downloaded from the GWAS Catalog\n\n        Returns:\n            GWASCatalogStudyIndex: Slimmed and cleaned version of the ancestry annotation.\n        \"\"\"\n        ancestry = (\n            ancestry_lut\n            # Convert column headers to camelcase:\n            .transform(\n                lambda df: df.select(\n                    *[f.expr(column2camel_case(x)) for x in df.columns]\n                )\n            ).withColumnRenamed(\n                \"studyAccession\", \"studyId\"\n            )  # studyId has not been split yet\n        )\n\n        # Get a high resolution dataset on experimental stage:\n        ancestry_stages = (\n            ancestry.groupBy(\"studyId\")\n            .pivot(\"stage\")\n            .agg(\n                f.collect_set(\n                    f.struct(\n                        f.col(\"broadAncestralCategory\").alias(\"ancestry\"),\n                        f.col(\"numberOfIndividuals\")\n                        .cast(t.LongType())\n                        .alias(\"sampleSize\"),\n                    )\n                )\n            )\n            .withColumn(\n                \"discoverySamples\", self._parse_discovery_samples(f.col(\"initial\"))\n            )\n            .withColumnRenamed(\"replication\", \"replicationSamples\")\n            # Mapping discovery stage ancestries to LD reference:\n            .withColumn(\n                \"ldPopulationStructure\",\n                self.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n            )\n            .drop(\"initial\")\n            .persist()\n        )\n\n        # Generate information on the ancestry composition of the discovery stage, and calculate\n        # the proportion of the Europeans:\n        europeans_deconvoluted = (\n            ancestry\n            # Focus on discovery stage:\n            .filter(f.col(\"stage\") == \"initial\")\n            # Sorting ancestries if European:\n            .withColumn(\n                \"ancestryFlag\",\n                # Excluding finnish:\n                f.when(\n                    f.col(\"initialSampleDescription\").contains(\"Finnish\"),\n                    f.lit(\"other\"),\n                )\n                # Excluding Icelandic population:\n                .when(\n                    f.col(\"initialSampleDescription\").contains(\"Icelandic\"),\n                    f.lit(\"other\"),\n                )\n                # Including European ancestry:\n                .when(f.col(\"broadAncestralCategory\") == \"European\", f.lit(\"european\"))\n                # Exclude all other population:\n                .otherwise(\"other\"),\n            )\n            # Grouping by study accession and initial sample description:\n            .groupBy(\"studyId\")\n            .pivot(\"ancestryFlag\")\n            .agg(\n                # Summarizing sample sizes for all ancestries:\n                f.sum(f.col(\"numberOfIndividuals\"))\n            )\n            # Do arithmetics to make sure we have the right proportion of european in the set:\n            .withColumn(\n                \"initialSampleCountEuropean\",\n                f.when(f.col(\"european\").isNull(), f.lit(0)).otherwise(\n                    f.col(\"european\")\n                ),\n            )\n            .withColumn(\n                \"initialSampleCountOther\",\n                f.when(f.col(\"other\").isNull(), f.lit(0)).otherwise(f.col(\"other\")),\n            )\n            .withColumn(\n                \"initialSampleCount\",\n                f.col(\"initialSampleCountEuropean\") + f.col(\"other\"),\n            )\n            .drop(\n                \"european\",\n                \"other\",\n                \"initialSampleCount\",\n                \"initialSampleCountEuropean\",\n                \"initialSampleCountOther\",\n            )\n        )\n\n        parsed_ancestry_lut = ancestry_stages.join(\n            europeans_deconvoluted, on=\"studyId\", how=\"outer\"\n        )\n\n        self.df = self.df.join(parsed_ancestry_lut, on=\"studyId\", how=\"left\")\n        return self\n\n    def _annotate_sumstats_info(\n        self: GWASCatalogStudyIndex, sumstats_lut: DataFrame\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Annotate summary stat locations.\n\n        Args:\n            sumstats_lut (DataFrame): listing GWAS Catalog summary stats paths\n\n        Returns:\n            GWASCatalogStudyIndex: including `summarystatsLocation` and `hasSumstats` columns\n        \"\"\"\n        gwas_sumstats_base_uri = (\n            \"ftp://ftp.ebi.ac.uk/pub/databases/gwas/summary_statistics/\"\n        )\n\n        parsed_sumstats_lut = sumstats_lut.withColumn(\n            \"summarystatsLocation\",\n            f.concat(\n                f.lit(gwas_sumstats_base_uri),\n                f.regexp_replace(f.col(\"_c0\"), r\"^\\.\\/\", \"\"),\n            ),\n        ).select(\n            f.regexp_extract(f.col(\"summarystatsLocation\"), r\"\\/(GCST\\d+)\\/\", 1).alias(\n                \"studyId\"\n            ),\n            \"summarystatsLocation\",\n            f.lit(True).alias(\"hasSumstats\"),\n        )\n\n        self.df = (\n            self.df.drop(\"hasSumstats\")\n            .join(parsed_sumstats_lut, on=\"studyId\", how=\"left\")\n            .withColumn(\"hasSumstats\", f.coalesce(f.col(\"hasSumstats\"), f.lit(False)))\n        )\n        return self\n\n    def _annotate_discovery_sample_sizes(\n        self: GWASCatalogStudyIndex,\n    ) -&gt; GWASCatalogStudyIndex:\n        \"\"\"Extract the sample size of the discovery stage of the study as annotated in the GWAS Catalog.\n\n        For some studies that measure quantitative traits, nCases and nControls can't be extracted. Therefore, we assume these are 0.\n\n        Returns:\n            GWASCatalogStudyIndex: object with columns `nCases`, `nControls`, and `nSamples` per `studyId` correctly extracted.\n        \"\"\"\n        sample_size_lut = (\n            self.df.select(\n                \"studyId\",\n                f.explode_outer(f.split(f.col(\"initialSampleSize\"), r\",\\s+\")).alias(\n                    \"samples\"\n                ),\n            )\n            # Extracting the sample size from the string:\n            .withColumn(\n                \"sampleSize\",\n                f.regexp_extract(\n                    f.regexp_replace(f.col(\"samples\"), \",\", \"\"), r\"[0-9,]+\", 0\n                ).cast(t.IntegerType()),\n            )\n            .select(\n                \"studyId\",\n                \"sampleSize\",\n                f.when(f.col(\"samples\").contains(\"cases\"), f.col(\"sampleSize\"))\n                .otherwise(f.lit(0))\n                .alias(\"nCases\"),\n                f.when(f.col(\"samples\").contains(\"controls\"), f.col(\"sampleSize\"))\n                .otherwise(f.lit(0))\n                .alias(\"nControls\"),\n            )\n            # Aggregating sample sizes for all ancestries:\n            .groupBy(\"studyId\")  # studyId has not been split yet\n            .agg(\n                f.sum(\"nCases\").alias(\"nCases\"),\n                f.sum(\"nControls\").alias(\"nControls\"),\n                f.sum(\"sampleSize\").alias(\"nSamples\"),\n            )\n        )\n        self.df = self.df.join(sample_size_lut, on=\"studyId\", how=\"left\")\n        return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_index/#otg.datasource.gwas_catalog.study_index.GWASCatalogStudyIndex.from_source","title":"<code>from_source(catalog_studies, ancestry_file, sumstats_lut)</code>  <code>classmethod</code>","text":"<p>Ingests study level metadata from the GWAS Catalog.</p> <p>Parameters:</p> Name Type Description Default <code>catalog_studies</code> <code>DataFrame</code> <p>GWAS Catalog raw study table</p> required <code>ancestry_file</code> <code>DataFrame</code> <p>GWAS Catalog ancestry table.</p> required <code>sumstats_lut</code> <code>DataFrame</code> <p>GWAS Catalog summary statistics list.</p> required <p>Returns:</p> Name Type Description <code>GWASCatalogStudyIndex</code> <code>StudyIndex</code> <p>Parsed and annotated GWAS Catalog study table.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_index.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[GWASCatalogStudyIndex],\n    catalog_studies: DataFrame,\n    ancestry_file: DataFrame,\n    sumstats_lut: DataFrame,\n) -&gt; StudyIndex:\n    \"\"\"Ingests study level metadata from the GWAS Catalog.\n\n    Args:\n        catalog_studies (DataFrame): GWAS Catalog raw study table\n        ancestry_file (DataFrame): GWAS Catalog ancestry table.\n        sumstats_lut (DataFrame): GWAS Catalog summary statistics list.\n\n    Returns:\n        GWASCatalogStudyIndex: Parsed and annotated GWAS Catalog study table.\n    \"\"\"\n    # Read GWAS Catalogue raw data\n    return (\n        cls._parse_study_table(catalog_studies)\n        ._annotate_ancestries(ancestry_file)\n        ._annotate_sumstats_info(sumstats_lut)\n        ._annotate_discovery_sample_sizes()\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_index/#otg.datasource.gwas_catalog.study_index.GWASCatalogStudyIndex.update_study_id","title":"<code>update_study_id(study_annotation)</code>","text":"<p>Update studyId with a dataframe containing study.</p> <p>Parameters:</p> Name Type Description Default <code>study_annotation</code> <code>DataFrame</code> <p>Dataframe containing <code>updatedStudyId</code>, <code>traitFromSource</code>, <code>traitFromSourceMappedIds</code> and key column <code>studyId</code>.</p> required <p>Returns:</p> Name Type Description <code>GWASCatalogStudyIndex</code> <code>GWASCatalogStudyIndex</code> <p>Updated study table.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_index.py</code> <pre><code>def update_study_id(\n    self: GWASCatalogStudyIndex, study_annotation: DataFrame\n) -&gt; GWASCatalogStudyIndex:\n    \"\"\"Update studyId with a dataframe containing study.\n\n    Args:\n        study_annotation (DataFrame): Dataframe containing `updatedStudyId`, `traitFromSource`, `traitFromSourceMappedIds` and key column `studyId`.\n\n    Returns:\n        GWASCatalogStudyIndex: Updated study table.\n    \"\"\"\n    self.df = (\n        self._df.join(\n            study_annotation.select(\n                *[\n                    f.col(c).alias(f\"updated{c}\")\n                    if c not in [\"studyId\", \"updatedStudyId\"]\n                    else f.col(c)\n                    for c in study_annotation.columns\n                ]\n            ),\n            on=\"studyId\",\n            how=\"left\",\n        )\n        .withColumn(\n            \"studyId\",\n            f.coalesce(f.col(\"updatedStudyId\"), f.col(\"studyId\")),\n        )\n        .withColumn(\n            \"traitFromSource\",\n            f.coalesce(f.col(\"updatedtraitFromSource\"), f.col(\"traitFromSource\")),\n        )\n        .withColumn(\n            \"traitFromSourceMappedIds\",\n            f.coalesce(\n                f.col(\"updatedtraitFromSourceMappedIds\"),\n                f.col(\"traitFromSourceMappedIds\"),\n            ),\n        )\n        .select(self._df.columns)\n    )\n\n    return self\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_splitter/","title":"Study splitter","text":"<p>Splitting multi-trait GWAS Catalog studies.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_splitter.py</code> <pre><code>class GWASCatalogStudySplitter:\n    \"\"\"Splitting multi-trait GWAS Catalog studies.\"\"\"\n\n    @staticmethod\n    def _resolve_trait(\n        study_trait: Column, association_trait: Column, p_value_text: Column\n    ) -&gt; Column:\n        \"\"\"Resolve trait names by consolidating association-level and study-level trait names.\n\n        Args:\n            association_trait (Column): Association-level trait name.\n            study_trait (Column): Study-level trait name.\n            p_value_text (Column): P-value text.\n\n        Returns:\n            Column: Resolved trait name.\n        \"\"\"\n        return (\n            f.when(\n                (p_value_text.isNotNull()) &amp; (p_value_text != (\"no_pvalue_text\")),\n                f.concat(\n                    association_trait,\n                    f.lit(\" [\"),\n                    p_value_text,\n                    f.lit(\"]\"),\n                ),\n            )\n            .when(\n                association_trait.isNotNull(),\n                association_trait,\n            )\n            .otherwise(study_trait)\n        )\n\n    @staticmethod\n    def _resolve_efo(association_efo: Column, study_efo: Column) -&gt; Column:\n        \"\"\"Resolve EFOs by consolidating association-level and study-level EFOs.\n\n        Args:\n            association_efo (Column): EFO column from the association table.\n            study_efo (Column): EFO column from the study table.\n\n        Returns:\n            Column: Consolidated EFO column.\n        \"\"\"\n        return f.coalesce(f.split(association_efo, r\"\\/\"), study_efo)\n\n    @staticmethod\n    def _resolve_study_id(study_id: Column, sub_study_description: Column) -&gt; Column:\n        \"\"\"Resolve study IDs by exploding association-level information (e.g. pvalue_text, EFO).\n\n        Args:\n            study_id (Column): Study ID column.\n            sub_study_description (Column): Sub-study description column from the association table.\n\n        Returns:\n            Column: Resolved study ID column.\n        \"\"\"\n        split_w = Window.partitionBy(study_id).orderBy(sub_study_description)\n        row_number = f.dense_rank().over(split_w)\n        substudy_count = f.count(row_number).over(split_w)\n        return f.when(substudy_count == 1, study_id).otherwise(\n            f.concat_ws(\"_\", study_id, row_number)\n        )\n\n    @classmethod\n    def split(\n        cls: type[GWASCatalogStudySplitter],\n        studies: GWASCatalogStudyIndex,\n        associations: GWASCatalogAssociations,\n    ) -&gt; Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]:\n        \"\"\"Splitting multi-trait GWAS Catalog studies.\n\n        If assigned disease of the study and the association don't agree, we assume the study needs to be split.\n        Then disease EFOs, trait names and study ID are consolidated\n\n        Args:\n            studies (GWASCatalogStudyIndex): GWAS Catalog studies.\n            associations (StudyLocusGWASCatalog): GWAS Catalog associations.\n\n        Returns:\n            A tuple of the split associations and studies.\n        \"\"\"\n        # Composite of studies and associations to resolve scattered information\n        st_ass = (\n            associations.df.join(f.broadcast(studies.df), on=\"studyId\", how=\"inner\")\n            .select(\n                \"studyId\",\n                \"subStudyDescription\",\n                cls._resolve_study_id(\n                    f.col(\"studyId\"), f.col(\"subStudyDescription\")\n                ).alias(\"updatedStudyId\"),\n                cls._resolve_trait(\n                    f.col(\"traitFromSource\"),\n                    f.split(\"subStudyDescription\", r\"\\|\").getItem(0),\n                    f.split(\"subStudyDescription\", r\"\\|\").getItem(1),\n                ).alias(\"traitFromSource\"),\n                cls._resolve_efo(\n                    f.split(\"subStudyDescription\", r\"\\|\").getItem(2),\n                    f.col(\"traitFromSourceMappedIds\"),\n                ).alias(\"traitFromSourceMappedIds\"),\n            )\n            .persist()\n        )\n\n        return (\n            studies.update_study_id(\n                st_ass.select(\n                    \"studyId\",\n                    \"updatedStudyId\",\n                    \"traitFromSource\",\n                    \"traitFromSourceMappedIds\",\n                ).distinct()\n            ),\n            associations.update_study_id(\n                st_ass.select(\n                    \"updatedStudyId\", \"studyId\", \"subStudyDescription\"\n                ).distinct()\n            )._qc_ambiguous_study(),\n        )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/study_splitter/#otg.datasource.gwas_catalog.study_splitter.GWASCatalogStudySplitter.split","title":"<code>split(studies, associations)</code>  <code>classmethod</code>","text":"<p>Splitting multi-trait GWAS Catalog studies.</p> <p>If assigned disease of the study and the association don't agree, we assume the study needs to be split. Then disease EFOs, trait names and study ID are consolidated</p> <p>Parameters:</p> Name Type Description Default <code>studies</code> <code>GWASCatalogStudyIndex</code> <p>GWAS Catalog studies.</p> required <code>associations</code> <code>StudyLocusGWASCatalog</code> <p>GWAS Catalog associations.</p> required <p>Returns:</p> Type Description <code>Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]</code> <p>A tuple of the split associations and studies.</p> Source code in <code>src/otg/datasource/gwas_catalog/study_splitter.py</code> <pre><code>@classmethod\ndef split(\n    cls: type[GWASCatalogStudySplitter],\n    studies: GWASCatalogStudyIndex,\n    associations: GWASCatalogAssociations,\n) -&gt; Tuple[GWASCatalogStudyIndex, GWASCatalogAssociations]:\n    \"\"\"Splitting multi-trait GWAS Catalog studies.\n\n    If assigned disease of the study and the association don't agree, we assume the study needs to be split.\n    Then disease EFOs, trait names and study ID are consolidated\n\n    Args:\n        studies (GWASCatalogStudyIndex): GWAS Catalog studies.\n        associations (StudyLocusGWASCatalog): GWAS Catalog associations.\n\n    Returns:\n        A tuple of the split associations and studies.\n    \"\"\"\n    # Composite of studies and associations to resolve scattered information\n    st_ass = (\n        associations.df.join(f.broadcast(studies.df), on=\"studyId\", how=\"inner\")\n        .select(\n            \"studyId\",\n            \"subStudyDescription\",\n            cls._resolve_study_id(\n                f.col(\"studyId\"), f.col(\"subStudyDescription\")\n            ).alias(\"updatedStudyId\"),\n            cls._resolve_trait(\n                f.col(\"traitFromSource\"),\n                f.split(\"subStudyDescription\", r\"\\|\").getItem(0),\n                f.split(\"subStudyDescription\", r\"\\|\").getItem(1),\n            ).alias(\"traitFromSource\"),\n            cls._resolve_efo(\n                f.split(\"subStudyDescription\", r\"\\|\").getItem(2),\n                f.col(\"traitFromSourceMappedIds\"),\n            ).alias(\"traitFromSourceMappedIds\"),\n        )\n        .persist()\n    )\n\n    return (\n        studies.update_study_id(\n            st_ass.select(\n                \"studyId\",\n                \"updatedStudyId\",\n                \"traitFromSource\",\n                \"traitFromSourceMappedIds\",\n            ).distinct()\n        ),\n        associations.update_study_id(\n            st_ass.select(\n                \"updatedStudyId\", \"studyId\", \"subStudyDescription\"\n            ).distinct()\n        )._qc_ambiguous_study(),\n    )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/summary_statistics/","title":"Summary statistics","text":"<p>             Bases: <code>SummaryStatistics</code></p> <p>GWAS Catalog Summary Statistics reader.</p> Source code in <code>src/otg/datasource/gwas_catalog/summary_statistics.py</code> <pre><code>@dataclass\nclass GWASCatalogSummaryStatistics(SummaryStatistics):\n    \"\"\"GWAS Catalog Summary Statistics reader.\"\"\"\n\n    @classmethod\n    def from_gwas_harmonized_summary_stats(\n        cls: type[GWASCatalogSummaryStatistics],\n        sumstats_df: DataFrame,\n        study_id: str,\n    ) -&gt; GWASCatalogSummaryStatistics:\n        \"\"\"Create summary statistics object from summary statistics flatfile, harmonized by the GWAS Catalog.\n\n        Args:\n            sumstats_df (DataFrame): Harmonized dataset read as a spark dataframe from GWAS Catalog.\n            study_id (str): GWAS Catalog study accession.\n\n        Returns:\n            SummaryStatistics\n        \"\"\"\n        # The effect allele frequency is an optional column, we have to test if it is there:\n        allele_frequency_expression = (\n            f.col(\"hm_effect_allele_frequency\").cast(t.FloatType())\n            if \"hm_effect_allele_frequency\" in sumstats_df.columns\n            else f.lit(None)\n        )\n\n        # Processing columns of interest:\n        processed_sumstats_df = (\n            sumstats_df\n            # Dropping rows which doesn't have proper position:\n            .filter(f.col(\"hm_pos\").cast(t.IntegerType()).isNotNull())\n            .select(\n                # Adding study identifier:\n                f.lit(study_id).cast(t.StringType()).alias(\"studyId\"),\n                # Adding variant identifier:\n                f.col(\"hm_variant_id\").alias(\"variantId\"),\n                f.col(\"hm_chrom\").alias(\"chromosome\"),\n                f.col(\"hm_pos\").cast(t.IntegerType()).alias(\"position\"),\n                # Parsing p-value mantissa and exponent:\n                *parse_pvalue(f.col(\"p_value\")),\n                # Converting/calculating effect and confidence interval:\n                *convert_odds_ratio_to_beta(\n                    f.col(\"hm_beta\").cast(t.DoubleType()),\n                    f.col(\"hm_odds_ratio\").cast(t.DoubleType()),\n                    f.col(\"standard_error\").cast(t.DoubleType()),\n                ),\n                allele_frequency_expression.alias(\"effectAlleleFrequencyFromSource\"),\n            )\n            # The previous select expression generated the necessary fields for calculating the confidence intervals:\n            .select(\n                \"*\",\n                *calculate_confidence_interval(\n                    f.col(\"pValueMantissa\"),\n                    f.col(\"pValueExponent\"),\n                    f.col(\"beta\"),\n                    f.col(\"standardError\"),\n                ),\n            )\n            .repartition(200, \"chromosome\")\n            .sortWithinPartitions(\"position\")\n        )\n\n        # Initializing summary statistics object:\n        return cls(\n            _df=processed_sumstats_df,\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/gwas_catalog/summary_statistics/#otg.datasource.gwas_catalog.summary_statistics.GWASCatalogSummaryStatistics.from_gwas_harmonized_summary_stats","title":"<code>from_gwas_harmonized_summary_stats(sumstats_df, study_id)</code>  <code>classmethod</code>","text":"<p>Create summary statistics object from summary statistics flatfile, harmonized by the GWAS Catalog.</p> <p>Parameters:</p> Name Type Description Default <code>sumstats_df</code> <code>DataFrame</code> <p>Harmonized dataset read as a spark dataframe from GWAS Catalog.</p> required <code>study_id</code> <code>str</code> <p>GWAS Catalog study accession.</p> required <p>Returns:</p> Type Description <code>GWASCatalogSummaryStatistics</code> <p>SummaryStatistics</p> Source code in <code>src/otg/datasource/gwas_catalog/summary_statistics.py</code> <pre><code>@classmethod\ndef from_gwas_harmonized_summary_stats(\n    cls: type[GWASCatalogSummaryStatistics],\n    sumstats_df: DataFrame,\n    study_id: str,\n) -&gt; GWASCatalogSummaryStatistics:\n    \"\"\"Create summary statistics object from summary statistics flatfile, harmonized by the GWAS Catalog.\n\n    Args:\n        sumstats_df (DataFrame): Harmonized dataset read as a spark dataframe from GWAS Catalog.\n        study_id (str): GWAS Catalog study accession.\n\n    Returns:\n        SummaryStatistics\n    \"\"\"\n    # The effect allele frequency is an optional column, we have to test if it is there:\n    allele_frequency_expression = (\n        f.col(\"hm_effect_allele_frequency\").cast(t.FloatType())\n        if \"hm_effect_allele_frequency\" in sumstats_df.columns\n        else f.lit(None)\n    )\n\n    # Processing columns of interest:\n    processed_sumstats_df = (\n        sumstats_df\n        # Dropping rows which doesn't have proper position:\n        .filter(f.col(\"hm_pos\").cast(t.IntegerType()).isNotNull())\n        .select(\n            # Adding study identifier:\n            f.lit(study_id).cast(t.StringType()).alias(\"studyId\"),\n            # Adding variant identifier:\n            f.col(\"hm_variant_id\").alias(\"variantId\"),\n            f.col(\"hm_chrom\").alias(\"chromosome\"),\n            f.col(\"hm_pos\").cast(t.IntegerType()).alias(\"position\"),\n            # Parsing p-value mantissa and exponent:\n            *parse_pvalue(f.col(\"p_value\")),\n            # Converting/calculating effect and confidence interval:\n            *convert_odds_ratio_to_beta(\n                f.col(\"hm_beta\").cast(t.DoubleType()),\n                f.col(\"hm_odds_ratio\").cast(t.DoubleType()),\n                f.col(\"standard_error\").cast(t.DoubleType()),\n            ),\n            allele_frequency_expression.alias(\"effectAlleleFrequencyFromSource\"),\n        )\n        # The previous select expression generated the necessary fields for calculating the confidence intervals:\n        .select(\n            \"*\",\n            *calculate_confidence_interval(\n                f.col(\"pValueMantissa\"),\n                f.col(\"pValueExponent\"),\n                f.col(\"beta\"),\n                f.col(\"standardError\"),\n            ),\n        )\n        .repartition(200, \"chromosome\")\n        .sortWithinPartitions(\"position\")\n    )\n\n    # Initializing summary statistics object:\n    return cls(\n        _df=processed_sumstats_df,\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/_intervals/","title":"Chromatin intervals","text":""},{"location":"python_api/datasource/intervals/andersson/","title":"Andersson","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Andersson et al. 2014.</p> Source code in <code>src/otg/datasource/intervals/andersson.py</code> <pre><code>class IntervalsAndersson(Intervals):\n    \"\"\"Interval dataset from Andersson et al. 2014.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str):\n        \"\"\"Read andersson2014 dataset.\"\"\"\n        input_schema = t.StructType.fromJson(\n            json.loads(\n                pkg_resources.read_text(schemas, \"andersson2014.json\", encoding=\"utf-8\")\n            )\n        )\n        return (\n            spark.read.option(\"delimiter\", \"\\t\")\n            .option(\"mode\", \"DROPMALFORMED\")\n            .option(\"header\", \"true\")\n            .schema(input_schema)\n            .csv(path)\n        )\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsAndersson],\n        raw_anderson_df: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; Intervals:\n        \"\"\"Parse Andersson et al. 2014 dataset.\n\n        Args:\n            raw_anderson_df (DataFrame): Raw Andersson et al. dataset\n            gene_index (GeneIndex): Gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            Intervals: Intervals dataset\n        \"\"\"\n        # Constant values:\n        dataset_name = \"andersson2014\"\n        experiment_type = \"fantom5\"\n        pmid = \"24670763\"\n        bio_feature = \"aggregate\"\n        twosided_threshold = 2.45e6  # &lt;-  this needs to phased out. Filter by percentile instead of absolute value.\n\n        # Read the anderson file:\n        parsed_anderson_df = (\n            raw_anderson_df\n            # Parsing score column and casting as float:\n            .withColumn(\"score\", f.col(\"score\").cast(\"float\") / f.lit(1000))\n            # Parsing the 'name' column:\n            .withColumn(\"parsedName\", f.split(f.col(\"name\"), \";\"))\n            .withColumn(\"gene_symbol\", f.col(\"parsedName\")[2])\n            .withColumn(\"location\", f.col(\"parsedName\")[0])\n            .withColumn(\n                \"chrom\",\n                f.regexp_replace(f.split(f.col(\"location\"), \":|-\")[0], \"chr\", \"\"),\n            )\n            .withColumn(\n                \"start\", f.split(f.col(\"location\"), \":|-\")[1].cast(t.IntegerType())\n            )\n            .withColumn(\n                \"end\", f.split(f.col(\"location\"), \":|-\")[2].cast(t.IntegerType())\n            )\n            # Select relevant columns:\n            .select(\"chrom\", \"start\", \"end\", \"gene_symbol\", \"score\")\n            # Drop rows with non-canonical chromosomes:\n            .filter(\n                f.col(\"chrom\").isin([str(x) for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"])\n            )\n            # For each region/gene, keep only one row with the highest score:\n            .groupBy(\"chrom\", \"start\", \"end\", \"gene_symbol\")\n            .agg(f.max(\"score\").alias(\"resourceScore\"))\n            .orderBy(\"chrom\", \"start\")\n        )\n\n        return cls(\n            _df=(\n                # Lift over the intervals:\n                lift.convert_intervals(parsed_anderson_df, \"chrom\", \"start\", \"end\")\n                .drop(\"start\", \"end\")\n                .withColumnRenamed(\"mapped_start\", \"start\")\n                .withColumnRenamed(\"mapped_end\", \"end\")\n                .distinct()\n                # Joining with the gene index\n                .alias(\"intervals\")\n                .join(\n                    gene_index.symbols_lut().alias(\"genes\"),\n                    on=[\n                        f.col(\"intervals.gene_symbol\") == f.col(\"genes.geneSymbol\"),\n                        # Drop rows where the TSS is far from the start of the region\n                        f.abs(\n                            (f.col(\"intervals.start\") + f.col(\"intervals.end\")) / 2\n                            - f.col(\"tss\")\n                        )\n                        &lt;= twosided_threshold,\n                    ],\n                    how=\"left\",\n                )\n                # Select relevant columns:\n                .select(\n                    f.col(\"chrom\").alias(\"chromosome\"),\n                    f.col(\"intervals.start\").alias(\"start\"),\n                    f.col(\"intervals.end\").alias(\"end\"),\n                    \"geneId\",\n                    \"resourceScore\",\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                    f.lit(bio_feature).alias(\"biofeature\"),\n                )\n            ),\n            _schema=Intervals.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/andersson/#otg.datasource.intervals.andersson.IntervalsAndersson.parse","title":"<code>parse(raw_anderson_df, gene_index, lift)</code>  <code>classmethod</code>","text":"<p>Parse Andersson et al. 2014 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>raw_anderson_df</code> <code>DataFrame</code> <p>Raw Andersson et al. dataset</p> required <code>gene_index</code> <code>GeneIndex</code> <p>Gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>Intervals</code> <code>Intervals</code> <p>Intervals dataset</p> Source code in <code>src/otg/datasource/intervals/andersson.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsAndersson],\n    raw_anderson_df: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; Intervals:\n    \"\"\"Parse Andersson et al. 2014 dataset.\n\n    Args:\n        raw_anderson_df (DataFrame): Raw Andersson et al. dataset\n        gene_index (GeneIndex): Gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        Intervals: Intervals dataset\n    \"\"\"\n    # Constant values:\n    dataset_name = \"andersson2014\"\n    experiment_type = \"fantom5\"\n    pmid = \"24670763\"\n    bio_feature = \"aggregate\"\n    twosided_threshold = 2.45e6  # &lt;-  this needs to phased out. Filter by percentile instead of absolute value.\n\n    # Read the anderson file:\n    parsed_anderson_df = (\n        raw_anderson_df\n        # Parsing score column and casting as float:\n        .withColumn(\"score\", f.col(\"score\").cast(\"float\") / f.lit(1000))\n        # Parsing the 'name' column:\n        .withColumn(\"parsedName\", f.split(f.col(\"name\"), \";\"))\n        .withColumn(\"gene_symbol\", f.col(\"parsedName\")[2])\n        .withColumn(\"location\", f.col(\"parsedName\")[0])\n        .withColumn(\n            \"chrom\",\n            f.regexp_replace(f.split(f.col(\"location\"), \":|-\")[0], \"chr\", \"\"),\n        )\n        .withColumn(\n            \"start\", f.split(f.col(\"location\"), \":|-\")[1].cast(t.IntegerType())\n        )\n        .withColumn(\n            \"end\", f.split(f.col(\"location\"), \":|-\")[2].cast(t.IntegerType())\n        )\n        # Select relevant columns:\n        .select(\"chrom\", \"start\", \"end\", \"gene_symbol\", \"score\")\n        # Drop rows with non-canonical chromosomes:\n        .filter(\n            f.col(\"chrom\").isin([str(x) for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"])\n        )\n        # For each region/gene, keep only one row with the highest score:\n        .groupBy(\"chrom\", \"start\", \"end\", \"gene_symbol\")\n        .agg(f.max(\"score\").alias(\"resourceScore\"))\n        .orderBy(\"chrom\", \"start\")\n    )\n\n    return cls(\n        _df=(\n            # Lift over the intervals:\n            lift.convert_intervals(parsed_anderson_df, \"chrom\", \"start\", \"end\")\n            .drop(\"start\", \"end\")\n            .withColumnRenamed(\"mapped_start\", \"start\")\n            .withColumnRenamed(\"mapped_end\", \"end\")\n            .distinct()\n            # Joining with the gene index\n            .alias(\"intervals\")\n            .join(\n                gene_index.symbols_lut().alias(\"genes\"),\n                on=[\n                    f.col(\"intervals.gene_symbol\") == f.col(\"genes.geneSymbol\"),\n                    # Drop rows where the TSS is far from the start of the region\n                    f.abs(\n                        (f.col(\"intervals.start\") + f.col(\"intervals.end\")) / 2\n                        - f.col(\"tss\")\n                    )\n                    &lt;= twosided_threshold,\n                ],\n                how=\"left\",\n            )\n            # Select relevant columns:\n            .select(\n                f.col(\"chrom\").alias(\"chromosome\"),\n                f.col(\"intervals.start\").alias(\"start\"),\n                f.col(\"intervals.end\").alias(\"end\"),\n                \"geneId\",\n                \"resourceScore\",\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n                f.lit(bio_feature).alias(\"biofeature\"),\n            )\n        ),\n        _schema=Intervals.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/andersson/#otg.datasource.intervals.andersson.IntervalsAndersson.read","title":"<code>read(spark, path)</code>  <code>staticmethod</code>","text":"<p>Read andersson2014 dataset.</p> Source code in <code>src/otg/datasource/intervals/andersson.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str):\n    \"\"\"Read andersson2014 dataset.\"\"\"\n    input_schema = t.StructType.fromJson(\n        json.loads(\n            pkg_resources.read_text(schemas, \"andersson2014.json\", encoding=\"utf-8\")\n        )\n    )\n    return (\n        spark.read.option(\"delimiter\", \"\\t\")\n        .option(\"mode\", \"DROPMALFORMED\")\n        .option(\"header\", \"true\")\n        .schema(input_schema)\n        .csv(path)\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/javierre/","title":"Javierre","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Javierre et al. 2016.</p> Source code in <code>src/otg/datasource/intervals/javierre.py</code> <pre><code>class IntervalsJavierre(Intervals):\n    \"\"\"Interval dataset from Javierre et al. 2016.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str) -&gt; DataFrame:\n        \"\"\"Read Javierre dataset.\n\n        Args:\n            spark (SparkSession): Spark session\n            path (str): Path to dataset\n\n        Returns:\n            DataFrame: Raw Javierre dataset\n        \"\"\"\n        return spark.read.parquet(path)\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsJavierre],\n        javierre_raw: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; Intervals:\n        \"\"\"Parse Javierre et al. 2016 dataset.\n\n        Args:\n            javierre_raw (DataFrame): Raw Javierre data\n            gene_index (GeneIndex): Gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            Intervals: Javierre et al. 2016 interval data\n        \"\"\"\n        # Constant values:\n        dataset_name = \"javierre2016\"\n        experiment_type = \"pchic\"\n        pmid = \"27863249\"\n        twosided_threshold = 2.45e6\n\n        # Read Javierre data:\n        javierre_parsed = (\n            javierre_raw\n            # Splitting name column into chromosome, start, end, and score:\n            .withColumn(\"name_split\", f.split(f.col(\"name\"), r\":|-|,\"))\n            .withColumn(\n                \"name_chr\",\n                f.regexp_replace(f.col(\"name_split\")[0], \"chr\", \"\").cast(\n                    t.StringType()\n                ),\n            )\n            .withColumn(\"name_start\", f.col(\"name_split\")[1].cast(t.IntegerType()))\n            .withColumn(\"name_end\", f.col(\"name_split\")[2].cast(t.IntegerType()))\n            .withColumn(\"name_score\", f.col(\"name_split\")[3].cast(t.FloatType()))\n            # Cleaning up chromosome:\n            .withColumn(\n                \"chrom\",\n                f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").cast(t.StringType()),\n            )\n            .drop(\"name_split\", \"name\", \"annotation\")\n            # Keep canonical chromosomes and consistent chromosomes with scores:\n            .filter(\n                (f.col(\"name_score\").isNotNull())\n                &amp; (f.col(\"chrom\") == f.col(\"name_chr\"))\n                &amp; f.col(\"name_chr\").isin(\n                    [f\"{x}\" for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"]\n                )\n            )\n        )\n\n        # Lifting over intervals:\n        javierre_remapped = (\n            javierre_parsed\n            # Lifting over to GRCh38 interval 1:\n            .transform(lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\"))\n            .drop(\"start\", \"end\")\n            .withColumnRenamed(\"mapped_chrom\", \"chrom\")\n            .withColumnRenamed(\"mapped_start\", \"start\")\n            .withColumnRenamed(\"mapped_end\", \"end\")\n            # Lifting over interval 2 to GRCh38:\n            .transform(\n                lambda df: lift.convert_intervals(\n                    df, \"name_chr\", \"name_start\", \"name_end\"\n                )\n            )\n            .drop(\"name_start\", \"name_end\")\n            .withColumnRenamed(\"mapped_name_chr\", \"name_chr\")\n            .withColumnRenamed(\"mapped_name_start\", \"name_start\")\n            .withColumnRenamed(\"mapped_name_end\", \"name_end\")\n        )\n\n        # Once the intervals are lifted, extracting the unique intervals:\n        unique_intervals_with_genes = (\n            javierre_remapped.select(\n                f.col(\"chrom\"),\n                f.col(\"start\").cast(t.IntegerType()),\n                f.col(\"end\").cast(t.IntegerType()),\n            )\n            .distinct()\n            .alias(\"intervals\")\n            .join(\n                gene_index.locations_lut().alias(\"genes\"),\n                on=[\n                    f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                    (\n                        (f.col(\"intervals.start\") &gt;= f.col(\"genes.start\"))\n                        &amp; (f.col(\"intervals.start\") &lt;= f.col(\"genes.end\"))\n                    )\n                    | (\n                        (f.col(\"intervals.end\") &gt;= f.col(\"genes.start\"))\n                        &amp; (f.col(\"intervals.end\") &lt;= f.col(\"genes.end\"))\n                    ),\n                ],\n                how=\"left\",\n            )\n            .select(\n                f.col(\"intervals.chrom\").alias(\"chrom\"),\n                f.col(\"intervals.start\").alias(\"start\"),\n                f.col(\"intervals.end\").alias(\"end\"),\n                f.col(\"genes.geneId\").alias(\"geneId\"),\n                f.col(\"genes.tss\").alias(\"tss\"),\n            )\n        )\n\n        # Joining back the data:\n        return cls(\n            _df=(\n                javierre_remapped.join(\n                    unique_intervals_with_genes,\n                    on=[\"chrom\", \"start\", \"end\"],\n                    how=\"left\",\n                )\n                .filter(\n                    # Drop rows where the TSS is far from the start of the region\n                    f.abs((f.col(\"start\") + f.col(\"end\")) / 2 - f.col(\"tss\"))\n                    &lt;= twosided_threshold\n                )\n                # For each gene, keep only the highest scoring interval:\n                .groupBy(\"name_chr\", \"name_start\", \"name_end\", \"geneId\", \"bio_feature\")\n                .agg(f.max(f.col(\"name_score\")).alias(\"resourceScore\"))\n                # Create the output:\n                .select(\n                    f.col(\"name_chr\").alias(\"chromosome\"),\n                    f.col(\"name_start\").alias(\"start\"),\n                    f.col(\"name_end\").alias(\"end\"),\n                    f.col(\"resourceScore\").cast(t.DoubleType()),\n                    f.col(\"geneId\"),\n                    f.col(\"bio_feature\").alias(\"biofeature\"),\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                )\n            ),\n            _schema=Intervals.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/javierre/#otg.datasource.intervals.javierre.IntervalsJavierre.parse","title":"<code>parse(javierre_raw, gene_index, lift)</code>  <code>classmethod</code>","text":"<p>Parse Javierre et al. 2016 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>javierre_raw</code> <code>DataFrame</code> <p>Raw Javierre data</p> required <code>gene_index</code> <code>GeneIndex</code> <p>Gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>Intervals</code> <code>Intervals</code> <p>Javierre et al. 2016 interval data</p> Source code in <code>src/otg/datasource/intervals/javierre.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsJavierre],\n    javierre_raw: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; Intervals:\n    \"\"\"Parse Javierre et al. 2016 dataset.\n\n    Args:\n        javierre_raw (DataFrame): Raw Javierre data\n        gene_index (GeneIndex): Gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        Intervals: Javierre et al. 2016 interval data\n    \"\"\"\n    # Constant values:\n    dataset_name = \"javierre2016\"\n    experiment_type = \"pchic\"\n    pmid = \"27863249\"\n    twosided_threshold = 2.45e6\n\n    # Read Javierre data:\n    javierre_parsed = (\n        javierre_raw\n        # Splitting name column into chromosome, start, end, and score:\n        .withColumn(\"name_split\", f.split(f.col(\"name\"), r\":|-|,\"))\n        .withColumn(\n            \"name_chr\",\n            f.regexp_replace(f.col(\"name_split\")[0], \"chr\", \"\").cast(\n                t.StringType()\n            ),\n        )\n        .withColumn(\"name_start\", f.col(\"name_split\")[1].cast(t.IntegerType()))\n        .withColumn(\"name_end\", f.col(\"name_split\")[2].cast(t.IntegerType()))\n        .withColumn(\"name_score\", f.col(\"name_split\")[3].cast(t.FloatType()))\n        # Cleaning up chromosome:\n        .withColumn(\n            \"chrom\",\n            f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").cast(t.StringType()),\n        )\n        .drop(\"name_split\", \"name\", \"annotation\")\n        # Keep canonical chromosomes and consistent chromosomes with scores:\n        .filter(\n            (f.col(\"name_score\").isNotNull())\n            &amp; (f.col(\"chrom\") == f.col(\"name_chr\"))\n            &amp; f.col(\"name_chr\").isin(\n                [f\"{x}\" for x in range(1, 23)] + [\"X\", \"Y\", \"MT\"]\n            )\n        )\n    )\n\n    # Lifting over intervals:\n    javierre_remapped = (\n        javierre_parsed\n        # Lifting over to GRCh38 interval 1:\n        .transform(lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\"))\n        .drop(\"start\", \"end\")\n        .withColumnRenamed(\"mapped_chrom\", \"chrom\")\n        .withColumnRenamed(\"mapped_start\", \"start\")\n        .withColumnRenamed(\"mapped_end\", \"end\")\n        # Lifting over interval 2 to GRCh38:\n        .transform(\n            lambda df: lift.convert_intervals(\n                df, \"name_chr\", \"name_start\", \"name_end\"\n            )\n        )\n        .drop(\"name_start\", \"name_end\")\n        .withColumnRenamed(\"mapped_name_chr\", \"name_chr\")\n        .withColumnRenamed(\"mapped_name_start\", \"name_start\")\n        .withColumnRenamed(\"mapped_name_end\", \"name_end\")\n    )\n\n    # Once the intervals are lifted, extracting the unique intervals:\n    unique_intervals_with_genes = (\n        javierre_remapped.select(\n            f.col(\"chrom\"),\n            f.col(\"start\").cast(t.IntegerType()),\n            f.col(\"end\").cast(t.IntegerType()),\n        )\n        .distinct()\n        .alias(\"intervals\")\n        .join(\n            gene_index.locations_lut().alias(\"genes\"),\n            on=[\n                f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                (\n                    (f.col(\"intervals.start\") &gt;= f.col(\"genes.start\"))\n                    &amp; (f.col(\"intervals.start\") &lt;= f.col(\"genes.end\"))\n                )\n                | (\n                    (f.col(\"intervals.end\") &gt;= f.col(\"genes.start\"))\n                    &amp; (f.col(\"intervals.end\") &lt;= f.col(\"genes.end\"))\n                ),\n            ],\n            how=\"left\",\n        )\n        .select(\n            f.col(\"intervals.chrom\").alias(\"chrom\"),\n            f.col(\"intervals.start\").alias(\"start\"),\n            f.col(\"intervals.end\").alias(\"end\"),\n            f.col(\"genes.geneId\").alias(\"geneId\"),\n            f.col(\"genes.tss\").alias(\"tss\"),\n        )\n    )\n\n    # Joining back the data:\n    return cls(\n        _df=(\n            javierre_remapped.join(\n                unique_intervals_with_genes,\n                on=[\"chrom\", \"start\", \"end\"],\n                how=\"left\",\n            )\n            .filter(\n                # Drop rows where the TSS is far from the start of the region\n                f.abs((f.col(\"start\") + f.col(\"end\")) / 2 - f.col(\"tss\"))\n                &lt;= twosided_threshold\n            )\n            # For each gene, keep only the highest scoring interval:\n            .groupBy(\"name_chr\", \"name_start\", \"name_end\", \"geneId\", \"bio_feature\")\n            .agg(f.max(f.col(\"name_score\")).alias(\"resourceScore\"))\n            # Create the output:\n            .select(\n                f.col(\"name_chr\").alias(\"chromosome\"),\n                f.col(\"name_start\").alias(\"start\"),\n                f.col(\"name_end\").alias(\"end\"),\n                f.col(\"resourceScore\").cast(t.DoubleType()),\n                f.col(\"geneId\"),\n                f.col(\"bio_feature\").alias(\"biofeature\"),\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n            )\n        ),\n        _schema=Intervals.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/javierre/#otg.datasource.intervals.javierre.IntervalsJavierre.read","title":"<code>read(spark, path)</code>  <code>staticmethod</code>","text":"<p>Read Javierre dataset.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to dataset</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Raw Javierre dataset</p> Source code in <code>src/otg/datasource/intervals/javierre.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str) -&gt; DataFrame:\n    \"\"\"Read Javierre dataset.\n\n    Args:\n        spark (SparkSession): Spark session\n        path (str): Path to dataset\n\n    Returns:\n        DataFrame: Raw Javierre dataset\n    \"\"\"\n    return spark.read.parquet(path)\n</code></pre>"},{"location":"python_api/datasource/intervals/jung/","title":"Jung","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Jung et al. 2019.</p> Source code in <code>src/otg/datasource/intervals/jung.py</code> <pre><code>class IntervalsJung(Intervals):\n    \"\"\"Interval dataset from Jung et al. 2019.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str) -&gt; DataFrame:\n        \"\"\"Read jung dataset.\n\n        Args:\n            spark (SparkSession): Spark session\n            path (str): Path to dataset\n\n        Returns:\n            DataFrame: DataFrame with raw jung data\n        \"\"\"\n        return spark.read.csv(path, sep=\",\", header=True)\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsJung],\n        jung_raw: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; Intervals:\n        \"\"\"Parse the Jung et al. 2019 dataset.\n\n        Args:\n            jung_raw (DataFrame): raw Jung et al. 2019 dataset\n            gene_index (GeneIndex): gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            Intervals: Interval dataset containing Jung et al. 2019 data\n        \"\"\"\n        dataset_name = \"jung2019\"\n        experiment_type = \"pchic\"\n        pmid = \"31501517\"\n\n        # Lifting over the coordinates:\n        return cls(\n            _df=(\n                jung_raw.withColumn(\n                    \"interval\", f.split(f.col(\"Interacting_fragment\"), r\"\\.\")\n                )\n                .select(\n                    # Parsing intervals:\n                    f.regexp_replace(f.col(\"interval\")[0], \"chr\", \"\").alias(\"chrom\"),\n                    f.col(\"interval\")[1].cast(t.IntegerType()).alias(\"start\"),\n                    f.col(\"interval\")[2].cast(t.IntegerType()).alias(\"end\"),\n                    # Extract other columns:\n                    f.col(\"Promoter\").alias(\"gene_name\"),\n                    f.col(\"Tissue_type\").alias(\"tissue\"),\n                )\n                # Lifting over to GRCh38 interval 1:\n                .transform(\n                    lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n                )\n                .select(\n                    \"chrom\",\n                    f.col(\"mapped_start\").alias(\"start\"),\n                    f.col(\"mapped_end\").alias(\"end\"),\n                    f.explode(f.split(f.col(\"gene_name\"), \";\")).alias(\"gene_name\"),\n                    \"tissue\",\n                )\n                .alias(\"intervals\")\n                # Joining with genes:\n                .join(\n                    gene_index.symbols_lut().alias(\"genes\"),\n                    on=[f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\")],\n                    how=\"inner\",\n                )\n                # Finalize dataset:\n                .select(\n                    \"chromosome\",\n                    f.col(\"intervals.start\").alias(\"start\"),\n                    f.col(\"intervals.end\").alias(\"end\"),\n                    \"geneId\",\n                    f.col(\"tissue\").alias(\"biofeature\"),\n                    f.lit(1.0).alias(\"score\"),\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                )\n                .drop_duplicates()\n            ),\n            _schema=Intervals.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/jung/#otg.datasource.intervals.jung.IntervalsJung.parse","title":"<code>parse(jung_raw, gene_index, lift)</code>  <code>classmethod</code>","text":"<p>Parse the Jung et al. 2019 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>jung_raw</code> <code>DataFrame</code> <p>raw Jung et al. 2019 dataset</p> required <code>gene_index</code> <code>GeneIndex</code> <p>gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>Intervals</code> <code>Intervals</code> <p>Interval dataset containing Jung et al. 2019 data</p> Source code in <code>src/otg/datasource/intervals/jung.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsJung],\n    jung_raw: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; Intervals:\n    \"\"\"Parse the Jung et al. 2019 dataset.\n\n    Args:\n        jung_raw (DataFrame): raw Jung et al. 2019 dataset\n        gene_index (GeneIndex): gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        Intervals: Interval dataset containing Jung et al. 2019 data\n    \"\"\"\n    dataset_name = \"jung2019\"\n    experiment_type = \"pchic\"\n    pmid = \"31501517\"\n\n    # Lifting over the coordinates:\n    return cls(\n        _df=(\n            jung_raw.withColumn(\n                \"interval\", f.split(f.col(\"Interacting_fragment\"), r\"\\.\")\n            )\n            .select(\n                # Parsing intervals:\n                f.regexp_replace(f.col(\"interval\")[0], \"chr\", \"\").alias(\"chrom\"),\n                f.col(\"interval\")[1].cast(t.IntegerType()).alias(\"start\"),\n                f.col(\"interval\")[2].cast(t.IntegerType()).alias(\"end\"),\n                # Extract other columns:\n                f.col(\"Promoter\").alias(\"gene_name\"),\n                f.col(\"Tissue_type\").alias(\"tissue\"),\n            )\n            # Lifting over to GRCh38 interval 1:\n            .transform(\n                lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n            )\n            .select(\n                \"chrom\",\n                f.col(\"mapped_start\").alias(\"start\"),\n                f.col(\"mapped_end\").alias(\"end\"),\n                f.explode(f.split(f.col(\"gene_name\"), \";\")).alias(\"gene_name\"),\n                \"tissue\",\n            )\n            .alias(\"intervals\")\n            # Joining with genes:\n            .join(\n                gene_index.symbols_lut().alias(\"genes\"),\n                on=[f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\")],\n                how=\"inner\",\n            )\n            # Finalize dataset:\n            .select(\n                \"chromosome\",\n                f.col(\"intervals.start\").alias(\"start\"),\n                f.col(\"intervals.end\").alias(\"end\"),\n                \"geneId\",\n                f.col(\"tissue\").alias(\"biofeature\"),\n                f.lit(1.0).alias(\"score\"),\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n            )\n            .drop_duplicates()\n        ),\n        _schema=Intervals.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/jung/#otg.datasource.intervals.jung.IntervalsJung.read","title":"<code>read(spark, path)</code>  <code>staticmethod</code>","text":"<p>Read jung dataset.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to dataset</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>DataFrame with raw jung data</p> Source code in <code>src/otg/datasource/intervals/jung.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str) -&gt; DataFrame:\n    \"\"\"Read jung dataset.\n\n    Args:\n        spark (SparkSession): Spark session\n        path (str): Path to dataset\n\n    Returns:\n        DataFrame: DataFrame with raw jung data\n    \"\"\"\n    return spark.read.csv(path, sep=\",\", header=True)\n</code></pre>"},{"location":"python_api/datasource/intervals/thurman/","title":"Thurman","text":"<p>             Bases: <code>Intervals</code></p> <p>Interval dataset from Thurman et al. 2012.</p> Source code in <code>src/otg/datasource/intervals/thurman.py</code> <pre><code>class IntervalsThurman(Intervals):\n    \"\"\"Interval dataset from Thurman et al. 2012.\"\"\"\n\n    @staticmethod\n    def read(spark: SparkSession, path: str) -&gt; DataFrame:\n        \"\"\"Read thurman dataset.\n\n        Args:\n            spark (SparkSession): Spark session\n            path (str): Path to dataset\n\n        Returns:\n            DataFrame: DataFrame with raw thurman data\n        \"\"\"\n        thurman_schema = t.StructType(\n            [\n                t.StructField(\"gene_chr\", t.StringType(), False),\n                t.StructField(\"gene_start\", t.IntegerType(), False),\n                t.StructField(\"gene_end\", t.IntegerType(), False),\n                t.StructField(\"gene_name\", t.StringType(), False),\n                t.StructField(\"chrom\", t.StringType(), False),\n                t.StructField(\"start\", t.IntegerType(), False),\n                t.StructField(\"end\", t.IntegerType(), False),\n                t.StructField(\"score\", t.FloatType(), False),\n            ]\n        )\n        return spark.read.csv(path, sep=\"\\t\", header=True, schema=thurman_schema)\n\n    @classmethod\n    def parse(\n        cls: type[IntervalsThurman],\n        thurman_raw: DataFrame,\n        gene_index: GeneIndex,\n        lift: LiftOverSpark,\n    ) -&gt; Intervals:\n        \"\"\"Parse the Thurman et al. 2012 dataset.\n\n        Args:\n            thurman_raw (DataFrame): raw Thurman et al. 2019 dataset\n            gene_index (GeneIndex): gene index\n            lift (LiftOverSpark): LiftOverSpark instance\n\n        Returns:\n            Intervals: Interval dataset containing Thurman et al. 2012 data\n        \"\"\"\n        dataset_name = \"thurman2012\"\n        experiment_type = \"dhscor\"\n        pmid = \"22955617\"\n\n        return cls(\n            _df=(\n                thurman_raw.select(\n                    f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").alias(\"chrom\"),\n                    \"start\",\n                    \"end\",\n                    \"gene_name\",\n                    \"score\",\n                )\n                # Lift over to the GRCh38 build:\n                .transform(\n                    lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n                )\n                .alias(\"intervals\")\n                # Map gene names to gene IDs:\n                .join(\n                    gene_index.symbols_lut().alias(\"genes\"),\n                    on=[\n                        f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\"),\n                        f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                    ],\n                    how=\"inner\",\n                )\n                # Select relevant columns and add constant columns:\n                .select(\n                    f.col(\"chrom\").alias(\"chromosome\"),\n                    f.col(\"mapped_start\").alias(\"start\"),\n                    f.col(\"mapped_end\").alias(\"end\"),\n                    \"geneId\",\n                    f.col(\"score\").cast(t.DoubleType()).alias(\"resourceScore\"),\n                    f.lit(dataset_name).alias(\"datasourceId\"),\n                    f.lit(experiment_type).alias(\"datatypeId\"),\n                    f.lit(pmid).alias(\"pmid\"),\n                )\n                .distinct()\n            ),\n            _schema=cls.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/intervals/thurman/#otg.datasource.intervals.thurman.IntervalsThurman.parse","title":"<code>parse(thurman_raw, gene_index, lift)</code>  <code>classmethod</code>","text":"<p>Parse the Thurman et al. 2012 dataset.</p> <p>Parameters:</p> Name Type Description Default <code>thurman_raw</code> <code>DataFrame</code> <p>raw Thurman et al. 2019 dataset</p> required <code>gene_index</code> <code>GeneIndex</code> <p>gene index</p> required <code>lift</code> <code>LiftOverSpark</code> <p>LiftOverSpark instance</p> required <p>Returns:</p> Name Type Description <code>Intervals</code> <code>Intervals</code> <p>Interval dataset containing Thurman et al. 2012 data</p> Source code in <code>src/otg/datasource/intervals/thurman.py</code> <pre><code>@classmethod\ndef parse(\n    cls: type[IntervalsThurman],\n    thurman_raw: DataFrame,\n    gene_index: GeneIndex,\n    lift: LiftOverSpark,\n) -&gt; Intervals:\n    \"\"\"Parse the Thurman et al. 2012 dataset.\n\n    Args:\n        thurman_raw (DataFrame): raw Thurman et al. 2019 dataset\n        gene_index (GeneIndex): gene index\n        lift (LiftOverSpark): LiftOverSpark instance\n\n    Returns:\n        Intervals: Interval dataset containing Thurman et al. 2012 data\n    \"\"\"\n    dataset_name = \"thurman2012\"\n    experiment_type = \"dhscor\"\n    pmid = \"22955617\"\n\n    return cls(\n        _df=(\n            thurman_raw.select(\n                f.regexp_replace(f.col(\"chrom\"), \"chr\", \"\").alias(\"chrom\"),\n                \"start\",\n                \"end\",\n                \"gene_name\",\n                \"score\",\n            )\n            # Lift over to the GRCh38 build:\n            .transform(\n                lambda df: lift.convert_intervals(df, \"chrom\", \"start\", \"end\")\n            )\n            .alias(\"intervals\")\n            # Map gene names to gene IDs:\n            .join(\n                gene_index.symbols_lut().alias(\"genes\"),\n                on=[\n                    f.col(\"intervals.gene_name\") == f.col(\"genes.geneSymbol\"),\n                    f.col(\"intervals.chrom\") == f.col(\"genes.chromosome\"),\n                ],\n                how=\"inner\",\n            )\n            # Select relevant columns and add constant columns:\n            .select(\n                f.col(\"chrom\").alias(\"chromosome\"),\n                f.col(\"mapped_start\").alias(\"start\"),\n                f.col(\"mapped_end\").alias(\"end\"),\n                \"geneId\",\n                f.col(\"score\").cast(t.DoubleType()).alias(\"resourceScore\"),\n                f.lit(dataset_name).alias(\"datasourceId\"),\n                f.lit(experiment_type).alias(\"datatypeId\"),\n                f.lit(pmid).alias(\"pmid\"),\n            )\n            .distinct()\n        ),\n        _schema=cls.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/intervals/thurman/#otg.datasource.intervals.thurman.IntervalsThurman.read","title":"<code>read(spark, path)</code>  <code>staticmethod</code>","text":"<p>Read thurman dataset.</p> <p>Parameters:</p> Name Type Description Default <code>spark</code> <code>SparkSession</code> <p>Spark session</p> required <code>path</code> <code>str</code> <p>Path to dataset</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>DataFrame with raw thurman data</p> Source code in <code>src/otg/datasource/intervals/thurman.py</code> <pre><code>@staticmethod\ndef read(spark: SparkSession, path: str) -&gt; DataFrame:\n    \"\"\"Read thurman dataset.\n\n    Args:\n        spark (SparkSession): Spark session\n        path (str): Path to dataset\n\n    Returns:\n        DataFrame: DataFrame with raw thurman data\n    \"\"\"\n    thurman_schema = t.StructType(\n        [\n            t.StructField(\"gene_chr\", t.StringType(), False),\n            t.StructField(\"gene_start\", t.IntegerType(), False),\n            t.StructField(\"gene_end\", t.IntegerType(), False),\n            t.StructField(\"gene_name\", t.StringType(), False),\n            t.StructField(\"chrom\", t.StringType(), False),\n            t.StructField(\"start\", t.IntegerType(), False),\n            t.StructField(\"end\", t.IntegerType(), False),\n            t.StructField(\"score\", t.FloatType(), False),\n        ]\n    )\n    return spark.read.csv(path, sep=\"\\t\", header=True, schema=thurman_schema)\n</code></pre>"},{"location":"python_api/datasource/open_targets/_open_targets/","title":"Open targets","text":"<p>The Open Targets Platform is a comprehensive resource that aims to aggregate and harmonise various types of data to facilitate the identification, prioritisation, and validation of drug targets. By integrating publicly available datasets including data generated by the Open Targets consortium, the Platform builds and scores target-disease associations to assist in drug target identification and prioritisation. It also integrates relevant annotation information about targets, diseases, phenotypes, and drugs, as well as their most relevant relationships.</p> <p>Genomic data from Open Targets integrates human genome-wide association studies (GWAS) and functional genomics data including gene expression, protein abundance, chromatin interaction and conformation data from a wide range of cell types and tissues to make robust connections between GWAS-associated loci, variants and likely causal genes.</p>"},{"location":"python_api/datasource/open_targets/target/","title":"Target","text":"<p>Parser for OTPlatform target dataset.</p> <p>Genomic data from Open Targets provides gene identification and genomic coordinates that are integrated into the gene index of our ETL pipeline.</p> <p>The EMBL-EBI Ensembl database is used as a source for human targets in the Platform, with the Ensembl gene ID as the primary identifier. The criteria for target inclusion is: - Genes from all biotypes encoded in canonical chromosomes - Genes in alternative assemblies encoding for a reviewed protein product.</p> Source code in <code>src/otg/datasource/open_targets/target.py</code> <pre><code>class OpenTargetsTarget:\n    \"\"\"Parser for OTPlatform target dataset.\n\n    Genomic data from Open Targets provides gene identification and genomic coordinates that are integrated into the gene index of our ETL pipeline.\n\n    The EMBL-EBI Ensembl database is used as a source for human targets in the Platform, with the Ensembl gene ID as the primary identifier. The criteria for target inclusion is:\n    - Genes from all biotypes encoded in canonical chromosomes\n    - Genes in alternative assemblies encoding for a reviewed protein product.\n    \"\"\"\n\n    @staticmethod\n    def _get_gene_tss(strand_col: Column, start_col: Column, end_col: Column) -&gt; Column:\n        \"\"\"Returns the TSS of a gene based on its orientation.\n\n        Args:\n            strand_col (Column): Column containing 1 if the coding strand of the gene is forward, and -1 if it is reverse.\n            start_col (Column): Column containing the start position of the gene.\n            end_col (Column): Column containing the end position of the gene.\n\n        Returns:\n            Column: Column containing the TSS of the gene.\n\n        Examples:\n            &gt;&gt;&gt; df = spark.createDataFrame([{\"strand\": 1, \"start\": 100, \"end\": 200}, {\"strand\": -1, \"start\": 100, \"end\": 200}])\n            &gt;&gt;&gt; df.withColumn(\"tss\", OpenTargetsTarget._get_gene_tss(f.col(\"strand\"), f.col(\"start\"), f.col(\"end\"))).show()\n            +---+-----+------+---+\n            |end|start|strand|tss|\n            +---+-----+------+---+\n            |200|  100|     1|100|\n            |200|  100|    -1|200|\n            +---+-----+------+---+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return f.when(strand_col == 1, start_col).when(strand_col == -1, end_col)\n\n    @classmethod\n    def as_gene_index(cls: type[GeneIndex], target_index: DataFrame) -&gt; GeneIndex:\n        \"\"\"Initialise GeneIndex from source dataset.\n\n        Args:\n            target_index (DataFrame): Target index dataframe\n\n        Returns:\n            GeneIndex: Gene index dataset\n        \"\"\"\n        return GeneIndex(\n            _df=target_index.select(\n                f.coalesce(f.col(\"id\"), f.lit(\"unknown\")).alias(\"geneId\"),\n                \"approvedSymbol\",\n                \"approvedName\",\n                \"biotype\",\n                f.col(\"obsoleteSymbols.label\").alias(\"obsoleteSymbols\"),\n                f.coalesce(f.col(\"genomicLocation.chromosome\"), f.lit(\"unknown\")).alias(\n                    \"chromosome\"\n                ),\n                OpenTargetsTarget._get_gene_tss(\n                    f.col(\"genomicLocation.strand\"),\n                    f.col(\"genomicLocation.start\"),\n                    f.col(\"genomicLocation.end\"),\n                ).alias(\"tss\"),\n                f.col(\"genomicLocation.start\").alias(\"start\"),\n                f.col(\"genomicLocation.end\").alias(\"end\"),\n                f.col(\"genomicLocation.strand\").alias(\"strand\"),\n            ),\n            _schema=GeneIndex.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/open_targets/target/#otg.datasource.open_targets.target.OpenTargetsTarget.as_gene_index","title":"<code>as_gene_index(target_index)</code>  <code>classmethod</code>","text":"<p>Initialise GeneIndex from source dataset.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>DataFrame</code> <p>Target index dataframe</p> required <p>Returns:</p> Name Type Description <code>GeneIndex</code> <code>GeneIndex</code> <p>Gene index dataset</p> Source code in <code>src/otg/datasource/open_targets/target.py</code> <pre><code>@classmethod\ndef as_gene_index(cls: type[GeneIndex], target_index: DataFrame) -&gt; GeneIndex:\n    \"\"\"Initialise GeneIndex from source dataset.\n\n    Args:\n        target_index (DataFrame): Target index dataframe\n\n    Returns:\n        GeneIndex: Gene index dataset\n    \"\"\"\n    return GeneIndex(\n        _df=target_index.select(\n            f.coalesce(f.col(\"id\"), f.lit(\"unknown\")).alias(\"geneId\"),\n            \"approvedSymbol\",\n            \"approvedName\",\n            \"biotype\",\n            f.col(\"obsoleteSymbols.label\").alias(\"obsoleteSymbols\"),\n            f.coalesce(f.col(\"genomicLocation.chromosome\"), f.lit(\"unknown\")).alias(\n                \"chromosome\"\n            ),\n            OpenTargetsTarget._get_gene_tss(\n                f.col(\"genomicLocation.strand\"),\n                f.col(\"genomicLocation.start\"),\n                f.col(\"genomicLocation.end\"),\n            ).alias(\"tss\"),\n            f.col(\"genomicLocation.start\").alias(\"start\"),\n            f.col(\"genomicLocation.end\").alias(\"end\"),\n            f.col(\"genomicLocation.strand\").alias(\"strand\"),\n        ),\n        _schema=GeneIndex.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/datasource/ukbiobank/_ukbiobank/","title":"Ukbiobank","text":"<p>The UK Biobank is a large-scale biomedical database and research resource that contains a diverse range of in-depth information from 500,000 volunteers in the United Kingdom. Its genomic data comprises whole-genome sequencing for a subset of participants, along with genotyping arrays for the entire cohort. The data has been a cornerstone for numerous genome-wide association studies (GWAS) and other genetic analyses, advancing our understanding of human health and disease.</p> <p>Recent efforts to rapidly and systematically apply established GWAS methods to all available data fields in UK Biobank have made available large repositories of summary statistics. To leverage these data disease locus discovery, we used full summary statistics from: The Neale lab Round 2 (N=2139). - These analyses applied GWAS (implemented in Hail) to all data fields using imputed genotypes from HRC as released by UK Biobank in May 2017, consisting of 337,199 individuals post-QC. Full details of the Neale lab GWAS implementation are available here. We have remove all ICD-10 related traits from the Neale data to reduce overlap with the SAIGE results. - http://www.nealelab.is/uk-biobank/ The University of Michigan SAIGE analysis (N=1281). - The SAIGE analysis uses PheCode derived phenotypes and applies a new method that \"provides accurate P values even when case-control ratios are extremely unbalanced\". See Zhou et al. (2018) for further details. - https://pubmed.ncbi.nlm.nih.gov/30104761/</p>"},{"location":"python_api/datasource/ukbiobank/study_index/","title":"Study index","text":"<p>             Bases: <code>StudyIndex</code></p> <p>Study index dataset from UKBiobank.</p> <p>The following information is extracted:</p> <ul> <li>studyId</li> <li>pubmedId</li> <li>publicationDate</li> <li>publicationJournal</li> <li>publicationTitle</li> <li>publicationFirstAuthor</li> <li>traitFromSource</li> <li>ancestry_discoverySamples</li> <li>ancestry_replicationSamples</li> <li>initialSampleSize</li> <li>nCases</li> <li>replicationSamples</li> </ul> <p>Some fields are populated as constants, such as projectID, studyType, and initial sample size.</p> Source code in <code>src/otg/datasource/ukbiobank/study_index.py</code> <pre><code>class UKBiobankStudyIndex(StudyIndex):\n    \"\"\"Study index dataset from UKBiobank.\n\n    The following information is extracted:\n\n    - studyId\n    - pubmedId\n    - publicationDate\n    - publicationJournal\n    - publicationTitle\n    - publicationFirstAuthor\n    - traitFromSource\n    - ancestry_discoverySamples\n    - ancestry_replicationSamples\n    - initialSampleSize\n    - nCases\n    - replicationSamples\n\n    Some fields are populated as constants, such as projectID, studyType, and initial sample size.\n    \"\"\"\n\n    @classmethod\n    def from_source(\n        cls: type[UKBiobankStudyIndex],\n        ukbiobank_studies: DataFrame,\n    ) -&gt; UKBiobankStudyIndex:\n        \"\"\"This function ingests study level metadata from UKBiobank.\n\n        The University of Michigan SAIGE analysis (N=1281) utilized PheCode derived phenotypes and a novel method that ensures accurate P values, even with highly unbalanced case-control ratios (Zhou et al., 2018).\n\n        The Neale lab Round 2 study (N=2139) used GWAS with imputed genotypes from HRC to analyze all data fields in UK Biobank, excluding ICD-10 related traits to reduce overlap with the SAIGE results.\n\n        Args:\n            ukbiobank_studies (DataFrame): UKBiobank study manifest file loaded in spark session.\n\n        Returns:\n            UKBiobankStudyIndex: Annotated UKBiobank study table.\n        \"\"\"\n        return StudyIndex(\n            _df=(\n                ukbiobank_studies.select(\n                    f.col(\"code\").alias(\"studyId\"),\n                    f.lit(\"UKBiobank\").alias(\"projectId\"),\n                    f.lit(\"gwas\").alias(\"studyType\"),\n                    f.col(\"trait\").alias(\"traitFromSource\"),\n                    # Make publication and ancestry schema columns.\n                    f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"30104761\").alias(\n                        \"pubmedId\"\n                    ),\n                    f.when(\n                        f.col(\"code\").startswith(\"SAIGE_\"),\n                        \"Efficiently controlling for case-control imbalance and sample relatedness in large-scale genetic association studies\",\n                    )\n                    .otherwise(None)\n                    .alias(\"publicationTitle\"),\n                    f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Wei Zhou\").alias(\n                        \"publicationFirstAuthor\"\n                    ),\n                    f.when(f.col(\"code\").startswith(\"NEALE2_\"), \"2018-08-01\")\n                    .otherwise(\"2018-10-24\")\n                    .alias(\"publicationDate\"),\n                    f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Nature Genetics\").alias(\n                        \"publicationJournal\"\n                    ),\n                    f.col(\"n_total\").cast(\"string\").alias(\"initialSampleSize\"),\n                    f.col(\"n_cases\").cast(\"long\").alias(\"nCases\"),\n                    f.array(\n                        f.struct(\n                            f.col(\"n_total\").cast(\"long\").alias(\"sampleSize\"),\n                            f.concat(f.lit(\"European=\"), f.col(\"n_total\")).alias(\n                                \"ancestry\"\n                            ),\n                        )\n                    ).alias(\"discoverySamples\"),\n                    f.col(\"in_path\").alias(\"summarystatsLocation\"),\n                    f.lit(True).alias(\"hasSumstats\"),\n                )\n                .withColumn(\n                    \"traitFromSource\",\n                    f.when(\n                        f.col(\"traitFromSource\").contains(\":\"),\n                        f.concat(\n                            f.initcap(\n                                f.split(f.col(\"traitFromSource\"), \": \").getItem(1)\n                            ),\n                            f.lit(\" | \"),\n                            f.lower(f.split(f.col(\"traitFromSource\"), \": \").getItem(0)),\n                        ),\n                    ).otherwise(f.col(\"traitFromSource\")),\n                )\n                .withColumn(\n                    \"ldPopulationStructure\",\n                    cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n                )\n            ),\n            _schema=StudyIndex.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/datasource/ukbiobank/study_index/#otg.datasource.ukbiobank.study_index.UKBiobankStudyIndex.from_source","title":"<code>from_source(ukbiobank_studies)</code>  <code>classmethod</code>","text":"<p>This function ingests study level metadata from UKBiobank.</p> <p>The University of Michigan SAIGE analysis (N=1281) utilized PheCode derived phenotypes and a novel method that ensures accurate P values, even with highly unbalanced case-control ratios (Zhou et al., 2018).</p> <p>The Neale lab Round 2 study (N=2139) used GWAS with imputed genotypes from HRC to analyze all data fields in UK Biobank, excluding ICD-10 related traits to reduce overlap with the SAIGE results.</p> <p>Parameters:</p> Name Type Description Default <code>ukbiobank_studies</code> <code>DataFrame</code> <p>UKBiobank study manifest file loaded in spark session.</p> required <p>Returns:</p> Name Type Description <code>UKBiobankStudyIndex</code> <code>UKBiobankStudyIndex</code> <p>Annotated UKBiobank study table.</p> Source code in <code>src/otg/datasource/ukbiobank/study_index.py</code> <pre><code>@classmethod\ndef from_source(\n    cls: type[UKBiobankStudyIndex],\n    ukbiobank_studies: DataFrame,\n) -&gt; UKBiobankStudyIndex:\n    \"\"\"This function ingests study level metadata from UKBiobank.\n\n    The University of Michigan SAIGE analysis (N=1281) utilized PheCode derived phenotypes and a novel method that ensures accurate P values, even with highly unbalanced case-control ratios (Zhou et al., 2018).\n\n    The Neale lab Round 2 study (N=2139) used GWAS with imputed genotypes from HRC to analyze all data fields in UK Biobank, excluding ICD-10 related traits to reduce overlap with the SAIGE results.\n\n    Args:\n        ukbiobank_studies (DataFrame): UKBiobank study manifest file loaded in spark session.\n\n    Returns:\n        UKBiobankStudyIndex: Annotated UKBiobank study table.\n    \"\"\"\n    return StudyIndex(\n        _df=(\n            ukbiobank_studies.select(\n                f.col(\"code\").alias(\"studyId\"),\n                f.lit(\"UKBiobank\").alias(\"projectId\"),\n                f.lit(\"gwas\").alias(\"studyType\"),\n                f.col(\"trait\").alias(\"traitFromSource\"),\n                # Make publication and ancestry schema columns.\n                f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"30104761\").alias(\n                    \"pubmedId\"\n                ),\n                f.when(\n                    f.col(\"code\").startswith(\"SAIGE_\"),\n                    \"Efficiently controlling for case-control imbalance and sample relatedness in large-scale genetic association studies\",\n                )\n                .otherwise(None)\n                .alias(\"publicationTitle\"),\n                f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Wei Zhou\").alias(\n                    \"publicationFirstAuthor\"\n                ),\n                f.when(f.col(\"code\").startswith(\"NEALE2_\"), \"2018-08-01\")\n                .otherwise(\"2018-10-24\")\n                .alias(\"publicationDate\"),\n                f.when(f.col(\"code\").startswith(\"SAIGE_\"), \"Nature Genetics\").alias(\n                    \"publicationJournal\"\n                ),\n                f.col(\"n_total\").cast(\"string\").alias(\"initialSampleSize\"),\n                f.col(\"n_cases\").cast(\"long\").alias(\"nCases\"),\n                f.array(\n                    f.struct(\n                        f.col(\"n_total\").cast(\"long\").alias(\"sampleSize\"),\n                        f.concat(f.lit(\"European=\"), f.col(\"n_total\")).alias(\n                            \"ancestry\"\n                        ),\n                    )\n                ).alias(\"discoverySamples\"),\n                f.col(\"in_path\").alias(\"summarystatsLocation\"),\n                f.lit(True).alias(\"hasSumstats\"),\n            )\n            .withColumn(\n                \"traitFromSource\",\n                f.when(\n                    f.col(\"traitFromSource\").contains(\":\"),\n                    f.concat(\n                        f.initcap(\n                            f.split(f.col(\"traitFromSource\"), \": \").getItem(1)\n                        ),\n                        f.lit(\" | \"),\n                        f.lower(f.split(f.col(\"traitFromSource\"), \": \").getItem(0)),\n                    ),\n                ).otherwise(f.col(\"traitFromSource\")),\n            )\n            .withColumn(\n                \"ldPopulationStructure\",\n                cls.aggregate_and_map_ancestries(f.col(\"discoverySamples\")),\n            )\n        ),\n        _schema=StudyIndex.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/_method/","title":"Method","text":"<p>TBC</p>"},{"location":"python_api/method/clumping/","title":"Clumping","text":"<p>Clumping is a commonly used post-processing method that allows for identification of independent association signals from GWAS summary statistics and curated associations. This process is critical because of the complex linkage disequilibrium (LD) structure in human populations, which can result in multiple statistically significant associations within the same genomic region. Clumping methods help reduce redundancy in GWAS results and ensure that each reported association represents an independent signal.</p> <p>We have implemented 2 clumping methods:</p>"},{"location":"python_api/method/clumping/#clumping-based-on-linkage-disequilibrium-ld","title":"Clumping based on Linkage Disequilibrium (LD)","text":"<p>LD clumping reports the most significant genetic associations in a region in terms of a smaller number of \u201cclumps\u201d of genetically linked SNPs.</p> Source code in <code>src/otg/method/clump.py</code> <pre><code>class LDclumping:\n    \"\"\"LD clumping reports the most significant genetic associations in a region in terms of a smaller number of \u201cclumps\u201d of genetically linked SNPs.\"\"\"\n\n    @staticmethod\n    def _is_lead_linked(\n        study_id: Column,\n        variant_id: Column,\n        p_value_exponent: Column,\n        p_value_mantissa: Column,\n        ld_set: Column,\n    ) -&gt; Column:\n        \"\"\"Evaluates whether a lead variant is linked to a tag (with lowest p-value) in the same studyLocus dataset.\n\n        Args:\n            study_id (Column): studyId\n            variant_id (Column): Lead variant id\n            p_value_exponent (Column): p-value exponent\n            p_value_mantissa (Column): p-value mantissa\n            locus (Column): Credible set &lt;array of structs&gt;\n\n        Returns:\n            Column: Boolean in which True indicates that the lead is linked to another tag in the same dataset.\n        \"\"\"\n        leads_in_study = f.collect_set(variant_id).over(Window.partitionBy(study_id))\n        tags_in_studylocus = f.array_union(\n            # Get all tag variants from the credible set per studyLocusId\n            f.transform(ld_set, lambda x: x.tagVariantId),\n            # And append the lead variant so that the intersection is the same for all studyLocusIds in a study\n            f.array(variant_id),\n        )\n        intersect_lead_tags = f.array_sort(\n            f.array_intersect(leads_in_study, tags_in_studylocus)\n        )\n        return (\n            # If the lead is in the credible set, we rank the peaks by p-value\n            f.when(\n                f.size(intersect_lead_tags) &gt; 0,\n                f.row_number().over(\n                    Window.partitionBy(study_id, intersect_lead_tags).orderBy(\n                        p_value_exponent, p_value_mantissa\n                    )\n                )\n                &gt; 1,\n            )\n            # If the intersection is empty (lead is not in the credible set or cred set is empty), the association is not linked\n            .otherwise(f.lit(False))\n        )\n\n    @classmethod\n    def clump(cls: type[LDclumping], associations: StudyLocus) -&gt; StudyLocus:\n        \"\"\"Perform clumping on studyLocus dataset.\n\n        Args:\n            associations (StudyLocus): StudyLocus dataset\n\n        Returns:\n            StudyLocus: including flag and removing locus information for LD clumped loci.\n        \"\"\"\n        return associations.clump()\n</code></pre>"},{"location":"python_api/method/clumping/#otg.method.clump.LDclumping.clump","title":"<code>clump(associations)</code>  <code>classmethod</code>","text":"<p>Perform clumping on studyLocus dataset.</p> <p>Parameters:</p> Name Type Description Default <code>associations</code> <code>StudyLocus</code> <p>StudyLocus dataset</p> required <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>including flag and removing locus information for LD clumped loci.</p> Source code in <code>src/otg/method/clump.py</code> <pre><code>@classmethod\ndef clump(cls: type[LDclumping], associations: StudyLocus) -&gt; StudyLocus:\n    \"\"\"Perform clumping on studyLocus dataset.\n\n    Args:\n        associations (StudyLocus): StudyLocus dataset\n\n    Returns:\n        StudyLocus: including flag and removing locus information for LD clumped loci.\n    \"\"\"\n    return associations.clump()\n</code></pre>"},{"location":"python_api/method/coloc/","title":"coloc","text":"<p>Calculate bayesian colocalisation based on overlapping signals from credible sets.</p> <p>Based on the R COLOC package, which uses the Bayes factors from the credible set to estimate the posterior probability of colocalisation. This method makes the simplifying assumption that only one single causal variant exists for any given trait in any genomic region.</p> Hypothesis Description H<sub>0</sub> no association with either trait in the region H<sub>1</sub> association with trait 1 only H<sub>2</sub> association with trait 2 only H<sub>3</sub> both traits are associated, but have different single causal variants H<sub>4</sub> both traits are associated and share the same single causal variant <p>Approximate Bayes factors required</p> <p>Coloc requires the availability of approximate Bayes factors (ABF) for each variant in the credible set (<code>logABF</code> column).</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>class Coloc:\n    \"\"\"Calculate bayesian colocalisation based on overlapping signals from credible sets.\n\n    Based on the [R COLOC package](https://github.com/chr1swallace/coloc/blob/main/R/claudia.R), which uses the Bayes factors from the credible set to estimate the posterior probability of colocalisation. This method makes the simplifying assumption that **only one single causal variant** exists for any given trait in any genomic region.\n\n    | Hypothesis    | Description                                                           |\n    | ------------- | --------------------------------------------------------------------- |\n    | H&lt;sub&gt;0&lt;/sub&gt; | no association with either trait in the region                        |\n    | H&lt;sub&gt;1&lt;/sub&gt; | association with trait 1 only                                         |\n    | H&lt;sub&gt;2&lt;/sub&gt; | association with trait 2 only                                         |\n    | H&lt;sub&gt;3&lt;/sub&gt; | both traits are associated, but have different single causal variants |\n    | H&lt;sub&gt;4&lt;/sub&gt; | both traits are associated and share the same single causal variant   |\n\n    !!! warning \"Approximate Bayes factors required\"\n        Coloc requires the availability of approximate Bayes factors (ABF) for each variant in the credible set (`logABF` column).\n\n    \"\"\"\n\n    @staticmethod\n    def _get_logsum(log_abf: ndarray) -&gt; float:\n        \"\"\"Calculates logsum of vector.\n\n        This function calculates the log of the sum of the exponentiated\n        logs taking out the max, i.e. insuring that the sum is not Inf\n\n        Args:\n            log_abf (ndarray): log approximate bayes factor\n\n        Returns:\n            float: logsum\n\n        Example:\n            &gt;&gt;&gt; l = [0.2, 0.1, 0.05, 0]\n            &gt;&gt;&gt; round(Coloc._get_logsum(l), 6)\n            1.476557\n        \"\"\"\n        themax = np.max(log_abf)\n        result = themax + np.log(np.sum(np.exp(log_abf - themax)))\n        return float(result)\n\n    @staticmethod\n    def _get_posteriors(all_abfs: ndarray) -&gt; DenseVector:\n        \"\"\"Calculate posterior probabilities for each hypothesis.\n\n        Args:\n            all_abfs (ndarray): h0-h4 bayes factors\n\n        Returns:\n            DenseVector: Posterior\n\n        Example:\n            &gt;&gt;&gt; l = np.array([0.2, 0.1, 0.05, 0])\n            &gt;&gt;&gt; Coloc._get_posteriors(l)\n            DenseVector([0.279, 0.2524, 0.2401, 0.2284])\n        \"\"\"\n        diff = all_abfs - Coloc._get_logsum(all_abfs)\n        abfs_posteriors = np.exp(diff)\n        return Vectors.dense(abfs_posteriors)\n\n    @classmethod\n    def colocalise(\n        cls: type[Coloc],\n        overlapping_signals: StudyLocusOverlap,\n        priorc1: float = 1e-4,\n        priorc2: float = 1e-4,\n        priorc12: float = 1e-5,\n    ) -&gt; Colocalisation:\n        \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n        Args:\n            overlapping_signals (StudyLocusOverlap): overlapping peaks\n            priorc1 (float): Prior on variant being causal for trait 1. Defaults to 1e-4.\n            priorc2 (float): Prior on variant being causal for trait 2. Defaults to 1e-4.\n            priorc12 (float): Prior on variant being causal for traits 1 and 2. Defaults to 1e-5.\n\n        Returns:\n            Colocalisation: Colocalisation results\n        \"\"\"\n        # register udfs\n        logsum = f.udf(Coloc._get_logsum, DoubleType())\n        posteriors = f.udf(Coloc._get_posteriors, VectorUDT())\n        return Colocalisation(\n            _df=(\n                overlapping_signals.df\n                # Before summing log_abf columns nulls need to be filled with 0:\n                .fillna(0, subset=[\"statistics.left_logABF\", \"statistics.right_logABF\"])\n                # Sum of log_abfs for each pair of signals\n                .withColumn(\n                    \"sum_log_abf\",\n                    f.col(\"statistics.left_logABF\") + f.col(\"statistics.right_logABF\"),\n                )\n                # Group by overlapping peak and generating dense vectors of log_abf:\n                .groupBy(\"chromosome\", \"leftStudyLocusId\", \"rightStudyLocusId\")\n                .agg(\n                    f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                    fml.array_to_vector(\n                        f.collect_list(f.col(\"statistics.left_logABF\"))\n                    ).alias(\"left_logABF\"),\n                    fml.array_to_vector(\n                        f.collect_list(f.col(\"statistics.right_logABF\"))\n                    ).alias(\"right_logABF\"),\n                    fml.array_to_vector(f.collect_list(f.col(\"sum_log_abf\"))).alias(\n                        \"sum_log_abf\"\n                    ),\n                )\n                .withColumn(\"logsum1\", logsum(f.col(\"left_logABF\")))\n                .withColumn(\"logsum2\", logsum(f.col(\"right_logABF\")))\n                .withColumn(\"logsum12\", logsum(f.col(\"sum_log_abf\")))\n                .drop(\"left_logABF\", \"right_logABF\", \"sum_log_abf\")\n                # Add priors\n                # priorc1 Prior on variant being causal for trait 1\n                .withColumn(\"priorc1\", f.lit(priorc1))\n                # priorc2 Prior on variant being causal for trait 2\n                .withColumn(\"priorc2\", f.lit(priorc2))\n                # priorc12 Prior on variant being causal for traits 1 and 2\n                .withColumn(\"priorc12\", f.lit(priorc12))\n                # h0-h2\n                .withColumn(\"lH0abf\", f.lit(0))\n                .withColumn(\"lH1abf\", f.log(f.col(\"priorc1\")) + f.col(\"logsum1\"))\n                .withColumn(\"lH2abf\", f.log(f.col(\"priorc2\")) + f.col(\"logsum2\"))\n                # h3\n                .withColumn(\"sumlogsum\", f.col(\"logsum1\") + f.col(\"logsum2\"))\n                # exclude null H3/H4s: due to sumlogsum == logsum12\n                .filter(f.col(\"sumlogsum\") != f.col(\"logsum12\"))\n                .withColumn(\"max\", f.greatest(\"sumlogsum\", \"logsum12\"))\n                .withColumn(\n                    \"logdiff\",\n                    (\n                        f.col(\"max\")\n                        + f.log(\n                            f.exp(f.col(\"sumlogsum\") - f.col(\"max\"))\n                            - f.exp(f.col(\"logsum12\") - f.col(\"max\"))\n                        )\n                    ),\n                )\n                .withColumn(\n                    \"lH3abf\",\n                    f.log(f.col(\"priorc1\"))\n                    + f.log(f.col(\"priorc2\"))\n                    + f.col(\"logdiff\"),\n                )\n                .drop(\"right_logsum\", \"left_logsum\", \"sumlogsum\", \"max\", \"logdiff\")\n                # h4\n                .withColumn(\"lH4abf\", f.log(f.col(\"priorc12\")) + f.col(\"logsum12\"))\n                # cleaning\n                .drop(\n                    \"priorc1\", \"priorc2\", \"priorc12\", \"logsum1\", \"logsum2\", \"logsum12\"\n                )\n                # posteriors\n                .withColumn(\n                    \"allABF\",\n                    fml.array_to_vector(\n                        f.array(\n                            f.col(\"lH0abf\"),\n                            f.col(\"lH1abf\"),\n                            f.col(\"lH2abf\"),\n                            f.col(\"lH3abf\"),\n                            f.col(\"lH4abf\"),\n                        )\n                    ),\n                )\n                .withColumn(\n                    \"posteriors\", fml.vector_to_array(posteriors(f.col(\"allABF\")))\n                )\n                .withColumn(\"h0\", f.col(\"posteriors\").getItem(0))\n                .withColumn(\"h1\", f.col(\"posteriors\").getItem(1))\n                .withColumn(\"h2\", f.col(\"posteriors\").getItem(2))\n                .withColumn(\"h3\", f.col(\"posteriors\").getItem(3))\n                .withColumn(\"h4\", f.col(\"posteriors\").getItem(4))\n                .withColumn(\"h4h3\", f.col(\"h4\") / f.col(\"h3\"))\n                .withColumn(\"log2h4h3\", f.log2(f.col(\"h4h3\")))\n                # clean up\n                .drop(\n                    \"posteriors\",\n                    \"allABF\",\n                    \"h4h3\",\n                    \"lH0abf\",\n                    \"lH1abf\",\n                    \"lH2abf\",\n                    \"lH3abf\",\n                    \"lH4abf\",\n                )\n                .withColumn(\"colocalisationMethod\", f.lit(\"COLOC\"))\n            ),\n            _schema=Colocalisation.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/coloc/#otg.method.colocalisation.Coloc.colocalise","title":"<code>colocalise(overlapping_signals, priorc1=0.0001, priorc2=0.0001, priorc12=1e-05)</code>  <code>classmethod</code>","text":"<p>Calculate bayesian colocalisation based on overlapping signals.</p> <p>Parameters:</p> Name Type Description Default <code>overlapping_signals</code> <code>StudyLocusOverlap</code> <p>overlapping peaks</p> required <code>priorc1</code> <code>float</code> <p>Prior on variant being causal for trait 1. Defaults to 1e-4.</p> <code>0.0001</code> <code>priorc2</code> <code>float</code> <p>Prior on variant being causal for trait 2. Defaults to 1e-4.</p> <code>0.0001</code> <code>priorc12</code> <code>float</code> <p>Prior on variant being causal for traits 1 and 2. Defaults to 1e-5.</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>Colocalisation</code> <code>Colocalisation</code> <p>Colocalisation results</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>@classmethod\ndef colocalise(\n    cls: type[Coloc],\n    overlapping_signals: StudyLocusOverlap,\n    priorc1: float = 1e-4,\n    priorc2: float = 1e-4,\n    priorc12: float = 1e-5,\n) -&gt; Colocalisation:\n    \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n    Args:\n        overlapping_signals (StudyLocusOverlap): overlapping peaks\n        priorc1 (float): Prior on variant being causal for trait 1. Defaults to 1e-4.\n        priorc2 (float): Prior on variant being causal for trait 2. Defaults to 1e-4.\n        priorc12 (float): Prior on variant being causal for traits 1 and 2. Defaults to 1e-5.\n\n    Returns:\n        Colocalisation: Colocalisation results\n    \"\"\"\n    # register udfs\n    logsum = f.udf(Coloc._get_logsum, DoubleType())\n    posteriors = f.udf(Coloc._get_posteriors, VectorUDT())\n    return Colocalisation(\n        _df=(\n            overlapping_signals.df\n            # Before summing log_abf columns nulls need to be filled with 0:\n            .fillna(0, subset=[\"statistics.left_logABF\", \"statistics.right_logABF\"])\n            # Sum of log_abfs for each pair of signals\n            .withColumn(\n                \"sum_log_abf\",\n                f.col(\"statistics.left_logABF\") + f.col(\"statistics.right_logABF\"),\n            )\n            # Group by overlapping peak and generating dense vectors of log_abf:\n            .groupBy(\"chromosome\", \"leftStudyLocusId\", \"rightStudyLocusId\")\n            .agg(\n                f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                fml.array_to_vector(\n                    f.collect_list(f.col(\"statistics.left_logABF\"))\n                ).alias(\"left_logABF\"),\n                fml.array_to_vector(\n                    f.collect_list(f.col(\"statistics.right_logABF\"))\n                ).alias(\"right_logABF\"),\n                fml.array_to_vector(f.collect_list(f.col(\"sum_log_abf\"))).alias(\n                    \"sum_log_abf\"\n                ),\n            )\n            .withColumn(\"logsum1\", logsum(f.col(\"left_logABF\")))\n            .withColumn(\"logsum2\", logsum(f.col(\"right_logABF\")))\n            .withColumn(\"logsum12\", logsum(f.col(\"sum_log_abf\")))\n            .drop(\"left_logABF\", \"right_logABF\", \"sum_log_abf\")\n            # Add priors\n            # priorc1 Prior on variant being causal for trait 1\n            .withColumn(\"priorc1\", f.lit(priorc1))\n            # priorc2 Prior on variant being causal for trait 2\n            .withColumn(\"priorc2\", f.lit(priorc2))\n            # priorc12 Prior on variant being causal for traits 1 and 2\n            .withColumn(\"priorc12\", f.lit(priorc12))\n            # h0-h2\n            .withColumn(\"lH0abf\", f.lit(0))\n            .withColumn(\"lH1abf\", f.log(f.col(\"priorc1\")) + f.col(\"logsum1\"))\n            .withColumn(\"lH2abf\", f.log(f.col(\"priorc2\")) + f.col(\"logsum2\"))\n            # h3\n            .withColumn(\"sumlogsum\", f.col(\"logsum1\") + f.col(\"logsum2\"))\n            # exclude null H3/H4s: due to sumlogsum == logsum12\n            .filter(f.col(\"sumlogsum\") != f.col(\"logsum12\"))\n            .withColumn(\"max\", f.greatest(\"sumlogsum\", \"logsum12\"))\n            .withColumn(\n                \"logdiff\",\n                (\n                    f.col(\"max\")\n                    + f.log(\n                        f.exp(f.col(\"sumlogsum\") - f.col(\"max\"))\n                        - f.exp(f.col(\"logsum12\") - f.col(\"max\"))\n                    )\n                ),\n            )\n            .withColumn(\n                \"lH3abf\",\n                f.log(f.col(\"priorc1\"))\n                + f.log(f.col(\"priorc2\"))\n                + f.col(\"logdiff\"),\n            )\n            .drop(\"right_logsum\", \"left_logsum\", \"sumlogsum\", \"max\", \"logdiff\")\n            # h4\n            .withColumn(\"lH4abf\", f.log(f.col(\"priorc12\")) + f.col(\"logsum12\"))\n            # cleaning\n            .drop(\n                \"priorc1\", \"priorc2\", \"priorc12\", \"logsum1\", \"logsum2\", \"logsum12\"\n            )\n            # posteriors\n            .withColumn(\n                \"allABF\",\n                fml.array_to_vector(\n                    f.array(\n                        f.col(\"lH0abf\"),\n                        f.col(\"lH1abf\"),\n                        f.col(\"lH2abf\"),\n                        f.col(\"lH3abf\"),\n                        f.col(\"lH4abf\"),\n                    )\n                ),\n            )\n            .withColumn(\n                \"posteriors\", fml.vector_to_array(posteriors(f.col(\"allABF\")))\n            )\n            .withColumn(\"h0\", f.col(\"posteriors\").getItem(0))\n            .withColumn(\"h1\", f.col(\"posteriors\").getItem(1))\n            .withColumn(\"h2\", f.col(\"posteriors\").getItem(2))\n            .withColumn(\"h3\", f.col(\"posteriors\").getItem(3))\n            .withColumn(\"h4\", f.col(\"posteriors\").getItem(4))\n            .withColumn(\"h4h3\", f.col(\"h4\") / f.col(\"h3\"))\n            .withColumn(\"log2h4h3\", f.log2(f.col(\"h4h3\")))\n            # clean up\n            .drop(\n                \"posteriors\",\n                \"allABF\",\n                \"h4h3\",\n                \"lH0abf\",\n                \"lH1abf\",\n                \"lH2abf\",\n                \"lH3abf\",\n                \"lH4abf\",\n            )\n            .withColumn(\"colocalisationMethod\", f.lit(\"COLOC\"))\n        ),\n        _schema=Colocalisation.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/ecaviar/","title":"eCAVIAR","text":"<p>ECaviar-based colocalisation analysis.</p> <p>It extends CAVIAR\u00a0framework to explicitly estimate the posterior probability that the same variant is causal in 2 studies while accounting for the uncertainty of LD. eCAVIAR computes the colocalization posterior probability (CLPP) by utilizing the marginal posterior probabilities. This framework allows for multiple variants to be causal in a single locus.</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>class ECaviar:\n    \"\"\"ECaviar-based colocalisation analysis.\n\n    It extends [CAVIAR](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5142122/#bib18)\u00a0framework to explicitly estimate the posterior probability that the same variant is causal in 2 studies while accounting for the uncertainty of LD. eCAVIAR computes the colocalization posterior probability (**CLPP**) by utilizing the marginal posterior probabilities. This framework allows for **multiple variants to be causal** in a single locus.\n    \"\"\"\n\n    @staticmethod\n    def _get_clpp(left_pp: Column, right_pp: Column) -&gt; Column:\n        \"\"\"Calculate the colocalisation posterior probability (CLPP).\n\n        If the fact that the same variant is found causal for two studies are independent events,\n        CLPP is defined as the product of posterior porbabilities that a variant is causal in both studies.\n\n        Args:\n            left_pp (Column): left posterior probability\n            right_pp (Column): right posterior probability\n\n        Returns:\n            Column: CLPP\n\n        Examples:\n            &gt;&gt;&gt; d = [{\"left_pp\": 0.5, \"right_pp\": 0.5}, {\"left_pp\": 0.25, \"right_pp\": 0.75}]\n            &gt;&gt;&gt; df = spark.createDataFrame(d)\n            &gt;&gt;&gt; df.withColumn(\"clpp\", ECaviar._get_clpp(f.col(\"left_pp\"), f.col(\"right_pp\"))).show()\n            +-------+--------+------+\n            |left_pp|right_pp|  clpp|\n            +-------+--------+------+\n            |    0.5|     0.5|  0.25|\n            |   0.25|    0.75|0.1875|\n            +-------+--------+------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        return left_pp * right_pp\n\n    @classmethod\n    def colocalise(\n        cls: type[ECaviar], overlapping_signals: StudyLocusOverlap\n    ) -&gt; Colocalisation:\n        \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n        Args:\n            overlapping_signals (StudyLocusOverlap): overlapping signals.\n\n        Returns:\n            Colocalisation: colocalisation results based on eCAVIAR.\n        \"\"\"\n        return Colocalisation(\n            _df=(\n                overlapping_signals.df.withColumn(\n                    \"clpp\",\n                    ECaviar._get_clpp(\n                        f.col(\"statistics.left_posteriorProbability\"),\n                        f.col(\"statistics.right_posteriorProbability\"),\n                    ),\n                )\n                .groupBy(\"leftStudyLocusId\", \"rightStudyLocusId\", \"chromosome\")\n                .agg(\n                    f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                    f.sum(f.col(\"clpp\")).alias(\"clpp\"),\n                )\n                .withColumn(\"colocalisationMethod\", f.lit(\"eCAVIAR\"))\n            ),\n            _schema=Colocalisation.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/ecaviar/#otg.method.colocalisation.ECaviar.colocalise","title":"<code>colocalise(overlapping_signals)</code>  <code>classmethod</code>","text":"<p>Calculate bayesian colocalisation based on overlapping signals.</p> <p>Parameters:</p> Name Type Description Default <code>overlapping_signals</code> <code>StudyLocusOverlap</code> <p>overlapping signals.</p> required <p>Returns:</p> Name Type Description <code>Colocalisation</code> <code>Colocalisation</code> <p>colocalisation results based on eCAVIAR.</p> Source code in <code>src/otg/method/colocalisation.py</code> <pre><code>@classmethod\ndef colocalise(\n    cls: type[ECaviar], overlapping_signals: StudyLocusOverlap\n) -&gt; Colocalisation:\n    \"\"\"Calculate bayesian colocalisation based on overlapping signals.\n\n    Args:\n        overlapping_signals (StudyLocusOverlap): overlapping signals.\n\n    Returns:\n        Colocalisation: colocalisation results based on eCAVIAR.\n    \"\"\"\n    return Colocalisation(\n        _df=(\n            overlapping_signals.df.withColumn(\n                \"clpp\",\n                ECaviar._get_clpp(\n                    f.col(\"statistics.left_posteriorProbability\"),\n                    f.col(\"statistics.right_posteriorProbability\"),\n                ),\n            )\n            .groupBy(\"leftStudyLocusId\", \"rightStudyLocusId\", \"chromosome\")\n            .agg(\n                f.count(\"*\").alias(\"numberColocalisingVariants\"),\n                f.sum(f.col(\"clpp\")).alias(\"clpp\"),\n            )\n            .withColumn(\"colocalisationMethod\", f.lit(\"eCAVIAR\"))\n        ),\n        _schema=Colocalisation.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/ld_annotator/","title":"LD annotator","text":"<p>Class to annotate linkage disequilibrium (LD) operations from GnomAD.</p> Source code in <code>src/otg/method/ld.py</code> <pre><code>class LDAnnotator:\n    \"\"\"Class to annotate linkage disequilibrium (LD) operations from GnomAD.\"\"\"\n\n    @staticmethod\n    def _calculate_weighted_r_overall(ld_set: Column) -&gt; Column:\n        \"\"\"Aggregation of weighted R information using ancestry proportions.\"\"\"\n        return f.transform(\n            ld_set,\n            lambda x: f.struct(\n                x[\"tagVariantId\"].alias(\"tagVariantId\"),\n                # r2Overall is the accumulated sum of each r2 relative to the population size\n                f.aggregate(\n                    x[\"rValues\"],\n                    f.lit(0.0),\n                    lambda acc, y: acc\n                    + f.coalesce(\n                        f.pow(y[\"r\"], 2) * y[\"relativeSampleSize\"], f.lit(0.0)\n                    ),  # we use coalesce to avoid problems when r/relativeSampleSize is null\n                ).alias(\"r2Overall\"),\n            ),\n        )\n\n    @staticmethod\n    def _add_population_size(ld_set: Column, study_populations: Column) -&gt; Column:\n        \"\"\"Add population size to each rValues entry in the ldSet.\n\n        Args:\n            ld_set (Column): LD set\n            study_populations (Column): Study populations\n\n        Returns:\n            Column: LD set with added 'relativeSampleSize' field\n        \"\"\"\n        # Create a population to relativeSampleSize map from the struct\n        populations_map = f.map_from_arrays(\n            study_populations[\"ldPopulation\"],\n            study_populations[\"relativeSampleSize\"],\n        )\n        return f.transform(\n            ld_set,\n            lambda x: f.struct(\n                x[\"tagVariantId\"].alias(\"tagVariantId\"),\n                f.transform(\n                    x[\"rValues\"],\n                    lambda y: f.struct(\n                        y[\"population\"].alias(\"population\"),\n                        y[\"r\"].alias(\"r\"),\n                        populations_map[y[\"population\"]].alias(\"relativeSampleSize\"),\n                    ),\n                ).alias(\"rValues\"),\n            ),\n        )\n\n    @classmethod\n    def ld_annotate(\n        cls: type[LDAnnotator],\n        associations: StudyLocus,\n        studies: StudyIndex,\n        ld_index: LDIndex,\n    ) -&gt; StudyLocus:\n        \"\"\"Annotate linkage disequilibrium (LD) information to a set of studyLocus.\n\n        This function:\n            1. Annotates study locus with population structure information from the study index\n            2. Joins the LD index to the StudyLocus\n            3. Adds the population size of the study to each rValues entry in the ldSet\n            4. Calculates the overall R weighted by the ancestry proportions in every given study.\n\n        Args:\n            associations (StudyLocus): Dataset to be LD annotated\n            studies (StudyIndex): Dataset with study information\n            ld_index (LDIndex): Dataset with LD information for every variant present in LD matrix\n\n        Returns:\n            StudyLocus: including additional column with LD information.\n        \"\"\"\n        return (\n            StudyLocus(\n                _df=(\n                    associations.df\n                    # Drop ldSet column if already available\n                    .select(*[col for col in associations.df.columns if col != \"ldSet\"])\n                    # Annotate study locus with population structure from study index\n                    .join(\n                        studies.df.select(\"studyId\", \"ldPopulationStructure\"),\n                        on=\"studyId\",\n                        how=\"left\",\n                    )\n                    # Bring LD information from LD Index\n                    .join(\n                        ld_index.df,\n                        on=[\"variantId\", \"chromosome\"],\n                        how=\"left\",\n                    )\n                    # Add population size to each rValues entry in the ldSet if population structure available:\n                    .withColumn(\n                        \"ldSet\",\n                        f.when(\n                            f.col(\"ldPopulationStructure\").isNotNull(),\n                            cls._add_population_size(\n                                f.col(\"ldSet\"), f.col(\"ldPopulationStructure\")\n                            ),\n                        ),\n                    )\n                    # Aggregate weighted R information using ancestry proportions\n                    .withColumn(\n                        \"ldSet\",\n                        f.when(\n                            f.col(\"ldPopulationStructure\").isNotNull(),\n                            cls._calculate_weighted_r_overall(f.col(\"ldSet\")),\n                        ),\n                    ).drop(\"ldPopulationStructure\")\n                ),\n                _schema=StudyLocus.get_schema(),\n            )\n            ._qc_no_population()\n            ._qc_unresolved_ld()\n        )\n</code></pre>"},{"location":"python_api/method/ld_annotator/#otg.method.ld.LDAnnotator.ld_annotate","title":"<code>ld_annotate(associations, studies, ld_index)</code>  <code>classmethod</code>","text":"<p>Annotate linkage disequilibrium (LD) information to a set of studyLocus.</p> This function <ol> <li>Annotates study locus with population structure information from the study index</li> <li>Joins the LD index to the StudyLocus</li> <li>Adds the population size of the study to each rValues entry in the ldSet</li> <li>Calculates the overall R weighted by the ancestry proportions in every given study.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>associations</code> <code>StudyLocus</code> <p>Dataset to be LD annotated</p> required <code>studies</code> <code>StudyIndex</code> <p>Dataset with study information</p> required <code>ld_index</code> <code>LDIndex</code> <p>Dataset with LD information for every variant present in LD matrix</p> required <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>including additional column with LD information.</p> Source code in <code>src/otg/method/ld.py</code> <pre><code>@classmethod\ndef ld_annotate(\n    cls: type[LDAnnotator],\n    associations: StudyLocus,\n    studies: StudyIndex,\n    ld_index: LDIndex,\n) -&gt; StudyLocus:\n    \"\"\"Annotate linkage disequilibrium (LD) information to a set of studyLocus.\n\n    This function:\n        1. Annotates study locus with population structure information from the study index\n        2. Joins the LD index to the StudyLocus\n        3. Adds the population size of the study to each rValues entry in the ldSet\n        4. Calculates the overall R weighted by the ancestry proportions in every given study.\n\n    Args:\n        associations (StudyLocus): Dataset to be LD annotated\n        studies (StudyIndex): Dataset with study information\n        ld_index (LDIndex): Dataset with LD information for every variant present in LD matrix\n\n    Returns:\n        StudyLocus: including additional column with LD information.\n    \"\"\"\n    return (\n        StudyLocus(\n            _df=(\n                associations.df\n                # Drop ldSet column if already available\n                .select(*[col for col in associations.df.columns if col != \"ldSet\"])\n                # Annotate study locus with population structure from study index\n                .join(\n                    studies.df.select(\"studyId\", \"ldPopulationStructure\"),\n                    on=\"studyId\",\n                    how=\"left\",\n                )\n                # Bring LD information from LD Index\n                .join(\n                    ld_index.df,\n                    on=[\"variantId\", \"chromosome\"],\n                    how=\"left\",\n                )\n                # Add population size to each rValues entry in the ldSet if population structure available:\n                .withColumn(\n                    \"ldSet\",\n                    f.when(\n                        f.col(\"ldPopulationStructure\").isNotNull(),\n                        cls._add_population_size(\n                            f.col(\"ldSet\"), f.col(\"ldPopulationStructure\")\n                        ),\n                    ),\n                )\n                # Aggregate weighted R information using ancestry proportions\n                .withColumn(\n                    \"ldSet\",\n                    f.when(\n                        f.col(\"ldPopulationStructure\").isNotNull(),\n                        cls._calculate_weighted_r_overall(f.col(\"ldSet\")),\n                    ),\n                ).drop(\"ldPopulationStructure\")\n            ),\n            _schema=StudyLocus.get_schema(),\n        )\n        ._qc_no_population()\n        ._qc_unresolved_ld()\n    )\n</code></pre>"},{"location":"python_api/method/pics/","title":"PICS","text":"<p>Probabilistic Identification of Causal SNPs (PICS), an algorithm estimating the probability that an individual variant is causal considering the haplotype structure and observed pattern of association at the genetic locus.</p> Source code in <code>src/otg/method/pics.py</code> <pre><code>class PICS:\n    \"\"\"Probabilistic Identification of Causal SNPs (PICS), an algorithm estimating the probability that an individual variant is causal considering the haplotype structure and observed pattern of association at the genetic locus.\"\"\"\n\n    @staticmethod\n    def _pics_relative_posterior_probability(\n        neglog_p: float, pics_snp_mu: float, pics_snp_std: float\n    ) -&gt; float:\n        \"\"\"Compute the PICS posterior probability for a given SNP.\n\n        !!! info \"This probability needs to be scaled to take into account the probabilities of the other variants in the locus.\"\n\n        Args:\n            neglog_p (float): Negative log p-value of the lead variant\n            pics_snp_mu (float): Mean P value of the association between a SNP and a trait\n            pics_snp_std (float): Standard deviation for the P value of the association between a SNP and a trait\n\n        Returns:\n            Relative posterior probability of a SNP being causal in a locus\n\n        Examples:\n            &gt;&gt;&gt; rel_prob = PICS._pics_relative_posterior_probability(neglog_p=10.0, pics_snp_mu=1.0, pics_snp_std=10.0)\n            &gt;&gt;&gt; round(rel_prob, 3)\n            0.368\n        \"\"\"\n        return float(norm(pics_snp_mu, pics_snp_std).sf(neglog_p) * 2)\n\n    @staticmethod\n    def _pics_standard_deviation(neglog_p: float, r2: float, k: float) -&gt; float | None:\n        \"\"\"Compute the PICS standard deviation.\n\n        This distribution is obtained after a series of permutation tests described in the PICS method, and it is only\n        valid when the SNP is highly linked with the lead (r2 &gt; 0.5).\n\n        Args:\n            neglog_p (float): Negative log p-value of the lead variant\n            r2 (float): LD score between a given SNP and the lead variant\n            k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n        Returns:\n            Standard deviation for the P value of the association between a SNP and a trait\n\n        Examples:\n            &gt;&gt;&gt; PICS._pics_standard_deviation(neglog_p=1.0, r2=1.0, k=6.4)\n            0.0\n            &gt;&gt;&gt; round(PICS._pics_standard_deviation(neglog_p=10.0, r2=0.5, k=6.4), 3)\n            1.493\n            &gt;&gt;&gt; print(PICS._pics_standard_deviation(neglog_p=1.0, r2=0.0, k=6.4))\n            None\n        \"\"\"\n        return (\n            abs(((1 - (r2**0.5) ** k) ** 0.5) * (neglog_p**0.5) / 2)\n            if r2 &gt;= 0.5\n            else None\n        )\n\n    @staticmethod\n    def _pics_mu(neglog_p: float, r2: float) -&gt; float | None:\n        \"\"\"Compute the PICS mu that estimates the probability of association between a given SNP and the trait.\n\n        This distribution is obtained after a series of permutation tests described in the PICS method, and it is only\n        valid when the SNP is highly linked with the lead (r2 &gt; 0.5).\n\n        Args:\n            neglog_p (float): Negative log p-value of the lead variant\n            r2 (float): LD score between a given SNP and the lead variant\n\n        Returns:\n            Mean P value of the association between a SNP and a trait\n\n        Examples:\n            &gt;&gt;&gt; PICS._pics_mu(neglog_p=1.0, r2=1.0)\n            1.0\n            &gt;&gt;&gt; PICS._pics_mu(neglog_p=10.0, r2=0.5)\n            5.0\n            &gt;&gt;&gt; print(PICS._pics_mu(neglog_p=10.0, r2=0.3))\n            None\n        \"\"\"\n        return neglog_p * r2 if r2 &gt;= 0.5 else None\n\n    @staticmethod\n    def _finemap(ld_set: list[Row], lead_neglog_p: float, k: float) -&gt; list | None:\n        \"\"\"Calculates the probability of a variant being causal in a study-locus context by applying the PICS method.\n\n        It is intended to be applied as an UDF in `PICS.finemap`, where each row is a StudyLocus association.\n        The function iterates over every SNP in the `ldSet` array, and it returns an updated locus with\n        its association signal and causality probability as of PICS.\n\n        Args:\n            ld_set (list): list of tagging variants after expanding the locus\n            lead_neglog_p (float): P value of the association signal between the lead variant and the study in the form of -log10.\n            k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n        Returns:\n            List of tagging variants with an estimation of the association signal and their posterior probability as of PICS.\n\n        Examples:\n            &gt;&gt;&gt; from pyspark.sql import Row\n            &gt;&gt;&gt; ld_set = [\n            ...     Row(variantId=\"var1\", r2Overall=0.8),\n            ...     Row(variantId=\"var2\", r2Overall=1),\n            ... ]\n            &gt;&gt;&gt; PICS._finemap(ld_set, lead_neglog_p=10.0, k=6.4)\n            [{'variantId': 'var1', 'r2Overall': 0.8, 'standardError': 0.07420896512708416, 'posteriorProbability': 0.07116959886882368}, {'variantId': 'var2', 'r2Overall': 1, 'standardError': 0.9977000638225533, 'posteriorProbability': 0.9288304011311763}]\n            &gt;&gt;&gt; empty_ld_set = []\n            &gt;&gt;&gt; PICS._finemap(empty_ld_set, lead_neglog_p=10.0, k=6.4)\n            []\n            &gt;&gt;&gt; ld_set_with_no_r2 = [\n            ...     Row(variantId=\"var1\", r2Overall=None),\n            ...     Row(variantId=\"var2\", r2Overall=None),\n            ... ]\n            &gt;&gt;&gt; PICS._finemap(ld_set_with_no_r2, lead_neglog_p=10.0, k=6.4)\n            [{'variantId': 'var1', 'r2Overall': None}, {'variantId': 'var2', 'r2Overall': None}]\n        \"\"\"\n        if ld_set is None:\n            return None\n        elif not ld_set:\n            return []\n        tmp_credible_set = []\n        new_credible_set = []\n        # First iteration: calculation of mu, standard deviation, and the relative posterior probability\n        for tag_struct in ld_set:\n            tag_dict = (\n                tag_struct.asDict()\n            )  # tag_struct is of type pyspark.Row, we'll represent it as a dict\n            if (\n                not tag_dict[\"r2Overall\"]\n                or tag_dict[\"r2Overall\"] &lt; 0.5\n                or not lead_neglog_p\n            ):\n                # If PICS cannot be calculated, we'll return the original credible set\n                new_credible_set.append(tag_dict)\n                continue\n\n            pics_snp_mu = PICS._pics_mu(lead_neglog_p, tag_dict[\"r2Overall\"])\n            pics_snp_std = PICS._pics_standard_deviation(\n                lead_neglog_p, tag_dict[\"r2Overall\"], k\n            )\n            pics_snp_std = 0.001 if pics_snp_std == 0 else pics_snp_std\n            if pics_snp_mu is not None and pics_snp_std is not None:\n                posterior_probability = PICS._pics_relative_posterior_probability(\n                    lead_neglog_p, pics_snp_mu, pics_snp_std\n                )\n                tag_dict[\"standardError\"] = 10**-pics_snp_std\n                tag_dict[\"relativePosteriorProbability\"] = posterior_probability\n\n                tmp_credible_set.append(tag_dict)\n\n        # Second iteration: calculation of the sum of all the posteriors in each study-locus, so that we scale them between 0-1\n        total_posteriors = sum(\n            tag_dict.get(\"relativePosteriorProbability\", 0)\n            for tag_dict in tmp_credible_set\n        )\n\n        # Third iteration: calculation of the final posteriorProbability\n        for tag_dict in tmp_credible_set:\n            if total_posteriors != 0:\n                tag_dict[\"posteriorProbability\"] = float(\n                    tag_dict.get(\"relativePosteriorProbability\", 0) / total_posteriors\n                )\n            tag_dict.pop(\"relativePosteriorProbability\")\n            new_credible_set.append(tag_dict)\n        return new_credible_set\n\n    @classmethod\n    def finemap(\n        cls: type[PICS], associations: StudyLocus, k: float = 6.4\n    ) -&gt; StudyLocus:\n        \"\"\"Run PICS on a study locus.\n\n        !!! info \"Study locus needs to be LD annotated\"\n            The study locus needs to be LD annotated before PICS can be calculated.\n\n        Args:\n            associations (StudyLocus): Study locus to finemap using PICS\n            k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n        Returns:\n            StudyLocus: Study locus with PICS results\n        \"\"\"\n        # Register UDF by defining the structure of the output locus array of structs\n        # it also renames tagVariantId to variantId\n\n        picsed_ldset_schema = t.ArrayType(\n            t.StructType(\n                [\n                    t.StructField(\"tagVariantId\", t.StringType(), True),\n                    t.StructField(\"r2Overall\", t.DoubleType(), True),\n                    t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                    t.StructField(\"standardError\", t.DoubleType(), True),\n                ]\n            )\n        )\n        picsed_study_locus_schema = t.ArrayType(\n            t.StructType(\n                [\n                    t.StructField(\"variantId\", t.StringType(), True),\n                    t.StructField(\"r2Overall\", t.DoubleType(), True),\n                    t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                    t.StructField(\"standardError\", t.DoubleType(), True),\n                ]\n            )\n        )\n        _finemap_udf = f.udf(\n            lambda locus, neglog_p: PICS._finemap(locus, neglog_p, k),\n            picsed_ldset_schema,\n        )\n        return StudyLocus(\n            _df=(\n                associations.df\n                # Old locus column will be dropped if available\n                .select(*[col for col in associations.df.columns if col != \"locus\"])\n                # Estimate neglog_pvalue for the lead variant\n                .withColumn(\"neglog_pvalue\", associations.neglog_pvalue())\n                # New locus containing the PICS results\n                .withColumn(\n                    \"locus\",\n                    f.when(\n                        f.col(\"ldSet\").isNotNull(),\n                        _finemap_udf(f.col(\"ldSet\"), f.col(\"neglog_pvalue\")).cast(\n                            picsed_study_locus_schema\n                        ),\n                    ),\n                )\n                # Rename tagVariantId to variantId\n                .drop(\"neglog_pvalue\")\n            ),\n            _schema=StudyLocus.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/pics/#otg.method.pics.PICS.finemap","title":"<code>finemap(associations, k=6.4)</code>  <code>classmethod</code>","text":"<p>Run PICS on a study locus.</p> <p>Study locus needs to be LD annotated</p> <p>The study locus needs to be LD annotated before PICS can be calculated.</p> <p>Parameters:</p> Name Type Description Default <code>associations</code> <code>StudyLocus</code> <p>Study locus to finemap using PICS</p> required <code>k</code> <code>float</code> <p>Empiric constant that can be adjusted to fit the curve, 6.4 recommended.</p> <code>6.4</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>Study locus with PICS results</p> Source code in <code>src/otg/method/pics.py</code> <pre><code>@classmethod\ndef finemap(\n    cls: type[PICS], associations: StudyLocus, k: float = 6.4\n) -&gt; StudyLocus:\n    \"\"\"Run PICS on a study locus.\n\n    !!! info \"Study locus needs to be LD annotated\"\n        The study locus needs to be LD annotated before PICS can be calculated.\n\n    Args:\n        associations (StudyLocus): Study locus to finemap using PICS\n        k (float): Empiric constant that can be adjusted to fit the curve, 6.4 recommended.\n\n    Returns:\n        StudyLocus: Study locus with PICS results\n    \"\"\"\n    # Register UDF by defining the structure of the output locus array of structs\n    # it also renames tagVariantId to variantId\n\n    picsed_ldset_schema = t.ArrayType(\n        t.StructType(\n            [\n                t.StructField(\"tagVariantId\", t.StringType(), True),\n                t.StructField(\"r2Overall\", t.DoubleType(), True),\n                t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                t.StructField(\"standardError\", t.DoubleType(), True),\n            ]\n        )\n    )\n    picsed_study_locus_schema = t.ArrayType(\n        t.StructType(\n            [\n                t.StructField(\"variantId\", t.StringType(), True),\n                t.StructField(\"r2Overall\", t.DoubleType(), True),\n                t.StructField(\"posteriorProbability\", t.DoubleType(), True),\n                t.StructField(\"standardError\", t.DoubleType(), True),\n            ]\n        )\n    )\n    _finemap_udf = f.udf(\n        lambda locus, neglog_p: PICS._finemap(locus, neglog_p, k),\n        picsed_ldset_schema,\n    )\n    return StudyLocus(\n        _df=(\n            associations.df\n            # Old locus column will be dropped if available\n            .select(*[col for col in associations.df.columns if col != \"locus\"])\n            # Estimate neglog_pvalue for the lead variant\n            .withColumn(\"neglog_pvalue\", associations.neglog_pvalue())\n            # New locus containing the PICS results\n            .withColumn(\n                \"locus\",\n                f.when(\n                    f.col(\"ldSet\").isNotNull(),\n                    _finemap_udf(f.col(\"ldSet\"), f.col(\"neglog_pvalue\")).cast(\n                        picsed_study_locus_schema\n                    ),\n                ),\n            )\n            # Rename tagVariantId to variantId\n            .drop(\"neglog_pvalue\")\n        ),\n        _schema=StudyLocus.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/window_based_clumping/","title":"Window-based clumping","text":"<p>Get semi-lead snps from summary statistics using a window based function.</p> Source code in <code>src/otg/method/window_based_clumping.py</code> <pre><code>class WindowBasedClumping:\n    \"\"\"Get semi-lead snps from summary statistics using a window based function.\"\"\"\n\n    @staticmethod\n    def _cluster_peaks(\n        study: Column, chromosome: Column, position: Column, window_length: int\n    ) -&gt; Column:\n        \"\"\"Cluster GWAS significant variants, were clusters are separated by a defined distance.\n\n        !! Important to note that the length of the clusters can be arbitrarily big.\n\n        Args:\n            study (Column): study identifier\n            chromosome (Column): chromosome identifier\n            position (Column): position of the variant\n            window_length (int): window length in basepair\n\n        Returns:\n            Column: containing cluster identifier\n\n        Examples:\n            &gt;&gt;&gt; data = [\n            ...     # Cluster 1:\n            ...     ('s1', 'chr1', 2),\n            ...     ('s1', 'chr1', 4),\n            ...     ('s1', 'chr1', 12),\n            ...     # Cluster 2 - Same chromosome:\n            ...     ('s1', 'chr1', 31),\n            ...     ('s1', 'chr1', 38),\n            ...     ('s1', 'chr1', 42),\n            ...     # Cluster 3 - New chromosome:\n            ...     ('s1', 'chr2', 41),\n            ...     ('s1', 'chr2', 44),\n            ...     ('s1', 'chr2', 50),\n            ...     # Cluster 4 - other study:\n            ...     ('s2', 'chr2', 55),\n            ...     ('s2', 'chr2', 62),\n            ...     ('s2', 'chr2', 70),\n            ... ]\n            &gt;&gt;&gt; window_length = 10\n            &gt;&gt;&gt; (\n            ...     spark.createDataFrame(data, ['studyId', 'chromosome', 'position'])\n            ...     .withColumn(\"cluster_id\",\n            ...         WindowBasedClumping._cluster_peaks(\n            ...             f.col('studyId'),\n            ...             f.col('chromosome'),\n            ...             f.col('position'),\n            ...             window_length\n            ...         )\n            ...     ).show()\n            ... )\n            +-------+----------+--------+----------+\n            |studyId|chromosome|position|cluster_id|\n            +-------+----------+--------+----------+\n            |     s1|      chr1|       2| s1_chr1_2|\n            |     s1|      chr1|       4| s1_chr1_2|\n            |     s1|      chr1|      12| s1_chr1_2|\n            |     s1|      chr1|      31|s1_chr1_31|\n            |     s1|      chr1|      38|s1_chr1_31|\n            |     s1|      chr1|      42|s1_chr1_31|\n            |     s1|      chr2|      41|s1_chr2_41|\n            |     s1|      chr2|      44|s1_chr2_41|\n            |     s1|      chr2|      50|s1_chr2_41|\n            |     s2|      chr2|      55|s2_chr2_55|\n            |     s2|      chr2|      62|s2_chr2_55|\n            |     s2|      chr2|      70|s2_chr2_55|\n            +-------+----------+--------+----------+\n            &lt;BLANKLINE&gt;\n\n        \"\"\"\n        # By adding previous position, the cluster boundary can be identified:\n        previous_position = f.lag(position).over(\n            Window.partitionBy(study, chromosome).orderBy(position)\n        )\n        # We consider a cluster boudary if subsequent snps are further than the defined window:\n        cluster_id = f.when(\n            (previous_position.isNull())\n            | (position - previous_position &gt; window_length),\n            f.concat_ws(\"_\", study, chromosome, position),\n        )\n        # The cluster identifier is propagated across every variant of the cluster:\n        return f.when(\n            cluster_id.isNull(),\n            f.last(cluster_id, ignorenulls=True).over(\n                Window.partitionBy(study, chromosome)\n                .orderBy(position)\n                .rowsBetween(Window.unboundedPreceding, Window.currentRow)\n            ),\n        ).otherwise(cluster_id)\n\n    @staticmethod\n    def _prune_peak(position: ndarray, window_size: int) -&gt; DenseVector:\n        \"\"\"Establish lead snps based on their positions listed by p-value.\n\n        The function `find_peak` assigns lead SNPs based on their positions listed by p-value within a specified window size.\n\n        Args:\n            position (ndarray): positions of the SNPs sorted by p-value.\n            window_size (int): the distance in bp within which associations are clumped together around the lead snp.\n\n        Returns:\n            DenseVector: binary vector where 1 indicates a lead SNP and 0 indicates a non-lead SNP.\n\n        Examples:\n            &gt;&gt;&gt; from pyspark.ml import functions as fml\n            &gt;&gt;&gt; from pyspark.ml.linalg import DenseVector\n            &gt;&gt;&gt; WindowBasedClumping._prune_peak(np.array((3, 9, 8, 4, 6)), 2)\n            DenseVector([1.0, 1.0, 0.0, 0.0, 1.0])\n\n        \"\"\"\n        # Initializing the lead list with zeroes:\n        is_lead: ndarray = np.zeros(len(position))\n\n        # List containing indices of leads:\n        lead_indices: list = []\n\n        # Looping through all positions:\n        for index in range(len(position)):\n            # Looping through leads to find out if they are within a window:\n            for lead_index in lead_indices:\n                # If any of the leads within the window:\n                if abs(position[lead_index] - position[index]) &lt; window_size:\n                    # Skipping further checks:\n                    break\n            else:\n                # None of the leads were within the window:\n                lead_indices.append(index)\n                is_lead[index] = 1\n\n        return DenseVector(is_lead)\n\n    @classmethod\n    def clump(\n        cls: type[WindowBasedClumping],\n        summary_stats: SummaryStatistics,\n        window_length: int,\n        p_value_significance: float = 5e-8,\n    ) -&gt; StudyLocus:\n        \"\"\"Clump summary statistics by distance.\n\n        Args:\n            summary_stats (SummaryStatistics): summary statistics to clump\n            window_length (int): window length in basepair\n            p_value_significance (float): only more significant variants are considered\n\n        Returns:\n            StudyLocus: clumped summary statistics\n        \"\"\"\n        # Create window for locus clusters\n        # - variants where the distance between subsequent variants is below the defined threshold.\n        # - Variants are sorted by descending significance\n        cluster_window = Window.partitionBy(\n            \"studyId\", \"chromosome\", \"cluster_id\"\n        ).orderBy(f.col(\"pValueExponent\").asc(), f.col(\"pValueMantissa\").asc())\n\n        return StudyLocus(\n            _df=(\n                summary_stats\n                # Dropping snps below significance - all subsequent steps are done on significant variants:\n                .pvalue_filter(p_value_significance)\n                .df\n                # Clustering summary variants for efficient windowing (complexity reduction):\n                .withColumn(\n                    \"cluster_id\",\n                    WindowBasedClumping._cluster_peaks(\n                        f.col(\"studyId\"),\n                        f.col(\"chromosome\"),\n                        f.col(\"position\"),\n                        window_length,\n                    ),\n                )\n                # Within each cluster variants are ranked by significance:\n                .withColumn(\"pvRank\", f.row_number().over(cluster_window))\n                # Collect positions in cluster for the most significant variant (complexity reduction):\n                .withColumn(\n                    \"collectedPositions\",\n                    f.when(\n                        f.col(\"pvRank\") == 1,\n                        f.collect_list(f.col(\"position\")).over(\n                            cluster_window.rowsBetween(\n                                Window.currentRow, Window.unboundedFollowing\n                            )\n                        ),\n                    ).otherwise(f.array()),\n                )\n                # Get semi indices only ONCE per cluster:\n                .withColumn(\n                    \"semiIndices\",\n                    f.when(\n                        f.size(f.col(\"collectedPositions\")) &gt; 0,\n                        fml.vector_to_array(\n                            f.udf(WindowBasedClumping._prune_peak, VectorUDT())(\n                                fml.array_to_vector(f.col(\"collectedPositions\")),\n                                f.lit(window_length),\n                            )\n                        ),\n                    ),\n                )\n                # Propagating the result of the above calculation for all rows:\n                .withColumn(\n                    \"semiIndices\",\n                    f.when(\n                        f.col(\"semiIndices\").isNull(),\n                        f.first(f.col(\"semiIndices\"), ignorenulls=True).over(\n                            cluster_window\n                        ),\n                    ).otherwise(f.col(\"semiIndices\")),\n                )\n                # Keeping semi indices only:\n                .filter(f.col(\"semiIndices\")[f.col(\"pvRank\") - 1] &gt; 0)\n                .drop(\"pvRank\", \"collectedPositions\", \"semiIndices\", \"cluster_id\")\n                # Adding study-locus id:\n                .withColumn(\n                    \"studyLocusId\",\n                    StudyLocus.assign_study_locus_id(\"studyId\", \"variantId\"),\n                )\n                # Initialize QC column as array of strings:\n                .withColumn(\n                    \"qualityControls\", f.array().cast(t.ArrayType(t.StringType()))\n                )\n            ),\n            _schema=StudyLocus.get_schema(),\n        )\n\n    @classmethod\n    def clump_with_locus(\n        cls: type[WindowBasedClumping],\n        summary_stats: SummaryStatistics,\n        window_length: int,\n        p_value_significance: float = 5e-8,\n        p_value_baseline: float = 0.05,\n        locus_window_length: int | None = None,\n    ) -&gt; StudyLocus:\n        \"\"\"Clump significant associations while collecting locus around them.\n\n        Args:\n            summary_stats (SummaryStatistics): Input summary statistics dataset\n            window_length (int): Window size in  bp, used for distance based clumping.\n            p_value_significance (float, optional): GWAS significance threshold used to filter peaks. Defaults to 5e-8.\n            p_value_baseline (float, optional): Least significant threshold. Below this, all snps are dropped. Defaults to 0.05.\n            locus_window_length (int, optional): The distance for collecting locus around the semi indices.\n\n        Returns:\n            StudyLocus: StudyLocus after clumping with information about the `locus`\n        \"\"\"\n        # If no locus window provided, using the same value:\n        if locus_window_length is None:\n            locus_window_length = window_length\n\n        # Run distance based clumping on the summary stats:\n        clumped_dataframe = WindowBasedClumping.clump(\n            summary_stats,\n            window_length=window_length,\n            p_value_significance=p_value_significance,\n        ).df.alias(\"clumped\")\n\n        # Get list of columns from clumped dataset for further propagation:\n        clumped_columns = clumped_dataframe.columns\n\n        # Dropping variants not meeting the baseline criteria:\n        sumstats_baseline = summary_stats.pvalue_filter(p_value_baseline).df\n\n        # Renaming columns:\n        sumstats_baseline_renamed = sumstats_baseline.selectExpr(\n            *[f\"{col} as tag_{col}\" for col in sumstats_baseline.columns]\n        ).alias(\"sumstat\")\n\n        study_locus_df = (\n            sumstats_baseline_renamed\n            # Joining the two datasets together:\n            .join(\n                f.broadcast(clumped_dataframe),\n                on=[\n                    (f.col(\"sumstat.tag_studyId\") == f.col(\"clumped.studyId\"))\n                    &amp; (f.col(\"sumstat.tag_chromosome\") == f.col(\"clumped.chromosome\"))\n                    &amp; (\n                        f.col(\"sumstat.tag_position\")\n                        &gt;= (f.col(\"clumped.position\") - locus_window_length)\n                    )\n                    &amp; (\n                        f.col(\"sumstat.tag_position\")\n                        &lt;= (f.col(\"clumped.position\") + locus_window_length)\n                    )\n                ],\n                how=\"right\",\n            )\n            .withColumn(\n                \"locus\",\n                f.struct(\n                    f.col(\"tag_variantId\").alias(\"variantId\"),\n                    f.col(\"tag_beta\").alias(\"beta\"),\n                    f.col(\"tag_pValueMantissa\").alias(\"pValueMantissa\"),\n                    f.col(\"tag_pValueExponent\").alias(\"pValueExponent\"),\n                    f.col(\"tag_standardError\").alias(\"standardError\"),\n                ),\n            )\n            .groupby(\"studyLocusId\")\n            .agg(\n                *[\n                    f.first(col).alias(col)\n                    for col in clumped_columns\n                    if col != \"studyLocusId\"\n                ],\n                f.collect_list(f.col(\"locus\")).alias(\"locus\"),\n            )\n        )\n\n        return StudyLocus(\n            _df=study_locus_df,\n            _schema=StudyLocus.get_schema(),\n        )\n</code></pre>"},{"location":"python_api/method/window_based_clumping/#otg.method.window_based_clumping.WindowBasedClumping.clump","title":"<code>clump(summary_stats, window_length, p_value_significance=5e-08)</code>  <code>classmethod</code>","text":"<p>Clump summary statistics by distance.</p> <p>Parameters:</p> Name Type Description Default <code>summary_stats</code> <code>SummaryStatistics</code> <p>summary statistics to clump</p> required <code>window_length</code> <code>int</code> <p>window length in basepair</p> required <code>p_value_significance</code> <code>float</code> <p>only more significant variants are considered</p> <code>5e-08</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>clumped summary statistics</p> Source code in <code>src/otg/method/window_based_clumping.py</code> <pre><code>@classmethod\ndef clump(\n    cls: type[WindowBasedClumping],\n    summary_stats: SummaryStatistics,\n    window_length: int,\n    p_value_significance: float = 5e-8,\n) -&gt; StudyLocus:\n    \"\"\"Clump summary statistics by distance.\n\n    Args:\n        summary_stats (SummaryStatistics): summary statistics to clump\n        window_length (int): window length in basepair\n        p_value_significance (float): only more significant variants are considered\n\n    Returns:\n        StudyLocus: clumped summary statistics\n    \"\"\"\n    # Create window for locus clusters\n    # - variants where the distance between subsequent variants is below the defined threshold.\n    # - Variants are sorted by descending significance\n    cluster_window = Window.partitionBy(\n        \"studyId\", \"chromosome\", \"cluster_id\"\n    ).orderBy(f.col(\"pValueExponent\").asc(), f.col(\"pValueMantissa\").asc())\n\n    return StudyLocus(\n        _df=(\n            summary_stats\n            # Dropping snps below significance - all subsequent steps are done on significant variants:\n            .pvalue_filter(p_value_significance)\n            .df\n            # Clustering summary variants for efficient windowing (complexity reduction):\n            .withColumn(\n                \"cluster_id\",\n                WindowBasedClumping._cluster_peaks(\n                    f.col(\"studyId\"),\n                    f.col(\"chromosome\"),\n                    f.col(\"position\"),\n                    window_length,\n                ),\n            )\n            # Within each cluster variants are ranked by significance:\n            .withColumn(\"pvRank\", f.row_number().over(cluster_window))\n            # Collect positions in cluster for the most significant variant (complexity reduction):\n            .withColumn(\n                \"collectedPositions\",\n                f.when(\n                    f.col(\"pvRank\") == 1,\n                    f.collect_list(f.col(\"position\")).over(\n                        cluster_window.rowsBetween(\n                            Window.currentRow, Window.unboundedFollowing\n                        )\n                    ),\n                ).otherwise(f.array()),\n            )\n            # Get semi indices only ONCE per cluster:\n            .withColumn(\n                \"semiIndices\",\n                f.when(\n                    f.size(f.col(\"collectedPositions\")) &gt; 0,\n                    fml.vector_to_array(\n                        f.udf(WindowBasedClumping._prune_peak, VectorUDT())(\n                            fml.array_to_vector(f.col(\"collectedPositions\")),\n                            f.lit(window_length),\n                        )\n                    ),\n                ),\n            )\n            # Propagating the result of the above calculation for all rows:\n            .withColumn(\n                \"semiIndices\",\n                f.when(\n                    f.col(\"semiIndices\").isNull(),\n                    f.first(f.col(\"semiIndices\"), ignorenulls=True).over(\n                        cluster_window\n                    ),\n                ).otherwise(f.col(\"semiIndices\")),\n            )\n            # Keeping semi indices only:\n            .filter(f.col(\"semiIndices\")[f.col(\"pvRank\") - 1] &gt; 0)\n            .drop(\"pvRank\", \"collectedPositions\", \"semiIndices\", \"cluster_id\")\n            # Adding study-locus id:\n            .withColumn(\n                \"studyLocusId\",\n                StudyLocus.assign_study_locus_id(\"studyId\", \"variantId\"),\n            )\n            # Initialize QC column as array of strings:\n            .withColumn(\n                \"qualityControls\", f.array().cast(t.ArrayType(t.StringType()))\n            )\n        ),\n        _schema=StudyLocus.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/method/window_based_clumping/#otg.method.window_based_clumping.WindowBasedClumping.clump_with_locus","title":"<code>clump_with_locus(summary_stats, window_length, p_value_significance=5e-08, p_value_baseline=0.05, locus_window_length=None)</code>  <code>classmethod</code>","text":"<p>Clump significant associations while collecting locus around them.</p> <p>Parameters:</p> Name Type Description Default <code>summary_stats</code> <code>SummaryStatistics</code> <p>Input summary statistics dataset</p> required <code>window_length</code> <code>int</code> <p>Window size in  bp, used for distance based clumping.</p> required <code>p_value_significance</code> <code>float</code> <p>GWAS significance threshold used to filter peaks. Defaults to 5e-8.</p> <code>5e-08</code> <code>p_value_baseline</code> <code>float</code> <p>Least significant threshold. Below this, all snps are dropped. Defaults to 0.05.</p> <code>0.05</code> <code>locus_window_length</code> <code>int</code> <p>The distance for collecting locus around the semi indices.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>StudyLocus</code> <code>StudyLocus</code> <p>StudyLocus after clumping with information about the <code>locus</code></p> Source code in <code>src/otg/method/window_based_clumping.py</code> <pre><code>@classmethod\ndef clump_with_locus(\n    cls: type[WindowBasedClumping],\n    summary_stats: SummaryStatistics,\n    window_length: int,\n    p_value_significance: float = 5e-8,\n    p_value_baseline: float = 0.05,\n    locus_window_length: int | None = None,\n) -&gt; StudyLocus:\n    \"\"\"Clump significant associations while collecting locus around them.\n\n    Args:\n        summary_stats (SummaryStatistics): Input summary statistics dataset\n        window_length (int): Window size in  bp, used for distance based clumping.\n        p_value_significance (float, optional): GWAS significance threshold used to filter peaks. Defaults to 5e-8.\n        p_value_baseline (float, optional): Least significant threshold. Below this, all snps are dropped. Defaults to 0.05.\n        locus_window_length (int, optional): The distance for collecting locus around the semi indices.\n\n    Returns:\n        StudyLocus: StudyLocus after clumping with information about the `locus`\n    \"\"\"\n    # If no locus window provided, using the same value:\n    if locus_window_length is None:\n        locus_window_length = window_length\n\n    # Run distance based clumping on the summary stats:\n    clumped_dataframe = WindowBasedClumping.clump(\n        summary_stats,\n        window_length=window_length,\n        p_value_significance=p_value_significance,\n    ).df.alias(\"clumped\")\n\n    # Get list of columns from clumped dataset for further propagation:\n    clumped_columns = clumped_dataframe.columns\n\n    # Dropping variants not meeting the baseline criteria:\n    sumstats_baseline = summary_stats.pvalue_filter(p_value_baseline).df\n\n    # Renaming columns:\n    sumstats_baseline_renamed = sumstats_baseline.selectExpr(\n        *[f\"{col} as tag_{col}\" for col in sumstats_baseline.columns]\n    ).alias(\"sumstat\")\n\n    study_locus_df = (\n        sumstats_baseline_renamed\n        # Joining the two datasets together:\n        .join(\n            f.broadcast(clumped_dataframe),\n            on=[\n                (f.col(\"sumstat.tag_studyId\") == f.col(\"clumped.studyId\"))\n                &amp; (f.col(\"sumstat.tag_chromosome\") == f.col(\"clumped.chromosome\"))\n                &amp; (\n                    f.col(\"sumstat.tag_position\")\n                    &gt;= (f.col(\"clumped.position\") - locus_window_length)\n                )\n                &amp; (\n                    f.col(\"sumstat.tag_position\")\n                    &lt;= (f.col(\"clumped.position\") + locus_window_length)\n                )\n            ],\n            how=\"right\",\n        )\n        .withColumn(\n            \"locus\",\n            f.struct(\n                f.col(\"tag_variantId\").alias(\"variantId\"),\n                f.col(\"tag_beta\").alias(\"beta\"),\n                f.col(\"tag_pValueMantissa\").alias(\"pValueMantissa\"),\n                f.col(\"tag_pValueExponent\").alias(\"pValueExponent\"),\n                f.col(\"tag_standardError\").alias(\"standardError\"),\n            ),\n        )\n        .groupby(\"studyLocusId\")\n        .agg(\n            *[\n                f.first(col).alias(col)\n                for col in clumped_columns\n                if col != \"studyLocusId\"\n            ],\n            f.collect_list(f.col(\"locus\")).alias(\"locus\"),\n        )\n    )\n\n    return StudyLocus(\n        _df=study_locus_df,\n        _schema=StudyLocus.get_schema(),\n    )\n</code></pre>"},{"location":"python_api/step/_step/","title":"Step","text":"<p>TBC</p>"},{"location":"python_api/step/colocalisation/","title":"Colocalisation","text":"<p>             Bases: <code>ColocalisationStepConfig</code></p> <p>Colocalisation step.</p> <p>This workflow runs colocalization analyses that assess the degree to which independent signals of the association share the same causal variant in a region of the genome, typically limited by linkage disequilibrium (LD).</p> Source code in <code>src/otg/colocalisation.py</code> <pre><code>@dataclass\nclass ColocalisationStep(ColocalisationStepConfig):\n    \"\"\"Colocalisation step.\n\n    This workflow runs colocalization analyses that assess the degree to which independent signals of the association share the same causal variant in a region of the genome, typically limited by linkage disequilibrium (LD).\n    \"\"\"\n\n    session: Session = Session()\n\n    def run(self: ColocalisationStep) -&gt; None:\n        \"\"\"Run colocalisation step.\"\"\"\n        # Study-locus information\n        sl = StudyLocus.from_parquet(self.session, self.study_locus_path)\n        si = StudyIndex.from_parquet(self.session, self.study_index_path)\n\n        # Study-locus overlaps for 95% credible sets\n        sl_overlaps = sl.credible_set(CredibleInterval.IS95).overlaps(si)\n\n        coloc_results = Coloc.colocalise(\n            sl_overlaps, self.priorc1, self.priorc2, self.priorc12\n        )\n        ecaviar_results = ECaviar.colocalise(sl_overlaps)\n\n        coloc_results.df.unionByName(ecaviar_results.df, allowMissingColumns=True)\n\n        coloc_results.df.write.mode(self.session.write_mode).parquet(self.coloc_path)\n</code></pre> <p>Colocalisation step requirements.</p> <p>Attributes:</p> Name Type Description <code>study_locus_path</code> <code>DictConfig</code> <p>Input Study-locus path.</p> <code>coloc_path</code> <code>DictConfig</code> <p>Output Colocalisation path.</p> <code>priorc1</code> <code>float</code> <p>Prior on variant being causal for trait 1.</p> <code>priorc2</code> <code>float</code> <p>Prior on variant being causal for trait 2.</p> <code>priorc12</code> <code>float</code> <p>Prior on variant being causal for traits 1 and 2.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass ColocalisationStepConfig:\n    \"\"\"Colocalisation step requirements.\n\n    Attributes:\n        study_locus_path (DictConfig): Input Study-locus path.\n        coloc_path (DictConfig): Output Colocalisation path.\n        priorc1 (float): Prior on variant being causal for trait 1.\n        priorc2 (float): Prior on variant being causal for trait 2.\n        priorc12 (float): Prior on variant being causal for traits 1 and 2.\n    \"\"\"\n\n    _target_: str = \"otg.colocalisation.ColocalisationStep\"\n    study_locus_path: str = MISSING\n    study_index_path: str = MISSING\n    coloc_path: str = MISSING\n    priorc1: float = 1e-4\n    priorc2: float = 1e-4\n    priorc12: float = 1e-5\n</code></pre>"},{"location":"python_api/step/colocalisation/#otg.colocalisation.ColocalisationStep.run","title":"<code>run()</code>","text":"<p>Run colocalisation step.</p> Source code in <code>src/otg/colocalisation.py</code> <pre><code>def run(self: ColocalisationStep) -&gt; None:\n    \"\"\"Run colocalisation step.\"\"\"\n    # Study-locus information\n    sl = StudyLocus.from_parquet(self.session, self.study_locus_path)\n    si = StudyIndex.from_parquet(self.session, self.study_index_path)\n\n    # Study-locus overlaps for 95% credible sets\n    sl_overlaps = sl.credible_set(CredibleInterval.IS95).overlaps(si)\n\n    coloc_results = Coloc.colocalise(\n        sl_overlaps, self.priorc1, self.priorc2, self.priorc12\n    )\n    ecaviar_results = ECaviar.colocalise(sl_overlaps)\n\n    coloc_results.df.unionByName(ecaviar_results.df, allowMissingColumns=True)\n\n    coloc_results.df.write.mode(self.session.write_mode).parquet(self.coloc_path)\n</code></pre>"},{"location":"python_api/step/finngen/","title":"FinnGen","text":"<p>             Bases: <code>FinnGenStepConfig</code></p> <p>FinnGen ingestion step.</p> Source code in <code>src/otg/finngen.py</code> <pre><code>@dataclass\nclass FinnGenStep(FinnGenStepConfig):\n    \"\"\"FinnGen ingestion step.\"\"\"\n\n    session: Session = Session()\n\n    def run(self: FinnGenStep) -&gt; None:\n        \"\"\"Run FinnGen ingestion step.\"\"\"\n        # Read the JSON data from the URL.\n        json_data = urlopen(self.finngen_phenotype_table_url).read().decode(\"utf-8\")\n        rdd = self.session.spark.sparkContext.parallelize([json_data])\n        df = self.session.spark.read.json(rdd)\n\n        # Parse the study index data.\n        finngen_studies = FinnGenStudyIndex.from_source(\n            df,\n            self.finngen_release_prefix,\n            self.finngen_sumstat_url_prefix,\n            self.finngen_sumstat_url_suffix,\n        )\n\n        # Write the study index output.\n        finngen_studies.df.write.mode(self.session.write_mode).parquet(\n            self.finngen_study_index_out\n        )\n\n        # Prepare list of files for ingestion.\n        input_filenames = [\n            row.summarystatsLocation for row in finngen_studies.collect()\n        ]\n        summary_stats_df = self.session.spark.read.option(\"delimiter\", \"\\t\").csv(\n            input_filenames, header=True\n        )\n\n        # Specify data processing instructions.\n        summary_stats_df = FinnGenSummaryStats.from_finngen_harmonized_summary_stats(\n            summary_stats_df\n        ).df\n\n        # Sort and partition for output.\n        summary_stats_df.sortWithinPartitions(\"position\").write.partitionBy(\n            \"studyId\", \"chromosome\"\n        ).mode(self.session.write_mode).parquet(self.finngen_summary_stats_out)\n</code></pre> <p>FinnGen study table ingestion step requirements.</p> <p>Attributes:</p> Name Type Description <code>finngen_phenotype_table_url</code> <code>str</code> <p>FinnGen API for fetching the list of studies.</p> <code>finngen_release_prefix</code> <code>str</code> <p>Release prefix pattern.</p> <code>finngen_sumstat_url_prefix</code> <code>str</code> <p>URL prefix for summary statistics location.</p> <code>finngen_sumstat_url_suffix</code> <code>str</code> <p>URL prefix suffix for summary statistics location.</p> <code>finngen_study_index_out</code> <code>str</code> <p>Output path for the FinnGen study index dataset.</p> <code>finngen_summary_stats_out</code> <code>str</code> <p>Output path for the FinnGen summary statistics.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass FinnGenStepConfig:\n    \"\"\"FinnGen study table ingestion step requirements.\n\n    Attributes:\n        finngen_phenotype_table_url (str): FinnGen API for fetching the list of studies.\n        finngen_release_prefix (str): Release prefix pattern.\n        finngen_sumstat_url_prefix (str): URL prefix for summary statistics location.\n        finngen_sumstat_url_suffix (str): URL prefix suffix for summary statistics location.\n        finngen_study_index_out (str): Output path for the FinnGen study index dataset.\n        finngen_summary_stats_out (str): Output path for the FinnGen summary statistics.\n    \"\"\"\n\n    _target_: str = \"otg.finngen.FinnGenStep\"\n    finngen_phenotype_table_url: str = MISSING\n    finngen_release_prefix: str = MISSING\n    finngen_sumstat_url_prefix: str = MISSING\n    finngen_sumstat_url_suffix: str = MISSING\n    finngen_study_index_out: str = MISSING\n    finngen_summary_stats_out: str = MISSING\n</code></pre>"},{"location":"python_api/step/finngen/#otg.finngen.FinnGenStep.run","title":"<code>run()</code>","text":"<p>Run FinnGen ingestion step.</p> Source code in <code>src/otg/finngen.py</code> <pre><code>def run(self: FinnGenStep) -&gt; None:\n    \"\"\"Run FinnGen ingestion step.\"\"\"\n    # Read the JSON data from the URL.\n    json_data = urlopen(self.finngen_phenotype_table_url).read().decode(\"utf-8\")\n    rdd = self.session.spark.sparkContext.parallelize([json_data])\n    df = self.session.spark.read.json(rdd)\n\n    # Parse the study index data.\n    finngen_studies = FinnGenStudyIndex.from_source(\n        df,\n        self.finngen_release_prefix,\n        self.finngen_sumstat_url_prefix,\n        self.finngen_sumstat_url_suffix,\n    )\n\n    # Write the study index output.\n    finngen_studies.df.write.mode(self.session.write_mode).parquet(\n        self.finngen_study_index_out\n    )\n\n    # Prepare list of files for ingestion.\n    input_filenames = [\n        row.summarystatsLocation for row in finngen_studies.collect()\n    ]\n    summary_stats_df = self.session.spark.read.option(\"delimiter\", \"\\t\").csv(\n        input_filenames, header=True\n    )\n\n    # Specify data processing instructions.\n    summary_stats_df = FinnGenSummaryStats.from_finngen_harmonized_summary_stats(\n        summary_stats_df\n    ).df\n\n    # Sort and partition for output.\n    summary_stats_df.sortWithinPartitions(\"position\").write.partitionBy(\n        \"studyId\", \"chromosome\"\n    ).mode(self.session.write_mode).parquet(self.finngen_summary_stats_out)\n</code></pre>"},{"location":"python_api/step/gene_index/","title":"Gene index","text":"<p>             Bases: <code>GeneIndexStepConfig</code></p> <p>Gene index step.</p> <p>This step generates a gene index dataset from an Open Targets Platform target dataset.</p> Source code in <code>src/otg/gene_index.py</code> <pre><code>@dataclass\nclass GeneIndexStep(GeneIndexStepConfig):\n    \"\"\"Gene index step.\n\n    This step generates a gene index dataset from an Open Targets Platform target dataset.\n    \"\"\"\n\n    session: Session = Session()\n\n    def run(self: GeneIndexStep) -&gt; None:\n        \"\"\"Run Target index step.\"\"\"\n        # Extract\n        platform_target = self.session.spark.read.parquet(self.target_path)\n        # Transform\n        gene_index = OpenTargetsTarget.as_gene_index(platform_target)\n        # Load\n        gene_index.df.write.mode(self.session.write_mode).parquet(self.gene_index_path)\n</code></pre> <p>Gene index step requirements.</p> <p>Attributes:</p> Name Type Description <code>target_path</code> <code>str</code> <p>Open targets Platform target dataset path.</p> <code>gene_index_path</code> <code>str</code> <p>Output gene index path.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass GeneIndexStepConfig:\n    \"\"\"Gene index step requirements.\n\n    Attributes:\n        target_path (str): Open targets Platform target dataset path.\n        gene_index_path (str): Output gene index path.\n    \"\"\"\n\n    _target_: str = \"otg.gene_index.GeneIndexStep\"\n    target_path: str = MISSING\n    gene_index_path: str = MISSING\n</code></pre>"},{"location":"python_api/step/gene_index/#otg.gene_index.GeneIndexStep.run","title":"<code>run()</code>","text":"<p>Run Target index step.</p> Source code in <code>src/otg/gene_index.py</code> <pre><code>def run(self: GeneIndexStep) -&gt; None:\n    \"\"\"Run Target index step.\"\"\"\n    # Extract\n    platform_target = self.session.spark.read.parquet(self.target_path)\n    # Transform\n    gene_index = OpenTargetsTarget.as_gene_index(platform_target)\n    # Load\n    gene_index.df.write.mode(self.session.write_mode).parquet(self.gene_index_path)\n</code></pre>"},{"location":"python_api/step/gwas_catalog/","title":"GWAS Catalog","text":"<p>             Bases: <code>GWASCatalogStepConfig</code></p> <p>GWAS Catalog step.</p> Source code in <code>src/otg/gwas_catalog.py</code> <pre><code>@dataclass\nclass GWASCatalogStep(GWASCatalogStepConfig):\n    \"\"\"GWAS Catalog step.\"\"\"\n\n    session: Session = Session()\n\n    def run(self: GWASCatalogStep) -&gt; None:\n        \"\"\"Run GWAS Catalog ingestion step to extract GWASCatalog Study and StudyLocus tables.\"\"\"\n        hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n        # All inputs:\n        # Variant annotation dataset\n        va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n        # GWAS Catalog raw study information\n        catalog_studies = self.session.spark.read.csv(\n            self.catalog_studies_file, sep=\"\\t\", header=True\n        )\n        # GWAS Catalog ancestry information\n        ancestry_lut = self.session.spark.read.csv(\n            self.catalog_ancestry_file, sep=\"\\t\", header=True\n        )\n        # GWAS Catalog summary statistics information\n        sumstats_lut = self.session.spark.read.csv(\n            self.catalog_sumstats_lut, sep=\"\\t\", header=False\n        )\n        # GWAS Catalog raw association information\n        catalog_associations = self.session.spark.read.csv(\n            self.catalog_associations_file, sep=\"\\t\", header=True\n        )\n        # LD index dataset\n        ld_index = LDIndex.from_parquet(self.session, self.ld_index_path)\n\n        # Transform:\n        # GWAS Catalog study index and study-locus splitted\n        study_index, study_locus = GWASCatalogStudySplitter.split(\n            GWASCatalogStudyIndex.from_source(\n                catalog_studies, ancestry_lut, sumstats_lut\n            ),\n            GWASCatalogAssociations.from_source(catalog_associations, va),\n        )\n\n        # Annotate LD information and clump associations dataset\n        study_locus_ld = LDAnnotator.ld_annotate(study_locus, study_index, ld_index)\n\n        # Fine-mapping LD-clumped study-locus using PICS\n        finemapped_study_locus = PICS.finemap(study_locus_ld).annotate_credible_sets()\n\n        # Write:\n        study_index.df.write.mode(self.session.write_mode).parquet(\n            self.catalog_studies_out\n        )\n        finemapped_study_locus.df.write.mode(self.session.write_mode).parquet(\n            self.catalog_associations_out\n        )\n</code></pre> <p>GWAS Catalog step requirements.</p> <p>Attributes:</p> Name Type Description <code>catalog_studies_file</code> <code>str</code> <p>Raw GWAS catalog studies file.</p> <code>catalog_ancestry_file</code> <code>str</code> <p>Ancestry annotations file from GWAS Catalog.</p> <code>catalog_sumstats_lut</code> <code>str</code> <p>GWAS Catalog summary statistics lookup table.</p> <code>catalog_associations_file</code> <code>str</code> <p>Raw GWAS catalog associations file.</p> <code>variant_annotation_path</code> <code>str</code> <p>Input variant annotation path.</p> <code>ld_populations</code> <code>list</code> <p>List of populations to include.</p> <code>min_r2</code> <code>float</code> <p>Minimum r2 to consider when considering variants within a window.</p> <code>catalog_studies_out</code> <code>str</code> <p>Output GWAS catalog studies path.</p> <code>catalog_associations_out</code> <code>str</code> <p>Output GWAS catalog associations path.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass GWASCatalogStepConfig:\n    \"\"\"GWAS Catalog step requirements.\n\n    Attributes:\n        catalog_studies_file (str): Raw GWAS catalog studies file.\n        catalog_ancestry_file (str): Ancestry annotations file from GWAS Catalog.\n        catalog_sumstats_lut (str): GWAS Catalog summary statistics lookup table.\n        catalog_associations_file (str): Raw GWAS catalog associations file.\n        variant_annotation_path (str): Input variant annotation path.\n        ld_populations (list): List of populations to include.\n        min_r2 (float): Minimum r2 to consider when considering variants within a window.\n        catalog_studies_out (str): Output GWAS catalog studies path.\n        catalog_associations_out (str): Output GWAS catalog associations path.\n    \"\"\"\n\n    _target_: str = \"otg.gwas_catalog.GWASCatalogStep\"\n    catalog_studies_file: str = MISSING\n    catalog_ancestry_file: str = MISSING\n    catalog_sumstats_lut: str = MISSING\n    catalog_associations_file: str = MISSING\n    variant_annotation_path: str = MISSING\n    ld_index_path: str = MISSING\n    min_r2: float = 0.5\n    catalog_studies_out: str = MISSING\n    catalog_associations_out: str = MISSING\n</code></pre>"},{"location":"python_api/step/gwas_catalog/#otg.gwas_catalog.GWASCatalogStep.run","title":"<code>run()</code>","text":"<p>Run GWAS Catalog ingestion step to extract GWASCatalog Study and StudyLocus tables.</p> Source code in <code>src/otg/gwas_catalog.py</code> <pre><code>def run(self: GWASCatalogStep) -&gt; None:\n    \"\"\"Run GWAS Catalog ingestion step to extract GWASCatalog Study and StudyLocus tables.\"\"\"\n    hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n    # All inputs:\n    # Variant annotation dataset\n    va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n    # GWAS Catalog raw study information\n    catalog_studies = self.session.spark.read.csv(\n        self.catalog_studies_file, sep=\"\\t\", header=True\n    )\n    # GWAS Catalog ancestry information\n    ancestry_lut = self.session.spark.read.csv(\n        self.catalog_ancestry_file, sep=\"\\t\", header=True\n    )\n    # GWAS Catalog summary statistics information\n    sumstats_lut = self.session.spark.read.csv(\n        self.catalog_sumstats_lut, sep=\"\\t\", header=False\n    )\n    # GWAS Catalog raw association information\n    catalog_associations = self.session.spark.read.csv(\n        self.catalog_associations_file, sep=\"\\t\", header=True\n    )\n    # LD index dataset\n    ld_index = LDIndex.from_parquet(self.session, self.ld_index_path)\n\n    # Transform:\n    # GWAS Catalog study index and study-locus splitted\n    study_index, study_locus = GWASCatalogStudySplitter.split(\n        GWASCatalogStudyIndex.from_source(\n            catalog_studies, ancestry_lut, sumstats_lut\n        ),\n        GWASCatalogAssociations.from_source(catalog_associations, va),\n    )\n\n    # Annotate LD information and clump associations dataset\n    study_locus_ld = LDAnnotator.ld_annotate(study_locus, study_index, ld_index)\n\n    # Fine-mapping LD-clumped study-locus using PICS\n    finemapped_study_locus = PICS.finemap(study_locus_ld).annotate_credible_sets()\n\n    # Write:\n    study_index.df.write.mode(self.session.write_mode).parquet(\n        self.catalog_studies_out\n    )\n    finemapped_study_locus.df.write.mode(self.session.write_mode).parquet(\n        self.catalog_associations_out\n    )\n</code></pre>"},{"location":"python_api/step/gwas_catalog_sumstat_preprocess/","title":"GWAS Catalog sumstat preprocess","text":"<p>             Bases: <code>GWASCatalogSumstatsPreprocessConfig</code></p> <p>Step to preprocess GWAS Catalog harmonised summary stats.</p> Source code in <code>src/otg/gwas_catalog_sumstat_preprocess.py</code> <pre><code>@dataclass\nclass GWASCatalogSumstatsPreprocessStep(GWASCatalogSumstatsPreprocessConfig):\n    \"\"\"Step to preprocess GWAS Catalog harmonised summary stats.\"\"\"\n\n    session: Session = Session()\n\n    def run(self: GWASCatalogSumstatsPreprocessStep) -&gt; None:\n        \"\"\"Run Step.\"\"\"\n        # Extract\n        self.session.logger.info(self.raw_sumstats_path)\n        self.session.logger.info(self.out_sumstats_path)\n        self.session.logger.info(self.study_id)\n\n        # Reading dataset:\n        raw_dataset = self.session.spark.read.csv(\n            self.raw_sumstats_path, header=True, sep=\"\\t\"\n        )\n        self.session.logger.info(\n            f\"Number of single point associations: {raw_dataset.count()}\"\n        )\n\n        # Processing dataset:\n        GWASCatalogSummaryStatistics.from_gwas_harmonized_summary_stats(\n            raw_dataset, self.study_id\n        ).df.write.mode(self.session.write_mode).parquet(self.out_sumstats_path)\n        self.session.logger.info(\"Processing dataset successfully completed.\")\n</code></pre> <p>GWAS Catalog Sumstats Preprocessing step requirements.</p> <p>Attributes:</p> Name Type Description <code>raw_sumstats_path</code> <code>str</code> <p>Input raw GWAS Catalog summary statistics path.</p> <code>out_sumstats_path</code> <code>str</code> <p>Output GWAS Catalog summary statistics path.</p> <code>study_id</code> <code>str</code> <p>GWAS Catalog study identifier.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass GWASCatalogSumstatsPreprocessConfig:\n    \"\"\"GWAS Catalog Sumstats Preprocessing step requirements.\n\n    Attributes:\n        raw_sumstats_path (str): Input raw GWAS Catalog summary statistics path.\n        out_sumstats_path (str): Output GWAS Catalog summary statistics path.\n        study_id (str): GWAS Catalog study identifier.\n    \"\"\"\n\n    _target_: str = (\n        \"otg.gwas_catalog_sumstat_preprocess.GWASCatalogSumstatsPreprocessStep\"\n    )\n    raw_sumstats_path: str = MISSING\n    out_sumstats_path: str = MISSING\n    study_id: str = MISSING\n</code></pre>"},{"location":"python_api/step/gwas_catalog_sumstat_preprocess/#otg.gwas_catalog_sumstat_preprocess.GWASCatalogSumstatsPreprocessStep.run","title":"<code>run()</code>","text":"<p>Run Step.</p> Source code in <code>src/otg/gwas_catalog_sumstat_preprocess.py</code> <pre><code>def run(self: GWASCatalogSumstatsPreprocessStep) -&gt; None:\n    \"\"\"Run Step.\"\"\"\n    # Extract\n    self.session.logger.info(self.raw_sumstats_path)\n    self.session.logger.info(self.out_sumstats_path)\n    self.session.logger.info(self.study_id)\n\n    # Reading dataset:\n    raw_dataset = self.session.spark.read.csv(\n        self.raw_sumstats_path, header=True, sep=\"\\t\"\n    )\n    self.session.logger.info(\n        f\"Number of single point associations: {raw_dataset.count()}\"\n    )\n\n    # Processing dataset:\n    GWASCatalogSummaryStatistics.from_gwas_harmonized_summary_stats(\n        raw_dataset, self.study_id\n    ).df.write.mode(self.session.write_mode).parquet(self.out_sumstats_path)\n    self.session.logger.info(\"Processing dataset successfully completed.\")\n</code></pre>"},{"location":"python_api/step/ld_index/","title":"LD index","text":"<p>             Bases: <code>LDIndexStepConfig</code></p> <p>LD index step.</p> <p>This step is resource intensive</p> <p>Suggested params: high memory machine, 5TB of boot disk, no SSDs.</p> Source code in <code>src/otg/ld_index.py</code> <pre><code>@dataclass\nclass LDIndexStep(LDIndexStepConfig):\n    \"\"\"LD index step.\n\n    !!! warning \"This step is resource intensive\"\n        Suggested params: high memory machine, 5TB of boot disk, no SSDs.\n\n    \"\"\"\n\n    session: Session = Session()\n\n    def run(self: LDIndexStep) -&gt; None:\n        \"\"\"Run LD index dump step.\"\"\"\n        hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n        ld_index = GnomADLDMatrix.as_ld_index(\n            self.ld_populations,\n            self.ld_matrix_template,\n            self.ld_index_raw_template,\n            self.grch37_to_grch38_chain_path,\n            self.min_r2,\n        )\n        self.session.logger.info(f\"Writing LD index to: {self.ld_index_out}\")\n        (\n            ld_index.df.write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(f\"{self.ld_index_out}\")\n        )\n</code></pre> <p>LD matrix step requirements.</p> <p>Attributes:</p> Name Type Description <code>ld_matrix_template</code> <code>str</code> <p>Template path for LD matrix from gnomAD.</p> <code>ld_index_raw_template</code> <code>str</code> <p>Template path for the variant indices correspondance in the LD Matrix from gnomAD.</p> <code>min_r2</code> <code>float</code> <p>Minimum r2 to consider when considering variants within a window.</p> <code>grch37_to_grch38_chain_path</code> <code>str</code> <p>Path to GRCh37 to GRCh38 chain file.</p> <code>ld_populations</code> <code>List[str]</code> <p>List of population-specific LD matrices to process.</p> <code>ld_index_out</code> <code>str</code> <p>Output LD index path.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass LDIndexStepConfig:\n    \"\"\"LD matrix step requirements.\n\n    Attributes:\n        ld_matrix_template (str): Template path for LD matrix from gnomAD.\n        ld_index_raw_template (str): Template path for the variant indices correspondance in the LD Matrix from gnomAD.\n        min_r2 (float): Minimum r2 to consider when considering variants within a window.\n        grch37_to_grch38_chain_path (str): Path to GRCh37 to GRCh38 chain file.\n        ld_populations (List[str]): List of population-specific LD matrices to process.\n        ld_index_out (str): Output LD index path.\n    \"\"\"\n\n    _target_: str = \"otg.ld_index.LDIndexStep\"\n    ld_matrix_template: str = \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.adj.ld.bm\"\n    ld_index_raw_template: str = \"gs://gcp-public-data--gnomad/release/2.1.1/ld/gnomad.genomes.r2.1.1.{POP}.common.ld.variant_indices.ht\"\n    min_r2: float = 0.5\n    grch37_to_grch38_chain_path: str = (\n        \"gs://hail-common/references/grch37_to_grch38.over.chain.gz\"\n    )\n    ld_populations: List[str] = field(\n        default_factory=lambda: [\n            \"afr\",  # African-American\n            \"amr\",  # American Admixed/Latino\n            \"asj\",  # Ashkenazi Jewish\n            \"eas\",  # East Asian\n            \"fin\",  # Finnish\n            \"nfe\",  # Non-Finnish European\n            \"nwe\",  # Northwestern European\n            \"seu\",  # Southeastern European\n        ]\n    )\n    ld_index_out: str = MISSING\n</code></pre>"},{"location":"python_api/step/ld_index/#otg.ld_index.LDIndexStep.run","title":"<code>run()</code>","text":"<p>Run LD index dump step.</p> Source code in <code>src/otg/ld_index.py</code> <pre><code>def run(self: LDIndexStep) -&gt; None:\n    \"\"\"Run LD index dump step.\"\"\"\n    hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n    ld_index = GnomADLDMatrix.as_ld_index(\n        self.ld_populations,\n        self.ld_matrix_template,\n        self.ld_index_raw_template,\n        self.grch37_to_grch38_chain_path,\n        self.min_r2,\n    )\n    self.session.logger.info(f\"Writing LD index to: {self.ld_index_out}\")\n    (\n        ld_index.df.write.partitionBy(\"chromosome\")\n        .mode(self.session.write_mode)\n        .parquet(f\"{self.ld_index_out}\")\n    )\n</code></pre>"},{"location":"python_api/step/ukbiobank/","title":"UKBiobank","text":"<p>             Bases: <code>UKBiobankStepConfig</code></p> <p>UKBiobank study table ingestion step.</p> Source code in <code>src/otg/ukbiobank.py</code> <pre><code>@dataclass\nclass UKBiobankStep(UKBiobankStepConfig):\n    \"\"\"UKBiobank study table ingestion step.\"\"\"\n\n    session: Session = Session()\n\n    def run(self: UKBiobankStep) -&gt; None:\n        \"\"\"Run UKBiobank study table ingestion step.\"\"\"\n        # Read in the UKBiobank manifest tsv file.\n        df = self.session.spark.read.csv(\n            self.ukbiobank_manifest, sep=\"\\t\", header=True, inferSchema=True\n        )\n\n        # Parse the study index data.\n        ukbiobank_study_index = UKBiobankStudyIndex.from_source(df)\n\n        # Write the output.\n        ukbiobank_study_index.df.write.mode(self.session.write_mode).parquet(\n            self.ukbiobank_study_index_out\n        )\n</code></pre> <p>UKBiobank study table ingestion step requirements.</p> <p>Attributes:</p> Name Type Description <code>ukbiobank_manifest</code> <code>str</code> <p>UKBiobank manifest of studies.</p> <code>ukbiobank_study_index_out</code> <code>str</code> <p>Output path for the UKBiobank study index dataset.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass UKBiobankStepConfig:\n    \"\"\"UKBiobank study table ingestion step requirements.\n\n    Attributes:\n        ukbiobank_manifest (str): UKBiobank manifest of studies.\n        ukbiobank_study_index_out (str): Output path for the UKBiobank study index dataset.\n    \"\"\"\n\n    _target_: str = \"otg.ukbiobank.UKBiobankStep\"\n    ukbiobank_manifest: str = MISSING\n    ukbiobank_study_index_out: str = MISSING\n</code></pre>"},{"location":"python_api/step/ukbiobank/#otg.ukbiobank.UKBiobankStep.run","title":"<code>run()</code>","text":"<p>Run UKBiobank study table ingestion step.</p> Source code in <code>src/otg/ukbiobank.py</code> <pre><code>def run(self: UKBiobankStep) -&gt; None:\n    \"\"\"Run UKBiobank study table ingestion step.\"\"\"\n    # Read in the UKBiobank manifest tsv file.\n    df = self.session.spark.read.csv(\n        self.ukbiobank_manifest, sep=\"\\t\", header=True, inferSchema=True\n    )\n\n    # Parse the study index data.\n    ukbiobank_study_index = UKBiobankStudyIndex.from_source(df)\n\n    # Write the output.\n    ukbiobank_study_index.df.write.mode(self.session.write_mode).parquet(\n        self.ukbiobank_study_index_out\n    )\n</code></pre>"},{"location":"python_api/step/variant_annotation_step/","title":"Variant annotation","text":"<p>             Bases: <code>VariantAnnotationStepConfig</code></p> <p>Variant annotation step.</p> <p>Variant annotation step produces a dataset of the type <code>VariantAnnotation</code> derived from gnomADs <code>gnomad.genomes.vX.X.X.sites.ht</code> Hail's table. This dataset is used to validate variants and as a source of annotation.</p> Source code in <code>src/otg/variant_annotation.py</code> <pre><code>@dataclass\nclass VariantAnnotationStep(VariantAnnotationStepConfig):\n    \"\"\"Variant annotation step.\n\n    Variant annotation step produces a dataset of the type `VariantAnnotation` derived from gnomADs `gnomad.genomes.vX.X.X.sites.ht` Hail's table. This dataset is used to validate variants and as a source of annotation.\n    \"\"\"\n\n    session: Session = Session()\n\n    def run(self: VariantAnnotationStep) -&gt; None:\n        \"\"\"Run variant annotation step.\"\"\"\n        # init hail session\n        hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n\n        \"\"\"Run variant annotation step.\"\"\"\n        variant_annotation = GnomADVariants.as_variant_annotation(\n            self.gnomad_genomes,\n            self.chain_38_to_37,\n            self.populations,\n        )\n        # Writing data partitioned by chromosome and position:\n        (\n            variant_annotation.df.repartition(400, \"chromosome\")\n            .sortWithinPartitions(\"chromosome\", \"position\")\n            .write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.variant_annotation_path)\n        )\n</code></pre> <p>Variant annotation step requirements.</p> <p>Attributes:</p> Name Type Description <code>gnomad_genomes</code> <code>str</code> <p>Path to gnomAD genomes hail table.</p> <code>chain_38_to_37</code> <code>str</code> <p>Path to GRCh38 to GRCh37 chain file.</p> <code>variant_annotation_path</code> <code>str</code> <p>Output variant annotation path.</p> <code>populations</code> <code>List[str]</code> <p>List of populations to include.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass VariantAnnotationStepConfig:\n    \"\"\"Variant annotation step requirements.\n\n    Attributes:\n        gnomad_genomes (str): Path to gnomAD genomes hail table.\n        chain_38_to_37 (str): Path to GRCh38 to GRCh37 chain file.\n        variant_annotation_path (str): Output variant annotation path.\n        populations (List[str]): List of populations to include.\n    \"\"\"\n\n    _target_: str = \"otg.variant_annotation.VariantAnnotationStep\"\n    gnomad_genomes: str = MISSING\n    chain_38_to_37: str = MISSING\n    variant_annotation_path: str = MISSING\n    populations: List[str] = field(\n        default_factory=lambda: [\n            \"afr\",  # African-American\n            \"amr\",  # American Admixed/Latino\n            \"ami\",  # Amish ancestry\n            \"asj\",  # Ashkenazi Jewish\n            \"eas\",  # East Asian\n            \"fin\",  # Finnish\n            \"nfe\",  # Non-Finnish European\n            \"mid\",  # Middle Eastern\n            \"sas\",  # South Asian\n            \"oth\",  # Other\n        ]\n    )\n</code></pre>"},{"location":"python_api/step/variant_annotation_step/#otg.variant_annotation.VariantAnnotationStep.run","title":"<code>run()</code>","text":"<p>Run variant annotation step.</p> Source code in <code>src/otg/variant_annotation.py</code> <pre><code>def run(self: VariantAnnotationStep) -&gt; None:\n    \"\"\"Run variant annotation step.\"\"\"\n    # init hail session\n    hl.init(sc=self.session.spark.sparkContext, log=\"/dev/null\")\n\n    \"\"\"Run variant annotation step.\"\"\"\n    variant_annotation = GnomADVariants.as_variant_annotation(\n        self.gnomad_genomes,\n        self.chain_38_to_37,\n        self.populations,\n    )\n    # Writing data partitioned by chromosome and position:\n    (\n        variant_annotation.df.repartition(400, \"chromosome\")\n        .sortWithinPartitions(\"chromosome\", \"position\")\n        .write.partitionBy(\"chromosome\")\n        .mode(self.session.write_mode)\n        .parquet(self.variant_annotation_path)\n    )\n</code></pre>"},{"location":"python_api/step/variant_index_step/","title":"Variant index","text":"<p>             Bases: <code>VariantIndexStepConfig</code></p> <p>Variant index step.</p> <p>Using a <code>VariantAnnotation</code> dataset as a reference, this step creates and writes a dataset of the type <code>VariantIndex</code> that includes only variants that have disease-association data with a reduced set of annotations.</p> Source code in <code>src/otg/variant_index.py</code> <pre><code>@dataclass\nclass VariantIndexStep(VariantIndexStepConfig):\n    \"\"\"Variant index step.\n\n    Using a `VariantAnnotation` dataset as a reference, this step creates and writes a dataset of the type `VariantIndex` that includes only variants that have disease-association data with a reduced set of annotations.\n    \"\"\"\n\n    session: Session = Session()\n\n    def run(self: VariantIndexStep) -&gt; None:\n        \"\"\"Run variant index step to only variants in study-locus sets.\"\"\"\n        # Extract\n        va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n        study_locus = StudyLocus.from_parquet(\n            self.session, self.study_locus_path, recursiveFileLookup=True\n        )\n\n        # Transform\n        vi = VariantIndex.from_variant_annotation(va, study_locus)\n\n        # Load\n        self.session.logger.info(f\"Writing variant index to: {self.variant_index_path}\")\n        (\n            vi.df.write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.variant_index_path)\n        )\n</code></pre> <p>Variant index step requirements.</p> <p>Attributes:</p> Name Type Description <code>variant_annotation_path</code> <code>str</code> <p>Input variant annotation path.</p> <code>study_locus_path</code> <code>str</code> <p>Input study-locus path.</p> <code>variant_index_path</code> <code>str</code> <p>Output variant index path.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass VariantIndexStepConfig:\n    \"\"\"Variant index step requirements.\n\n    Attributes:\n        variant_annotation_path (str): Input variant annotation path.\n        study_locus_path (str): Input study-locus path.\n        variant_index_path (str): Output variant index path.\n    \"\"\"\n\n    _target_: str = \"otg.variant_index.VariantIndexStep\"\n    variant_annotation_path: str = MISSING\n    study_locus_path: str = MISSING\n    variant_index_path: str = MISSING\n</code></pre>"},{"location":"python_api/step/variant_index_step/#otg.variant_index.VariantIndexStep.run","title":"<code>run()</code>","text":"<p>Run variant index step to only variants in study-locus sets.</p> Source code in <code>src/otg/variant_index.py</code> <pre><code>def run(self: VariantIndexStep) -&gt; None:\n    \"\"\"Run variant index step to only variants in study-locus sets.\"\"\"\n    # Extract\n    va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n    study_locus = StudyLocus.from_parquet(\n        self.session, self.study_locus_path, recursiveFileLookup=True\n    )\n\n    # Transform\n    vi = VariantIndex.from_variant_annotation(va, study_locus)\n\n    # Load\n    self.session.logger.info(f\"Writing variant index to: {self.variant_index_path}\")\n    (\n        vi.df.write.partitionBy(\"chromosome\")\n        .mode(self.session.write_mode)\n        .parquet(self.variant_index_path)\n    )\n</code></pre>"},{"location":"python_api/step/variant_to_gene_step/","title":"V2G","text":"<p>             Bases: <code>V2GStepConfig</code></p> <p>Variant-to-gene (V2G) step.</p> <p>This step aims to generate a dataset that contains multiple pieces of evidence supporting the functional association of specific variants with genes. Some of the evidence types include:</p> <ol> <li>Chromatin interaction experiments, e.g. Promoter Capture Hi-C (PCHi-C).</li> <li>In silico functional predictions, e.g. Variant Effect Predictor (VEP) from Ensembl.</li> <li>Distance between the variant and each gene's canonical transcription start site (TSS).</li> </ol> Source code in <code>src/otg/v2g.py</code> <pre><code>@dataclass\nclass V2GStep(V2GStepConfig):\n    \"\"\"Variant-to-gene (V2G) step.\n\n    This step aims to generate a dataset that contains multiple pieces of evidence supporting the functional association of specific variants with genes. Some of the evidence types include:\n\n    1. Chromatin interaction experiments, e.g. Promoter Capture Hi-C (PCHi-C).\n    2. In silico functional predictions, e.g. Variant Effect Predictor (VEP) from Ensembl.\n    3. Distance between the variant and each gene's canonical transcription start site (TSS).\n\n    \"\"\"\n\n    session: Session = Session()\n\n    def run(self: V2GStep) -&gt; None:\n        \"\"\"Run V2G dataset generation.\"\"\"\n        # Read\n        gene_index = GeneIndex.from_parquet(self.session, self.gene_index_path)\n        vi = VariantIndex.from_parquet(self.session, self.variant_index_path).persist()\n        va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n        vep_consequences = self.session.spark.read.csv(\n            self.vep_consequences_path, sep=\"\\t\", header=True\n        ).select(\n            f.element_at(f.split(\"Accession\", r\"/\"), -1).alias(\n                \"variantFunctionalConsequenceId\"\n            ),\n            f.col(\"Term\").alias(\"label\"),\n            f.col(\"v2g_score\").cast(\"double\").alias(\"score\"),\n        )\n\n        # Transform\n        lift = LiftOverSpark(\n            # lift over variants to hg38\n            self.liftover_chain_file_path,\n            self.liftover_max_length_difference,\n        )\n        gene_index_filtered = gene_index.filter_by_biotypes(\n            # Filter gene index by approved biotypes to define V2G gene universe\n            list(self.approved_biotypes)\n        )\n        va_slimmed = va.filter_by_variant_df(\n            # Variant annotation reduced to the variant index to define V2G variant universe\n            vi.df\n        ).persist()\n        intervals = Intervals(\n            _df=reduce(\n                lambda x, y: x.unionByName(y, allowMissingColumns=True),\n                # create interval instances by parsing each source\n                [\n                    Intervals.from_source(\n                        self.session.spark, source_name, source_path, gene_index, lift\n                    ).df\n                    for source_name, source_path in self.intervals.items()\n                ],\n            ),\n            _schema=Intervals.get_schema(),\n        )\n        v2g_datasets = [\n            va_slimmed.get_distance_to_tss(gene_index_filtered, self.max_distance),\n            va_slimmed.get_most_severe_vep_v2g(vep_consequences, gene_index_filtered),\n            va_slimmed.get_polyphen_v2g(gene_index_filtered),\n            va_slimmed.get_sift_v2g(gene_index_filtered),\n            va_slimmed.get_plof_v2g(gene_index_filtered),\n            intervals.v2g(vi),\n        ]\n        v2g = V2G(\n            _df=reduce(\n                lambda x, y: x.unionByName(y, allowMissingColumns=True),\n                [dataset.df for dataset in v2g_datasets],\n            ).repartition(\"chromosome\"),\n            _schema=V2G.get_schema(),\n        )\n\n        # Load\n        (\n            v2g.df.write.partitionBy(\"chromosome\")\n            .mode(self.session.write_mode)\n            .parquet(self.v2g_path)\n        )\n</code></pre> <p>Variant to gene (V2G) step requirements.</p> <p>Attributes:</p> Name Type Description <code>variant_index_path</code> <code>str</code> <p>Input variant index path.</p> <code>variant_annotation_path</code> <code>str</code> <p>Input variant annotation path.</p> <code>gene_index_path</code> <code>str</code> <p>Input gene index path.</p> <code>vep_consequences_path</code> <code>str</code> <p>Input VEP consequences path.</p> <code>liftover_chain_file_path</code> <code>str</code> <p>Path to GRCh37 to GRCh38 chain file.</p> <code>liftover_max_length_difference</code> <code>int</code> <p>Maximum length difference for liftover.</p> <code>max_distance</code> <code>int</code> <p>Maximum distance to consider.</p> <code>approved_biotypes</code> <code>list[str]</code> <p>List of approved biotypes.</p> <code>intervals</code> <code>dict</code> <p>Dictionary of interval sources.</p> <code>v2g_path</code> <code>str</code> <p>Output V2G path.</p> Source code in <code>src/otg/config.py</code> <pre><code>@dataclass\nclass V2GStepConfig:\n    \"\"\"Variant to gene (V2G) step requirements.\n\n    Attributes:\n        variant_index_path (str): Input variant index path.\n        variant_annotation_path (str): Input variant annotation path.\n        gene_index_path (str): Input gene index path.\n        vep_consequences_path (str): Input VEP consequences path.\n        liftover_chain_file_path (str): Path to GRCh37 to GRCh38 chain file.\n        liftover_max_length_difference: Maximum length difference for liftover.\n        max_distance (int): Maximum distance to consider.\n        approved_biotypes (list[str]): List of approved biotypes.\n        intervals (dict): Dictionary of interval sources.\n        v2g_path (str): Output V2G path.\n    \"\"\"\n\n    _target_: str = \"otg.v2g.V2GStep\"\n    variant_index_path: str = MISSING\n    variant_annotation_path: str = MISSING\n    gene_index_path: str = MISSING\n    vep_consequences_path: str = MISSING\n    liftover_chain_file_path: str = MISSING\n    liftover_max_length_difference: int = 100\n    max_distance: int = 500_000\n    approved_biotypes: List[str] = field(\n        default_factory=lambda: [\n            \"protein_coding\",\n            \"3prime_overlapping_ncRNA\",\n            \"antisense\",\n            \"bidirectional_promoter_lncRNA\",\n            \"IG_C_gene\",\n            \"IG_D_gene\",\n            \"IG_J_gene\",\n            \"IG_V_gene\",\n            \"lincRNA\",\n            \"macro_lncRNA\",\n            \"non_coding\",\n            \"sense_intronic\",\n            \"sense_overlapping\",\n        ]\n    )\n    intervals: Dict[str, str] = field(default_factory=dict)\n    v2g_path: str = MISSING\n</code></pre>"},{"location":"python_api/step/variant_to_gene_step/#otg.v2g.V2GStep.run","title":"<code>run()</code>","text":"<p>Run V2G dataset generation.</p> Source code in <code>src/otg/v2g.py</code> <pre><code>def run(self: V2GStep) -&gt; None:\n    \"\"\"Run V2G dataset generation.\"\"\"\n    # Read\n    gene_index = GeneIndex.from_parquet(self.session, self.gene_index_path)\n    vi = VariantIndex.from_parquet(self.session, self.variant_index_path).persist()\n    va = VariantAnnotation.from_parquet(self.session, self.variant_annotation_path)\n    vep_consequences = self.session.spark.read.csv(\n        self.vep_consequences_path, sep=\"\\t\", header=True\n    ).select(\n        f.element_at(f.split(\"Accession\", r\"/\"), -1).alias(\n            \"variantFunctionalConsequenceId\"\n        ),\n        f.col(\"Term\").alias(\"label\"),\n        f.col(\"v2g_score\").cast(\"double\").alias(\"score\"),\n    )\n\n    # Transform\n    lift = LiftOverSpark(\n        # lift over variants to hg38\n        self.liftover_chain_file_path,\n        self.liftover_max_length_difference,\n    )\n    gene_index_filtered = gene_index.filter_by_biotypes(\n        # Filter gene index by approved biotypes to define V2G gene universe\n        list(self.approved_biotypes)\n    )\n    va_slimmed = va.filter_by_variant_df(\n        # Variant annotation reduced to the variant index to define V2G variant universe\n        vi.df\n    ).persist()\n    intervals = Intervals(\n        _df=reduce(\n            lambda x, y: x.unionByName(y, allowMissingColumns=True),\n            # create interval instances by parsing each source\n            [\n                Intervals.from_source(\n                    self.session.spark, source_name, source_path, gene_index, lift\n                ).df\n                for source_name, source_path in self.intervals.items()\n            ],\n        ),\n        _schema=Intervals.get_schema(),\n    )\n    v2g_datasets = [\n        va_slimmed.get_distance_to_tss(gene_index_filtered, self.max_distance),\n        va_slimmed.get_most_severe_vep_v2g(vep_consequences, gene_index_filtered),\n        va_slimmed.get_polyphen_v2g(gene_index_filtered),\n        va_slimmed.get_sift_v2g(gene_index_filtered),\n        va_slimmed.get_plof_v2g(gene_index_filtered),\n        intervals.v2g(vi),\n    ]\n    v2g = V2G(\n        _df=reduce(\n            lambda x, y: x.unionByName(y, allowMissingColumns=True),\n            [dataset.df for dataset in v2g_datasets],\n        ).repartition(\"chromosome\"),\n        _schema=V2G.get_schema(),\n    )\n\n    # Load\n    (\n        v2g.df.write.partitionBy(\"chromosome\")\n        .mode(self.session.write_mode)\n        .parquet(self.v2g_path)\n    )\n</code></pre>"}]}